import { Address, Network, TransferResult, Balances, Prefix, GetTxsParams, TxPage, Fees, AccountResult, VaultTxParams, NormalTxParams, FreezeParams, MultiSendParams, GetMarketsParams } from './types/binance';
import { BncClient } from '@binance-chain/javascript-sdk/lib/client';
/**
 * Interface for custom Binance client
 */
export interface BinanceClient {
    getBncClient(): BncClient;
    setNetwork(net: Network): BinanceClient;
    getNetwork(): Network;
    getClientUrl(): string;
    getExplorerUrl(): string;
    getPrefix(): Prefix;
    setPhrase(phrase: string): BinanceClient;
    getAddress(): string | undefined;
    validateAddress(address: string): boolean;
    getBalance(address?: Address): Promise<Balances>;
    getTransactions(params?: GetTxsParams): Promise<TxPage>;
    vaultTx(params: VaultTxParams): Promise<TransferResult>;
    normalTx(params: NormalTxParams): Promise<TransferResult>;
    freeze(params: FreezeParams): Promise<TransferResult>;
    unfreeze(params: FreezeParams): Promise<TransferResult>;
    getMarkets(params: GetMarketsParams): Promise<any>;
    multiSend(params: MultiSendParams): Promise<TransferResult>;
    getAccount(address: string): Promise<AccountResult | null>;
    getFees(): Promise<Fees>;
}
/**
 * Custom Binance client
 *
 * @example
 * ```
 * import { Client as BinanceClient } from '@thorchain/asgardex-binance'
 *
 * # testnet (by default)
 * const client = new BinanceClient('any BIP39 mnemonic')
 * await client.transfer(...)
 * # mainnet
 * const client = await binance.client('any BIP39 mnemonic', Network.MAINNET)
 * await client.transfer(...)
 *
 * ```
 *
 * @class Binance
 * @implements {BinanceClient}
 */
declare class Client implements BinanceClient {
    private network;
    private bncClient;
    private phrase;
    private address;
    private privateKey;
    private dirtyPrivateKey;
    /**
     * Client has to be initialised with network type and phrase
     * It will throw an error if an invalid phrase has been passed
     **/
    constructor({ network, phrase }: {
        network: Network;
        phrase?: string;
    });
    getBncClient(): BncClient;
    getAccount: (address: string) => Promise<AccountResult | null>;
    setNetwork(network: Network): BinanceClient;
    getNetwork(): Network;
    getClientUrl: () => string;
    getExplorerUrl: () => string;
    getPrefix: () => Prefix;
    static generatePhrase: () => string;
    setPhrase: (phrase: string) => BinanceClient;
    static validatePhrase: (phrase: string) => boolean;
    /**
     * @private
     * Returns private key
     * Throws an error if phrase has not been set before
     * */
    private getPrivateKey;
    private setPrivateKey;
    getAddress: () => string | undefined;
    validateAddress: (address: Address) => boolean;
    getBalance: (address?: string | undefined) => Promise<Balances>;
    getTransactions: (params?: GetTxsParams) => Promise<TxPage>;
    vaultTx: ({ addressFrom, addressTo, amount, asset, memo }: VaultTxParams) => Promise<TransferResult>;
    normalTx: ({ addressFrom, addressTo, amount, asset }: NormalTxParams) => Promise<TransferResult>;
    freeze: ({ address, asset, amount }: FreezeParams) => Promise<TransferResult>;
    unfreeze: ({ address, asset, amount }: FreezeParams) => Promise<TransferResult>;
    getMarkets: ({ limit, offset }: GetMarketsParams) => Promise<never[] | {
        result: any;
        status: number;
    }>;
    multiSend: ({ address, transactions, memo }: MultiSendParams) => Promise<{
        result: any;
        status: number;
    }>;
    getFees: () => Promise<Fees>;
}
export { Client };
