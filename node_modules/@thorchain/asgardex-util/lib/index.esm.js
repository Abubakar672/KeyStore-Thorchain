import BigNumber from 'bignumber.js';

/**
 * Helper to delay anything within an `async` function
 *
 * @param ms delay in milliseconds
 *
 * @example
 *
 * const anyAsyncFunc = async () => {
 *  // do something
 *  console.log('before delay')
 *  // wait for 200ms
 *  await delay(200)
 *  // and do other things
 *  console.log('after delay')
 * }
 */
var delay = function (ms) { return new Promise(function (resolve) { return setTimeout(resolve, ms); }); };

var getSwapOutput = function (inputAmount, pool, toRune) {
    // formula: (x * X * Y) / (x + X) ^ 2
    var x = inputAmount.amount();
    var X = toRune ? pool.assetBalance.amount() : pool.runeBalance.amount(); // input is asset if toRune
    var Y = toRune ? pool.runeBalance.amount() : pool.assetBalance.amount(); // output is rune if toRune
    var numerator = x.times(X).times(Y);
    var denominator = x.plus(X).pow(2);
    var result = numerator.div(denominator);
    return assetAmount(result);
};
var getSwapInput = function (toRune, pool, outputAmount) {
    // formula: (((X*Y)/y - 2*X) - sqrt(((X*Y)/y - 2*X)^2 - 4*X^2))/2
    // (part1 - sqrt(part1 - part2))/2
    var X = toRune ? pool.assetBalance.amount() : pool.runeBalance.amount(); // input is asset if toRune
    var Y = toRune ? pool.runeBalance.amount() : pool.assetBalance.amount(); // output is rune if toRune
    var y = outputAmount.amount();
    var part1 = X.times(Y).div(y).minus(X.times(2));
    var part2 = X.pow(2).times(4);
    var result = part1.minus(part1.pow(2).minus(part2).sqrt()).div(2);
    return assetAmount(result);
};
var getSwapSlip = function (inputAmount, pool, toRune) {
    // formula: (x) / (x + X)
    var x = inputAmount.amount();
    var X = toRune ? pool.assetBalance.amount() : pool.runeBalance.amount(); // input is asset if toRune
    var result = x.div(x.plus(X));
    return assetAmount(result);
};
var getSwapFee = function (inputAmount, pool, toRune) {
    // formula: (x * x * Y) / (x + X) ^ 2
    var x = inputAmount.amount();
    var X = toRune ? pool.assetBalance.amount() : pool.runeBalance.amount(); // input is asset if toRune
    var Y = toRune ? pool.runeBalance.amount() : pool.assetBalance.amount(); // output is rune if toRune
    var numerator = x.times(x).multipliedBy(Y);
    var denominator = x.plus(X).pow(2);
    var result = numerator.div(denominator);
    return assetAmount(result);
};
var getValueOfAssetInRune = function (inputAsset, pool) {
    // formula: (a * R) / A) => R per A (Runeper$)
    var t = inputAsset.amount();
    var R = pool.runeBalance.amount();
    var A = pool.assetBalance.amount();
    var result = t.times(R).div(A);
    return assetAmount(result);
};
var getValueOfRuneInAsset = function (inputRune, pool) {
    // formula: (r * A) / R) => A per R ($perRune)
    var r = inputRune.amount();
    var R = pool.runeBalance.amount();
    var A = pool.assetBalance.amount();
    var result = r.times(A).div(R);
    return assetAmount(result);
};
var getDoubleSwapOutput = function (inputAmount, pool1, pool2) {
    // formula: getSwapOutput(pool1) => getSwapOutput(pool2)
    var r = getSwapOutput(inputAmount, pool1, true);
    var output = getSwapOutput(r, pool2, false);
    return output;
};
var getDoubleSwapInput = function (pool1, pool2, outputAmount) {
    // formula: getSwapInput(pool2) => getSwapInput(pool1)
    var y = getSwapInput(false, pool2, outputAmount);
    var x = getSwapInput(true, pool1, y);
    return x;
};
var getDoubleSwapSlip = function (inputAmount, pool1, pool2) {
    // formula: getSwapSlip1(input1) + getSwapSlip2(getSwapOutput1 => input2)
    var swapSlip1 = getSwapSlip(inputAmount, pool1, true);
    var r = getSwapOutput(inputAmount, pool1, true);
    var swapSlip2 = getSwapSlip(r, pool2, false);
    var result = swapSlip1.amount().plus(swapSlip2.amount());
    return assetAmount(result);
};
var getDoubleSwapFee = function (inputAmount, pool1, pool2) {
    // formula: getSwapFee1 + getSwapFee2
    var fee1 = getSwapFee(inputAmount, pool1, true);
    var r = getSwapOutput(inputAmount, pool1, true);
    var fee2 = getSwapFee(r, pool2, false);
    var fee1Asset = getValueOfRuneInAsset(fee1, pool2);
    var result = fee2.amount().plus(fee1Asset.amount());
    return assetAmount(result);
};
var getValueOfAsset1InAsset2 = function (inputAsset, pool1, pool2) {
    // formula: (A2 / R) * (R / A1) => A2/A1 => A2 per A1 ($ per Asset)
    var A2perR = getValueOfRuneInAsset(assetAmount(1), pool2);
    var RperA1 = getValueOfAssetInRune(inputAsset, pool1);
    var result = A2perR.amount().times(RperA1.amount());
    return assetAmount(result);
};

var getStakeUnits = function (stake, pool) {
    // formula: ((R + T) (r T + R t))/(4 R T)
    // part1 * (part2 + part3) / denominator
    var r = stake.rune.amount();
    var t = stake.asset.amount();
    var R = pool.runeBalance.amount().plus(r); // Must add r first
    var T = pool.assetBalance.amount().plus(t); // Must add t first
    var part1 = R.plus(T);
    var part2 = r.times(T);
    var part3 = R.times(t);
    var numerator = part1.times(part2.plus(part3));
    var denominator = R.times(T).times(4);
    var result = numerator.div(denominator);
    return assetAmount(result);
};
var getPoolShare = function (unitData, pool) {
    // formula: (rune * part) / total; (asset * part) / total
    var units = unitData.stakeUnits.amount();
    var total = unitData.totalUnits.amount();
    var R = pool.runeBalance.amount();
    var T = pool.assetBalance.amount();
    var asset = T.times(units).div(total);
    var rune = R.times(units).div(total);
    var stakeData = {
        asset: assetAmount(asset),
        rune: assetAmount(rune),
    };
    return stakeData;
};
var getSlipOnStake = function (stake, pool) {
    // formula: (t * R - T * r)/ (T*r + R*T)
    var r = stake.rune.amount();
    var t = stake.asset.amount();
    var R = pool.runeBalance.amount();
    var T = pool.assetBalance.amount();
    var numerator = t.times(R).minus(T.times(r));
    var denominator = T.times(r).plus(R.times(T));
    var result = numerator.div(denominator).abs();
    return assetAmount(result);
};

/**
 * Shortcut to create a BigNumber
 */
var bn = function (value) { return new BigNumber(value); };
/**
 * Helper to check whether a BigNumber is valid or not
 * */
var isValidBN = function (value) { return !value.isNaN(); };
/**
 * Helper to create a big number from string or number
 * If it fails to create a big number, a big number with value 0 will be returned instead
 * */
var bnOrZero = function (value) {
    var b = value ? bn(value) : bn(0);
    return isValidBN(b) ? b : bn(0);
};
/**
 * Helper to validate a possible BigNumber
 * If the given valie is invalid or undefined, 0 is returned as a BigNumber
 */
var validBNOrZero = function (value) { return (value && isValidBN(value) ? value : bn(0)); };
/**
 * Format a BaseNumber to a string depending on given decimal places
 * */
var formatBN = function (value, decimalPlaces) {
    if (decimalPlaces === void 0) { decimalPlaces = 2; }
    return value.toFormat(decimalPlaces);
};
var SymbolPosition;
(function (SymbolPosition) {
    SymbolPosition["BEFORE"] = "before";
    SymbolPosition["AFTER"] = "after";
})(SymbolPosition || (SymbolPosition = {}));
/**
 * Formats a big number value by prefixing it with `$`
 */
var formatBNCurrency = function (n, decimalPlaces, symbol, position) {
    if (decimalPlaces === void 0) { decimalPlaces = 2; }
    if (symbol === void 0) { symbol = '$'; }
    if (position === void 0) { position = SymbolPosition.BEFORE; }
    var value = formatBN(n, decimalPlaces);
    if (position === SymbolPosition.BEFORE) {
        return "" + symbol + value;
    }
    return "" + value + symbol;
};
/**
 * Helper to get a fixed `BigNumber`
 * Returns zero `BigNumber` if `value` is invalid
 * */
var fixedBN = function (value, decimalPlaces) {
    if (decimalPlaces === void 0) { decimalPlaces = 2; }
    var n = bn(value || 0);
    var fixedBN = isValidBN(n) ? n.toFixed(decimalPlaces) : bn(0).toFixed(decimalPlaces);
    return bn(fixedBN);
};

var Denomination;
(function (Denomination) {
    /**
     * values for asset amounts in base units (no decimal)
     */
    Denomination["BASE"] = "BASE";
    /**
     * values of asset amounts (w/ decimal)
     */
    Denomination["ASSET"] = "ASSET";
})(Denomination || (Denomination = {}));

/**
 * Number of asset decimals - e.g. any of Binance chain assets
 * For example:
 * RUNE has a maximum of 8 digits of decimal
 * 0.00000001 RUNE == 1 รฐ (tor)
 * */
var ASSET_DECIMAL = 8;
/**
 * Base number of assets - e.g. any of Binance chain assets
 * For example:
 * The amount of RUNE is boosted by 1e8 for decimal part
 * 1 RUNE == 100,000,000 รฐ (tor)
 */
var BASE_NUMBER = Math.pow(10, ASSET_DECIMAL); // 1e8
/**
 * Factory to create any values of assets (e.g. RUNE)
 * If the value is undefined, 0 is returned
 * */
var assetAmount = function (value, decimal) {
    if (decimal === void 0) { decimal = ASSET_DECIMAL; }
    return ({
        type: Denomination.ASSET,
        amount: function () { return fixedBN(value, decimal); },
    });
};
/**
 * Factory to create base amounts (e.g. tor)
 * If the value is undefined, 0 is returned
 * */
var baseAmount = function (value) {
    return ({
        type: Denomination.BASE,
        amount: function () { return fixedBN(value, 0); },
    });
};
/**
 * Helper to convert values for a asset from base values (e.g. RUNE from tor)
 * */
var baseToAsset = function (base, decimal) {
    if (decimal === void 0) { decimal = ASSET_DECIMAL; }
    var value = base.amount().div(BASE_NUMBER).decimalPlaces(decimal);
    return assetAmount(value);
};
/**
 * Helper to convert asset to base values (e.g. tor -> RUNE)
 * */
var assetToBase = function (asset) {
    var value = asset.amount().multipliedBy(BASE_NUMBER).integerValue();
    return baseAmount(value);
};
/**
 * Guard to check whether value is an amount of asset or not
 * */
var isAssetAmount = function (v) { var _a; return (_a = v.type === Denomination.ASSET) !== null && _a !== void 0 ? _a : false; };
/**
 * Guard to check whether value is an amount of a base value or not
 * */
var isBaseAmount = function (v) { var _a; return (_a = v.type === Denomination.BASE) !== null && _a !== void 0 ? _a : false; };
/**
 * Formats a asset value in a user friendly way,
 * depending on given decimal places
 */
var formatAssetAmount = function (asset, decimal) {
    if (decimal === void 0) { decimal = 2; }
    return formatBN(asset.amount(), decimal);
};
/**
 * Formats a asset value by prefixing it with `$`
 */
var formatAssetAmountCurrency = function (asset, ticker) {
    var assetFormatted = formatAssetAmount(asset);
    if (ticker === null || ticker === void 0 ? void 0 : ticker.includes('USD')) {
        return "$" + assetFormatted;
    }
    var symbol = (ticker === null || ticker === void 0 ? void 0 : ticker.includes('.')) ? ticker.split('.')[1] : '';
    if (symbol) {
        return assetFormatted + " (" + symbol + ")";
    }
    return "$" + assetFormatted;
};
/**
 * Format a base value as a asset in a user friendly way,
 * depending on given decimal places
 */
var formatBaseAsAssetAmount = function (base, decimal) {
    if (decimal === void 0) { decimal = 2; }
    return formatAssetAmount(baseToAsset(base), decimal);
};

export { ASSET_DECIMAL, BASE_NUMBER, Denomination, assetAmount, assetToBase, baseAmount, baseToAsset, bn, bnOrZero, delay, fixedBN, formatAssetAmount, formatAssetAmountCurrency, formatBN, formatBNCurrency, formatBaseAsAssetAmount, getDoubleSwapFee, getDoubleSwapInput, getDoubleSwapOutput, getDoubleSwapSlip, getPoolShare, getSlipOnStake, getStakeUnits, getSwapFee, getSwapInput, getSwapOutput, getSwapSlip, getValueOfAsset1InAsset2, getValueOfAssetInRune, getValueOfRuneInAsset, isAssetAmount, isBaseAmount, isValidBN, validBNOrZero };
//# sourceMappingURL=index.esm.js.map
