'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var providers = require('@ethersproject/providers');
var xchainClient = require('@xchainjs/xchain-client');
var xchainUtil = require('@xchainjs/xchain-util');
var ethers = require('ethers');
var utils = require('ethers/lib/utils');
var axios = require('axios');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var axios__default = /*#__PURE__*/_interopDefaultLegacy(axios);

(function (EthNetwork) {
    EthNetwork["Test"] = "ropsten";
    EthNetwork["Main"] = "homestead";
})(exports.EthNetwork || (exports.EthNetwork = {}));

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __spreadArray(to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
}

var erc20ABI = [
	{
		inputs: [
		],
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "Approval",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "Transfer",
		type: "event"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		name: "allowance",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "approve",
		outputs: [
			{
				internalType: "bool",
				name: "success",
				type: "bool"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		name: "balanceOf",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "decimals",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "name",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "symbol",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "totalSupply",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "transfer",
		outputs: [
			{
				internalType: "bool",
				name: "success",
				type: "bool"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "from",
				type: "address"
			},
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "value",
				type: "uint256"
			}
		],
		name: "transferFrom",
		outputs: [
			{
				internalType: "bool",
				name: "success",
				type: "bool"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	}
];

var ETH_DECIMAL = 18;
// from https://github.com/MetaMask/metamask-extension/blob/ee205b893fe61dc4736efc576e0663189a9d23da/ui/app/pages/send/send.constants.js#L39
// and based on recommendations of https://ethgasstation.info/blog/gas-limit/
var SIMPLE_GAS_COST = ethers.BigNumber.from(21000);
var BASE_TOKEN_GAS_COST = ethers.BigNumber.from(100000);
// default gas price in gwei
var DEFAULT_GAS_PRICE = 50;
var ETHAddress = '0x0000000000000000000000000000000000000000';
var MAX_APPROVAL = ethers.BigNumber.from(2).pow(256).sub(1);
/**
 * Network -> EthNetwork
 *
 * @param {Network} network
 * @returns {EthNetwork}
 */
var xchainNetworkToEths = function (network) {
    switch (network) {
        case xchainClient.Network.Mainnet:
            return exports.EthNetwork.Main;
        case xchainClient.Network.Testnet:
            return exports.EthNetwork.Test;
    }
};
/**
 * Validate the given address.
 *
 * @param {Address} address
 * @returns {boolean} `true` or `false`
 */
var validateAddress = function (address) {
    try {
        ethers.ethers.utils.getAddress(address);
        return true;
    }
    catch (error) {
        return false;
    }
};
/**
 * Get token address from asset.
 *
 * @param {Asset} asset
 * @returns {string|null} The token address.
 */
var getTokenAddress = function (asset) {
    try {
        // strip 0X only - 0x is still valid
        return ethers.ethers.utils.getAddress(asset.symbol.slice(asset.ticker.length + 1).replace(/^0X/, ''));
    }
    catch (err) {
        return null;
    }
};
/**
 * Check if the symbol is valid.
 *
 * @param {string|null|undefined} symbol
 * @returns {boolean} `true` or `false`.
 */
var validateSymbol = function (symbol) { return (symbol ? symbol.length >= 3 : false); };
/**
 * Get transactions from token tx
 *
 * @param {TokenTransactionInfo} tx
 * @returns {Tx|null} The parsed transaction.
 */
var getTxFromTokenTransaction = function (tx) {
    var decimals = parseInt(tx.tokenDecimal) || ETH_DECIMAL;
    var symbol = tx.tokenSymbol;
    var address = tx.contractAddress;
    if (validateSymbol(symbol) && validateAddress(address)) {
        var tokenAsset = xchainUtil.assetFromString(xchainUtil.Chain.Ethereum + "." + symbol + "-" + address);
        if (tokenAsset) {
            return {
                asset: tokenAsset,
                from: [
                    {
                        from: tx.from,
                        amount: xchainUtil.baseAmount(tx.value, decimals),
                    },
                ],
                to: [
                    {
                        to: tx.to,
                        amount: xchainUtil.baseAmount(tx.value, decimals),
                    },
                ],
                date: new Date(parseInt(tx.timeStamp) * 1000),
                type: xchainClient.TxType.Transfer,
                hash: tx.hash,
            };
        }
    }
    return null;
};
/**
 * Get transactions from ETH transaction
 *
 * @param {ETHTransactionInfo} tx
 * @returns {Tx} The parsed transaction.
 */
var getTxFromEthTransaction = function (tx) {
    return {
        asset: xchainUtil.AssetETH,
        from: [
            {
                from: tx.from,
                amount: xchainUtil.baseAmount(tx.value, ETH_DECIMAL),
            },
        ],
        to: [
            {
                to: tx.to,
                amount: xchainUtil.baseAmount(tx.value, ETH_DECIMAL),
            },
        ],
        date: new Date(parseInt(tx.timeStamp) * 1000),
        type: xchainClient.TxType.Transfer,
        hash: tx.hash,
    };
};
/**
 * Get transactions from operation
 *
 * @param {TransactionOperation} operation
 * @returns {Tx|null} The parsed transaction.
 */
var getTxFromEthplorerTokenOperation = function (operation) {
    var decimals = parseInt(operation.tokenInfo.decimals) || ETH_DECIMAL;
    var _a = operation.tokenInfo, symbol = _a.symbol, address = _a.address;
    if (validateSymbol(symbol) && validateAddress(address)) {
        var tokenAsset = xchainUtil.assetFromString(xchainUtil.Chain.Ethereum + "." + symbol + "-" + address);
        if (tokenAsset) {
            return {
                asset: tokenAsset,
                from: [
                    {
                        from: operation.from,
                        amount: xchainUtil.baseAmount(operation.value, decimals),
                    },
                ],
                to: [
                    {
                        to: operation.to,
                        amount: xchainUtil.baseAmount(operation.value, decimals),
                    },
                ],
                date: new Date(operation.timestamp * 1000),
                type: operation.type === 'transfer' ? xchainClient.TxType.Transfer : xchainClient.TxType.Unknown,
                hash: operation.transactionHash,
            };
        }
    }
    return null;
};
/**
 * Get transactions from ETH transaction
 *
 * @param {TransactionInfo} txInfo
 * @returns {Tx} The parsed transaction.
 */
var getTxFromEthplorerEthTransaction = function (txInfo) {
    return {
        asset: xchainUtil.AssetETH,
        from: [
            {
                from: txInfo.from,
                amount: xchainUtil.assetToBase(xchainUtil.assetAmount(txInfo.value, ETH_DECIMAL)),
            },
        ],
        to: [
            {
                to: txInfo.to,
                amount: xchainUtil.assetToBase(xchainUtil.assetAmount(txInfo.value, ETH_DECIMAL)),
            },
        ],
        date: new Date(txInfo.timestamp * 1000),
        type: xchainClient.TxType.Transfer,
        hash: txInfo.hash,
    };
};
/**
 * Calculate fees by multiplying .
 *
 * @returns {Fees} The default gas price.
 */
var getFee = function (_a) {
    var gasPrice = _a.gasPrice, gasLimit = _a.gasLimit;
    return xchainUtil.baseAmount(gasPrice.amount().multipliedBy(gasLimit.toString()), ETH_DECIMAL);
};
var estimateDefaultFeesWithGasPricesAndLimits = function (asset) {
    var gasPrices = {
        average: xchainUtil.baseAmount(utils.parseUnits(DEFAULT_GAS_PRICE.toString(), 'gwei').toString(), ETH_DECIMAL),
        fast: xchainUtil.baseAmount(utils.parseUnits((DEFAULT_GAS_PRICE * 2).toString(), 'gwei').toString(), ETH_DECIMAL),
        fastest: xchainUtil.baseAmount(utils.parseUnits((DEFAULT_GAS_PRICE * 3).toString(), 'gwei').toString(), ETH_DECIMAL),
    };
    var fastGP = gasPrices.fast, fastestGP = gasPrices.fastest, averageGP = gasPrices.average;
    var assetAddress;
    if (asset && xchainUtil.assetToString(asset) !== xchainUtil.assetToString(xchainUtil.AssetETH)) {
        assetAddress = getTokenAddress(asset);
    }
    var gasLimit;
    if (assetAddress && assetAddress !== ETHAddress) {
        gasLimit = ethers.BigNumber.from(BASE_TOKEN_GAS_COST);
    }
    else {
        gasLimit = ethers.BigNumber.from(SIMPLE_GAS_COST);
    }
    return {
        gasPrices: gasPrices,
        gasLimit: gasLimit,
        fees: {
            type: xchainClient.FeeType.PerByte,
            average: getFee({ gasPrice: averageGP, gasLimit: gasLimit }),
            fast: getFee({ gasPrice: fastGP, gasLimit: gasLimit }),
            fastest: getFee({ gasPrice: fastestGP, gasLimit: gasLimit }),
        },
    };
};
/**
 * Get the default fees.
 *
 * @returns {Fees} The default gas price.
 */
var getDefaultFees = function (asset) {
    var fees = estimateDefaultFeesWithGasPricesAndLimits(asset).fees;
    return fees;
};
/**
 * Get the default gas price.
 *
 * @returns {Fees} The default gas prices.
 */
var getDefaultGasPrices = function (asset) {
    var gasPrices = estimateDefaultFeesWithGasPricesAndLimits(asset).gasPrices;
    return gasPrices;
};
/**
 * Get address prefix based on the network.
 *
 * @returns {string} The address prefix based on the network.
 *
 **/
var getPrefix = function () { return '0x'; };
/**
 * Filter self txs
 *
 * @returns {T[]}
 *
 **/
var filterSelfTxs = function (txs) {
    var filterTxs = txs.filter(function (tx) { return tx.from !== tx.to; });
    var selfTxs = txs.filter(function (tx) { return tx.from === tx.to; });
    var _loop_1 = function () {
        var selfTx = selfTxs[0];
        filterTxs.push(selfTx);
        selfTxs = selfTxs.filter(function (tx) { return tx.hash !== selfTx.hash; });
    };
    while (selfTxs.length) {
        _loop_1();
    }
    return filterTxs;
};
/**
 * Get Decimals
 *
 * @param {Asset} asset
 * @returns {Number} the decimal of a given asset
 *
 * @throws {"Invalid asset"} Thrown if the given asset is invalid
 */
var getDecimal = function (asset, provider) { return __awaiter(void 0, void 0, void 0, function () {
    var assetAddress, contract, decimal;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (xchainUtil.assetToString(asset) === xchainUtil.assetToString(xchainUtil.AssetETH))
                    return [2 /*return*/, ETH_DECIMAL];
                assetAddress = getTokenAddress(asset);
                if (!assetAddress)
                    throw new Error("Invalid asset " + xchainUtil.assetToString(asset));
                contract = new ethers.ethers.Contract(assetAddress, erc20ABI, provider);
                return [4 /*yield*/, contract.decimals()];
            case 1:
                decimal = _a.sent();
                return [2 /*return*/, ethers.ethers.BigNumber.from(decimal).toNumber()];
        }
    });
}); };
/**
 * Get Token Balances
 *
 * @param {TokenBalance[]} tokenBalances
 * @returns {Balance[]} the parsed balances
 *
 */
var getTokenBalances = function (tokenBalances) {
    return tokenBalances.reduce(function (acc, cur) {
        var _a;
        var _b = cur.tokenInfo, symbol = _b.symbol, tokenAddress = _b.address;
        if (validateSymbol(symbol) && validateAddress(tokenAddress) && ((_a = cur === null || cur === void 0 ? void 0 : cur.tokenInfo) === null || _a === void 0 ? void 0 : _a.decimals) !== undefined) {
            var decimals = parseInt(cur.tokenInfo.decimals, 10);
            var tokenAsset = xchainUtil.assetFromString(xchainUtil.Chain.Ethereum + "." + symbol + "-" + ethers.ethers.utils.getAddress(tokenAddress));
            if (tokenAsset) {
                return __spreadArray(__spreadArray([], acc), [
                    {
                        asset: tokenAsset,
                        amount: xchainUtil.baseAmount(cur.balance, decimals),
                    },
                ]);
            }
        }
        return acc;
    }, []);
};

var getApiKeyQueryParameter = function (apiKey) { return (!!apiKey ? "&apiKey=" + apiKey : ''); };
/**
 * SafeGasPrice, ProposeGasPrice And FastGasPrice returned in string-Gwei
 *
 * @see https://etherscan.io/apis#gastracker
 *
 * @param {string} baseUrl The etherscan node url.
 * @param {string} apiKey The etherscan API key. (optional)
 * @returns {GasOracleResponse} LastBlock, SafeGasPrice, ProposeGasPrice, FastGasPrice
 */
var getGasOracle = function (baseUrl, apiKey) { return __awaiter(void 0, void 0, void 0, function () {
    var url;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                url = baseUrl + '/api?module=gastracker&action=gasoracle';
                return [4 /*yield*/, axios__default['default'].get(url + getApiKeyQueryParameter(apiKey))];
            case 1: return [2 /*return*/, (_a.sent()).data.result];
        }
    });
}); };
/**
 * Get token balance
 *
 * @see https://etherscan.io/apis#tokens
 *
 * @param {string} baseUrl The etherscan node url.
 * @param {string} address The address.
 * @param {string} assetAddress The token contract address.
 * @param {string} apiKey The etherscan API key. (optional)
 * @returns {BigNumberish} The token balance
 */
var getTokenBalance = function (_a) {
    var baseUrl = _a.baseUrl, address = _a.address, assetAddress = _a.assetAddress, apiKey = _a.apiKey;
    return __awaiter(void 0, void 0, void 0, function () {
        var url;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    url = baseUrl + ("/api?module=account&action=tokenbalance&contractaddress=" + assetAddress + "&address=" + address);
                    return [4 /*yield*/, axios__default['default'].get(url + getApiKeyQueryParameter(apiKey))];
                case 1: return [2 /*return*/, (_b.sent()).data.result];
            }
        });
    });
};
/**
 * Get ETH transaction history
 *
 * @see https://etherscan.io/apis#accounts
 *
 * @param {string} baseUrl The etherscan node url.
 * @param {string} address The address.
 * @param {TransactionHistoryParam} params The search options.
 * @param {string} apiKey The etherscan API key. (optional)
 * @returns {ETHTransactionInfo[]} The ETH transaction history
 */
var getETHTransactionHistory = function (_a) {
    var baseUrl = _a.baseUrl, address = _a.address, page = _a.page, offset = _a.offset, startblock = _a.startblock, endblock = _a.endblock, apiKey = _a.apiKey;
    return __awaiter(void 0, void 0, void 0, function () {
        var url, result;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    url = baseUrl + "/api?module=account&action=txlist&sort=desc" + getApiKeyQueryParameter(apiKey);
                    if (address)
                        url += "&address=" + address;
                    if (offset)
                        url += "&offset=" + offset;
                    if (page)
                        url += "&page=" + page;
                    if (startblock)
                        url += "&startblock=" + startblock;
                    if (endblock)
                        url += "&endblock=" + endblock;
                    return [4 /*yield*/, axios__default['default'].get(url)];
                case 1:
                    result = (_b.sent()).data.result;
                    if (JSON.stringify(result).includes('Invalid API Key'))
                        throw new Error('Invalid API Key');
                    if (typeof result !== 'object')
                        throw new Error(result);
                    return [2 /*return*/, filterSelfTxs(result)
                            .filter(function (tx) { return !xchainUtil.bnOrZero(tx.value).isZero(); })
                            .map(getTxFromEthTransaction)];
            }
        });
    });
};
/**
 * Get token transaction history
 *
 * @see https://etherscan.io/apis#accounts
 *
 * @param {string} baseUrl The etherscan node url.
 * @param {string} address The address.
 * @param {TransactionHistoryParam} params The search options.
 * @param {string} apiKey The etherscan API key. (optional)
 * @returns {Tx[]} The token transaction history
 */
var getTokenTransactionHistory = function (_a) {
    var baseUrl = _a.baseUrl, address = _a.address, assetAddress = _a.assetAddress, page = _a.page, offset = _a.offset, startblock = _a.startblock, endblock = _a.endblock, apiKey = _a.apiKey;
    return __awaiter(void 0, void 0, void 0, function () {
        var url, result;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    url = baseUrl + "/api?module=account&action=tokentx&sort=desc" + getApiKeyQueryParameter(apiKey);
                    if (address)
                        url += "&address=" + address;
                    if (assetAddress)
                        url += "&contractaddress=" + assetAddress;
                    if (offset)
                        url += "&offset=" + offset;
                    if (page)
                        url += "&page=" + page;
                    if (startblock)
                        url += "&startblock=" + startblock;
                    if (endblock)
                        url += "&endblock=" + endblock;
                    return [4 /*yield*/, axios__default['default'].get(url)];
                case 1:
                    result = (_b.sent()).data.result;
                    if (JSON.stringify(result).includes('Invalid API Key'))
                        throw new Error('Invalid API Key');
                    return [2 /*return*/, filterSelfTxs(result)
                            .filter(function (tx) { return !xchainUtil.bnOrZero(tx.value).isZero(); })
                            .reduce(function (acc, cur) {
                            var tx = getTxFromTokenTransaction(cur);
                            return tx ? __spreadArray(__spreadArray([], acc), [tx]) : acc;
                        }, [])];
            }
        });
    });
};

/**
 * Get address information.
 *
 * @see https://github.com/EverexIO/Ethplorer/wiki/Ethplorer-API#get-address-info
 *
 * @param {string} baseUrl The ethplorer api url.
 * @param {string} address
 * @param {string} apiKey The ethplorer API key. (optional)
 * @returns {AddressInfo} The address information.
 */
var getAddress = function (baseUrl, address, apiKey) { return __awaiter(void 0, void 0, void 0, function () {
    var response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, axios__default['default'].get(baseUrl + "/getAddressInfo/" + address, {
                    params: {
                        apiKey: apiKey || 'freekey',
                    },
                })];
            case 1:
                response = _a.sent();
                return [2 /*return*/, response.data];
        }
    });
}); };
/**
 * Get transaction by hash.
 *
 * @see https://github.com/EverexIO/Ethplorer/wiki/Ethplorer-API#get-transaction-info
 *
 * @param {string} baseUrl The ethplorer api url.
 * @param {string} hash The transaction hash.
 * @param {string} apiKey The ethplorer API key. (optional)
 * @returns {Transactions} The transaction result.
 */
var getTxInfo = function (baseUrl, hash, apiKey) { return __awaiter(void 0, void 0, void 0, function () {
    var response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, axios__default['default'].get(baseUrl + "/getTxInfo/" + hash, {
                    params: {
                        apiKey: apiKey || 'freekey',
                    },
                })];
            case 1:
                response = _a.sent();
                return [2 /*return*/, response.data];
        }
    });
}); };

/**
 * Custom Ethereum client
 */
var Client = /** @class */ (function (_super) {
    __extends(Client, _super);
    /**
     * Constructor
     * @param {EthereumClientParams} params
     */
    function Client(_a) {
        var _b;
        var _c = _a.network, network = _c === void 0 ? xchainClient.Network.Testnet : _c, _d = _a.ethplorerUrl, ethplorerUrl = _d === void 0 ? 'https://api.ethplorer.io' : _d, _e = _a.ethplorerApiKey, ethplorerApiKey = _e === void 0 ? 'freekey' : _e, explorerUrl = _a.explorerUrl, _f = _a.phrase, phrase = _f === void 0 ? '' : _f, _g = _a.rootDerivationPaths, rootDerivationPaths = _g === void 0 ? (_b = {},
            _b[xchainClient.Network.Mainnet] = "m/44'/60'/0'/0/",
            _b[xchainClient.Network.Testnet] = "m/44'/60'/0'/0/",
            _b) : _g, etherscanApiKey = _a.etherscanApiKey, infuraCreds = _a.infuraCreds;
        var _this = _super.call(this, xchainUtil.Chain.Ethereum, { network: network, rootDerivationPaths: rootDerivationPaths }) || this;
        _this.providers = new Map();
        _this.ethNetwork = xchainNetworkToEths(network);
        _this.rootDerivationPaths = rootDerivationPaths;
        _this.infuraCreds = infuraCreds;
        _this.etherscanApiKey = etherscanApiKey;
        _this.ethplorerUrl = ethplorerUrl;
        _this.ethplorerApiKey = ethplorerApiKey;
        _this.explorerUrl = explorerUrl || _this.getDefaultExplorerURL();
        _this.setupProviders();
        _this.setPhrase(phrase);
        return _this;
    }
    /**
     * Purge client.
     *
     * @returns {void}
     */
    Client.prototype.purgeClient = function () {
        _super.prototype.purgeClient.call(this);
        this.hdNode = utils.HDNode.fromMnemonic('');
    };
    /**
     * Set/Update the explorer url.
     *
     * @param {string} url The explorer url.
     * @returns {void}
     */
    Client.prototype.setExplorerURL = function (url) {
        this.explorerUrl = url;
    };
    /**
     * Get the current address.
     *
     * @param {number} walletIndex (optional) HD wallet index
     * @returns {Address} The current address.
     *
     * @throws {"Phrase must be provided"}
     * Thrown if phrase has not been set before. A phrase is needed to create a wallet and to derive an address from it.
     */
    Client.prototype.getAddress = function (walletIndex) {
        if (walletIndex === void 0) { walletIndex = 0; }
        if (walletIndex < 0) {
            throw new Error('index must be greater than zero');
        }
        return this.hdNode.derivePath(this.getFullDerivationPath(walletIndex)).address.toLowerCase();
    };
    /**
     * Get etherjs wallet interface.
     *
     * @param {number} walletIndex (optional) HD wallet index
     * @returns {Wallet} The current etherjs wallet interface.
     *
     * @throws {"Phrase must be provided"}
     * Thrown if phrase has not been set before. A phrase is needed to create a wallet and to derive an address from it.
     */
    Client.prototype.getWallet = function (walletIndex) {
        if (walletIndex === void 0) { walletIndex = 0; }
        return new ethers.Wallet(this.hdNode.derivePath(this.getFullDerivationPath(walletIndex))).connect(this.getProvider());
    };
    Client.prototype.setupProviders = function () {
        if (this.infuraCreds) {
            // Infura provider takes either a string of project id
            // or an object of id and secret
            var testnetProvider = this.infuraCreds.projectSecret
                ? new ethers.ethers.providers.InfuraProvider(exports.EthNetwork.Test, this.infuraCreds)
                : new ethers.ethers.providers.InfuraProvider(exports.EthNetwork.Test, this.infuraCreds.projectId);
            var mainnetProvider = this.infuraCreds.projectSecret
                ? new ethers.ethers.providers.InfuraProvider(exports.EthNetwork.Main, this.infuraCreds)
                : new ethers.ethers.providers.InfuraProvider(exports.EthNetwork.Main, this.infuraCreds.projectId);
            this.providers.set(xchainClient.Network.Testnet, testnetProvider);
            this.providers.set(xchainClient.Network.Mainnet, mainnetProvider);
        }
        else {
            this.providers.set(xchainClient.Network.Testnet, providers.getDefaultProvider(exports.EthNetwork.Test));
            this.providers.set(xchainClient.Network.Mainnet, providers.getDefaultProvider(exports.EthNetwork.Main));
        }
    };
    /**
     * Get etherjs Provider interface.
     *
     * @returns {Provider} The current etherjs Provider interface.
     */
    Client.prototype.getProvider = function () {
        return this.providers.get(this.network) || providers.getDefaultProvider(this.network);
    };
    /**
     * Get etherjs EtherscanProvider interface.
     *
     * @returns {EtherscanProvider} The current etherjs EtherscanProvider interface.
     */
    Client.prototype.getEtherscanProvider = function () {
        return new providers.EtherscanProvider(this.ethNetwork, this.etherscanApiKey);
    };
    /**
     * Get the explorer url.
     *
     * @returns {string} The explorer url for ethereum based on the current network.
     */
    Client.prototype.getExplorerUrl = function () {
        return this.getExplorerUrlByNetwork(this.getNetwork());
    };
    /**
     * Get the explorer url.
     *
     * @returns {ExplorerUrl} The explorer url (both mainnet and testnet) for ethereum.
     */
    Client.prototype.getDefaultExplorerURL = function () {
        var _a;
        return _a = {},
            _a[xchainClient.Network.Testnet] = 'https://ropsten.etherscan.io',
            _a[xchainClient.Network.Mainnet] = 'https://etherscan.io',
            _a;
    };
    /**
     * Get the explorer url.
     *
     * @param {Network} network
     * @returns {string} The explorer url for ethereum based on the network.
     */
    Client.prototype.getExplorerUrlByNetwork = function (network) {
        return this.explorerUrl[network];
    };
    /**
     * Get the explorer url for the given address.
     *
     * @param {Address} address
     * @returns {string} The explorer url for the given address.
     */
    Client.prototype.getExplorerAddressUrl = function (address) {
        return this.getExplorerUrl() + "/address/" + address;
    };
    /**
     * Get the explorer url for the given transaction id.
     *
     * @param {string} txID
     * @returns {string} The explorer url for the given transaction id.
     */
    Client.prototype.getExplorerTxUrl = function (txID) {
        return this.getExplorerUrl() + "/tx/" + txID;
    };
    /**
     * Set/update the current network.
     *
     * @param {Network} network
     * @returns {void}
     *
     * @throws {"Network must be provided"}
     * Thrown if network has not been set before.
     */
    Client.prototype.setNetwork = function (network) {
        _super.prototype.setNetwork.call(this, network);
        this.ethNetwork = xchainNetworkToEths(network);
    };
    /**
     * Set/update a new phrase (Eg. If user wants to change wallet)
     *
     * @param {string} phrase A new phrase.
     * @param {number} walletIndex (optional) HD wallet index
     * @returns {Address} The address from the given phrase
     *
     * @throws {"Invalid phrase"}
     * Thrown if the given phase is invalid.
     */
    Client.prototype.setPhrase = function (phrase, walletIndex) {
        if (walletIndex === void 0) { walletIndex = 0; }
        this.hdNode = utils.HDNode.fromMnemonic(phrase);
        return _super.prototype.setPhrase.call(this, phrase, walletIndex);
    };
    /**
     * Validate the given address.
     *
     * @param {Address} address
     * @returns {boolean} `true` or `false`
     */
    Client.prototype.validateAddress = function (address) {
        return validateAddress(address);
    };
    /**
     * Get the ETH balance of a given address.
     *
     * @param {Address} address By default, it will return the balance of the current wallet. (optional)
     * @returns {Balance[]} The all balance of the address.
     *
     * @throws {"Invalid asset"} throws when the give asset is an invalid one
     */
    Client.prototype.getBalance = function (address, assets) {
        return __awaiter(this, void 0, void 0, function () {
            var ethAddress, ethBalance, ethBalanceAmount, _a, account, balances, newAssets, balances, i, asset, etherscan, assetAddress, balance, decimals, _b, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        ethAddress = address || this.getAddress();
                        return [4 /*yield*/, this.getProvider().getBalance(ethAddress)];
                    case 1:
                        ethBalance = _d.sent();
                        ethBalanceAmount = xchainUtil.baseAmount(ethBalance.toString(), ETH_DECIMAL);
                        _a = this.getNetwork();
                        switch (_a) {
                            case xchainClient.Network.Mainnet: return [3 /*break*/, 2];
                            case xchainClient.Network.Testnet: return [3 /*break*/, 4];
                        }
                        return [3 /*break*/, 13];
                    case 2: return [4 /*yield*/, getAddress(this.ethplorerUrl, address, this.ethplorerApiKey)];
                    case 3:
                        account = _d.sent();
                        balances = [
                            {
                                asset: xchainUtil.AssetETH,
                                amount: ethBalanceAmount,
                            },
                        ];
                        if (account.tokens) {
                            balances.push.apply(balances, getTokenBalances(account.tokens));
                        }
                        return [2 /*return*/, balances];
                    case 4:
                        newAssets = assets || [xchainUtil.AssetETH];
                        balances = [];
                        i = 0;
                        _d.label = 5;
                    case 5:
                        if (!(i < newAssets.length)) return [3 /*break*/, 12];
                        asset = newAssets[i];
                        etherscan = this.getEtherscanProvider();
                        if (!(xchainUtil.assetToString(asset) !== xchainUtil.assetToString(xchainUtil.AssetETH))) return [3 /*break*/, 8];
                        assetAddress = getTokenAddress(asset);
                        if (!assetAddress) {
                            throw new Error("Invalid asset " + asset);
                        }
                        return [4 /*yield*/, getTokenBalance({
                                baseUrl: etherscan.baseUrl,
                                address: address,
                                assetAddress: assetAddress,
                                apiKey: etherscan.apiKey,
                            })];
                    case 6:
                        balance = _d.sent();
                        _c = (_b = ethers.BigNumber).from;
                        return [4 /*yield*/, this.call({ contractAddress: assetAddress, abi: erc20ABI, funcName: 'decimals' })];
                    case 7:
                        decimals = _c.apply(_b, [_d.sent()]).toNumber() || ETH_DECIMAL;
                        if (!Number.isNaN(decimals)) {
                            balances.push({
                                asset: asset,
                                amount: xchainUtil.baseAmount(balance.toString(), decimals),
                            });
                        }
                        return [3 /*break*/, 9];
                    case 8:
                        balances.push({
                            asset: xchainUtil.AssetETH,
                            amount: ethBalanceAmount,
                        });
                        _d.label = 9;
                    case 9: 
                    // Due to etherscan api call limitation, put some delay before another call
                    // Free Etherscan api key limit: 5 calls per second
                    // So 0.3s delay is reasonable for now
                    return [4 /*yield*/, xchainUtil.delay(300)];
                    case 10:
                        // Due to etherscan api call limitation, put some delay before another call
                        // Free Etherscan api key limit: 5 calls per second
                        // So 0.3s delay is reasonable for now
                        _d.sent();
                        _d.label = 11;
                    case 11:
                        i++;
                        return [3 /*break*/, 5];
                    case 12: return [2 /*return*/, balances];
                    case 13: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get transaction history of a given address with pagination options.
     * By default it will return the transaction history of the current wallet.
     *
     * @param {TxHistoryParams} params The options to get transaction history. (optional)
     * @returns {TxsPage} The transaction history.
     */
    Client.prototype.getTransactions = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            var offset, limit, assetAddress, maxCount, transations, etherscan;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        offset = (params === null || params === void 0 ? void 0 : params.offset) || 0;
                        limit = (params === null || params === void 0 ? void 0 : params.limit) || 10;
                        assetAddress = params === null || params === void 0 ? void 0 : params.asset;
                        maxCount = 10000;
                        etherscan = this.getEtherscanProvider();
                        if (!assetAddress) return [3 /*break*/, 2];
                        return [4 /*yield*/, getTokenTransactionHistory({
                                baseUrl: etherscan.baseUrl,
                                address: params === null || params === void 0 ? void 0 : params.address,
                                assetAddress: assetAddress,
                                page: 0,
                                offset: maxCount,
                                apiKey: etherscan.apiKey,
                            })];
                    case 1:
                        transations = _a.sent();
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, getETHTransactionHistory({
                            baseUrl: etherscan.baseUrl,
                            address: params === null || params === void 0 ? void 0 : params.address,
                            page: 0,
                            offset: maxCount,
                            apiKey: etherscan.apiKey,
                        })];
                    case 3:
                        transations = _a.sent();
                        _a.label = 4;
                    case 4: return [2 /*return*/, {
                            total: transations.length,
                            txs: transations.filter(function (_, index) { return index >= offset && index < offset + limit; }),
                        }];
                }
            });
        });
    };
    /**
     * Get the transaction details of a given transaction id.
     *
     * @param {string} txId The transaction id.
     * @param {string} assetAddress The asset address. (optional)
     * @returns {Tx} The transaction details of the given transaction id.
     *
     * @throws {"Need to provide valid txId"}
     * Thrown if the given txId is invalid.
     */
    Client.prototype.getTransactionData = function (txId, assetAddress) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function () {
            var _d, txInfo, tx, tx, etherscan, txInfo;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        _d = this.getNetwork();
                        switch (_d) {
                            case xchainClient.Network.Mainnet: return [3 /*break*/, 1];
                            case xchainClient.Network.Testnet: return [3 /*break*/, 3];
                        }
                        return [3 /*break*/, 9];
                    case 1: return [4 /*yield*/, getTxInfo(this.ethplorerUrl, txId, this.ethplorerApiKey)];
                    case 2:
                        txInfo = _e.sent();
                        if (!((_a = txInfo.operations) === null || _a === void 0 ? void 0 : _a.length))
                            return [2 /*return*/, getTxFromEthplorerEthTransaction(txInfo)];
                        tx = getTxFromEthplorerTokenOperation(txInfo.operations[0]);
                        if (!tx)
                            throw new Error('Could not parse transaction data');
                        return [2 /*return*/, tx];
                    case 3:
                        tx = void 0;
                        etherscan = this.getEtherscanProvider();
                        return [4 /*yield*/, etherscan.getTransaction(txId)];
                    case 4:
                        txInfo = _e.sent();
                        if (!txInfo) return [3 /*break*/, 8];
                        if (!assetAddress) return [3 /*break*/, 6];
                        return [4 /*yield*/, getTokenTransactionHistory({
                                baseUrl: etherscan.baseUrl,
                                assetAddress: assetAddress,
                                startblock: txInfo.blockNumber,
                                endblock: txInfo.blockNumber,
                                apiKey: etherscan.apiKey,
                            })];
                    case 5:
                        tx =
                            (_b = (_e.sent()).filter(function (info) { return info.hash === txId; })[0]) !== null && _b !== void 0 ? _b : null;
                        return [3 /*break*/, 8];
                    case 6: return [4 /*yield*/, getETHTransactionHistory({
                            baseUrl: etherscan.baseUrl,
                            startblock: txInfo.blockNumber,
                            endblock: txInfo.blockNumber,
                            apiKey: etherscan.apiKey,
                            address: txInfo.from,
                        })];
                    case 7:
                        tx =
                            (_c = (_e.sent()).filter(function (info) { return info.hash === txId; })[0]) !== null && _c !== void 0 ? _c : null;
                        _e.label = 8;
                    case 8:
                        if (!tx)
                            throw new Error('Could not get transaction history');
                        return [2 /*return*/, tx];
                    case 9: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Call a contract function.
     * @template T The result interface.
     * @param {number} walletIndex (optional) HD wallet index
     * @param {Address} contractAddress The contract address.
     * @param {ContractInterface} abi The contract ABI json.
     * @param {string} funcName The function to be called.
     * @param {any[]} funcParams The parameters of the function.
     * @returns {T} The result of the contract function call.
     *
     * @throws {"contractAddress must be provided"}
     * Thrown if the given contract address is empty.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Client.prototype.call = function (_a) {
        var _b = _a.walletIndex, walletIndex = _b === void 0 ? 0 : _b, contractAddress = _a.contractAddress, abi = _a.abi, funcName = _a.funcName, _c = _a.funcParams, funcParams = _c === void 0 ? [] : _c;
        return __awaiter(this, void 0, void 0, function () {
            var contract;
            return __generator(this, function (_d) {
                if (!contractAddress)
                    throw new Error('contractAddress must be provided');
                contract = new ethers.ethers.Contract(contractAddress, abi, this.getProvider()).connect(this.getWallet(walletIndex));
                return [2 /*return*/, contract[funcName].apply(contract, funcParams)];
            });
        });
    };
    /**
     * Call a contract function.
     * @param {Address} contractAddress The contract address.
     * @param {ContractInterface} abi The contract ABI json.
     * @param {string} funcName The function to be called.
     * @param {any[]} funcParams The parameters of the function.
     * @param {number} walletIndex (optional) HD wallet index
     * @returns {BigNumber} The result of the contract function call.
     *
     * @throws {"contractAddress must be provided"}
     * Thrown if the given contract address is empty.
     */
    Client.prototype.estimateCall = function (_a) {
        var contractAddress = _a.contractAddress, abi = _a.abi, funcName = _a.funcName, _b = _a.funcParams, funcParams = _b === void 0 ? [] : _b, _c = _a.walletIndex, walletIndex = _c === void 0 ? 0 : _c;
        return __awaiter(this, void 0, void 0, function () {
            var contract;
            var _d;
            return __generator(this, function (_e) {
                if (!contractAddress)
                    throw new Error('contractAddress must be provided');
                contract = new ethers.ethers.Contract(contractAddress, abi, this.getProvider()).connect(this.getWallet(walletIndex));
                return [2 /*return*/, (_d = contract.estimateGas)[funcName].apply(_d, funcParams)];
            });
        });
    };
    /**
     * Check allowance.
     *
     * @param {Address} contractAddress The spender address.
     * @param {Address} spenderAddress The spender address.
     * @param {BaseAmount} amount The amount to check if it's allowed to spend or not (optional).
     * @param {number} walletIndex (optional) HD wallet index
     * @returns {boolean} `true` or `false`.
     */
    Client.prototype.isApproved = function (_a) {
        var _b;
        var contractAddress = _a.contractAddress, spenderAddress = _a.spenderAddress, amount = _a.amount, _c = _a.walletIndex, walletIndex = _c === void 0 ? 0 : _c;
        return __awaiter(this, void 0, void 0, function () {
            var txAmount, owner, allowance;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        txAmount = ethers.BigNumber.from((_b = amount === null || amount === void 0 ? void 0 : amount.amount().toFixed()) !== null && _b !== void 0 ? _b : 1);
                        owner = this.getAddress(walletIndex);
                        return [4 /*yield*/, this.call({
                                contractAddress: contractAddress,
                                abi: erc20ABI,
                                funcName: 'allowance',
                                funcParams: [owner, spenderAddress],
                            })];
                    case 1:
                        allowance = _d.sent();
                        return [2 /*return*/, txAmount.lte(allowance)];
                }
            });
        });
    };
    /**
     * Check allowance.
     *
     * @param {Address} contractAddress The contract address.
     * @param {Address} spenderAddress The spender address.
     * @param {feeOptionKey} FeeOption Fee option (optional)
     * @param {BaseAmount} amount The amount of token. By default, it will be unlimited token allowance. (optional)
     * @param {number} walletIndex (optional) HD wallet index
     *
     * @returns {TransactionResponse} The transaction result.
     */
    Client.prototype.approve = function (_a) {
        var contractAddress = _a.contractAddress, spenderAddress = _a.spenderAddress, _b = _a.feeOptionKey, feeOption = _b === void 0 ? xchainClient.FeeOption.Fastest : _b, amount = _a.amount, _c = _a.walletIndex, walletIndex = _c === void 0 ? 0 : _c, gasLimitFallback = _a.gasLimitFallback;
        return __awaiter(this, void 0, void 0, function () {
            var gasPrice, _d, _e, gasLimit, txAmount;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        _e = (_d = ethers.BigNumber).from;
                        return [4 /*yield*/, this.estimateGasPrices()
                                .then(function (prices) { return prices[feeOption]; })
                                .catch(function () { return getDefaultGasPrices()[feeOption]; })];
                    case 1:
                        gasPrice = _e.apply(_d, [(_f.sent())
                                .amount()
                                .toFixed()]);
                        return [4 /*yield*/, this.estimateApprove({
                                walletIndex: walletIndex,
                                spenderAddress: spenderAddress,
                                contractAddress: contractAddress,
                                amount: amount,
                            }).catch(function () { return ethers.BigNumber.from(gasLimitFallback); })];
                    case 2:
                        gasLimit = _f.sent();
                        txAmount = amount ? ethers.BigNumber.from(amount.amount().toFixed()) : MAX_APPROVAL;
                        return [4 /*yield*/, this.call({
                                walletIndex: walletIndex,
                                contractAddress: contractAddress,
                                abi: erc20ABI,
                                funcName: 'approve',
                                funcParams: [spenderAddress, txAmount, { from: this.getAddress(walletIndex), gasPrice: gasPrice, gasLimit: gasLimit }],
                            })];
                    case 3: return [2 /*return*/, _f.sent()];
                }
            });
        });
    };
    /**
     * Estimate gas limit of approve.
     *
     * @param {Address} contractAddress The contract address.
     * @param {Address} spenderAddress The spender address.
     * @param {number} walletIndex (optional) HD wallet index
     * @param {BaseAmount} amount The amount of token. By default, it will be unlimited token allowance. (optional)
     * @returns {BigNumber} The estimated gas limit.
     */
    Client.prototype.estimateApprove = function (_a) {
        var contractAddress = _a.contractAddress, spenderAddress = _a.spenderAddress, _b = _a.walletIndex, walletIndex = _b === void 0 ? 0 : _b, amount = _a.amount;
        return __awaiter(this, void 0, void 0, function () {
            var txAmount, gasLimit;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        txAmount = amount ? ethers.BigNumber.from(amount.amount().toFixed()) : MAX_APPROVAL;
                        return [4 /*yield*/, this.estimateCall({
                                walletIndex: walletIndex,
                                contractAddress: contractAddress,
                                abi: erc20ABI,
                                funcName: 'approve',
                                funcParams: [spenderAddress, txAmount, { from: this.getAddress(walletIndex) }],
                            })];
                    case 1:
                        gasLimit = _c.sent();
                        return [2 /*return*/, gasLimit];
                }
            });
        });
    };
    /**
     * Transfer ETH.
     *
     * @param {TxParams} params The transfer options.
     * @param {feeOptionKey} FeeOption Fee option (optional)
     * @param {gasPrice} BaseAmount Gas price (optional)
     * @param {gasLimit} BigNumber Gas limit (optional)
     *
     * A given `feeOptionKey` wins over `gasPrice` and `gasLimit`
     *
     * @returns {TxHash} The transaction hash.
     */
    Client.prototype.transfer = function (_a) {
        var _b = _a.walletIndex, walletIndex = _b === void 0 ? 0 : _b, asset = _a.asset, memo = _a.memo, amount = _a.amount, recipient = _a.recipient, feeOption = _a.feeOptionKey, gasPrice = _a.gasPrice, gasLimit = _a.gasLimit;
        return __awaiter(this, void 0, void 0, function () {
            var txAmount, assetAddress, isETHAddress, defaultGasLimit, overrides, gasPrice_1, gasLimit_1, txResult, transactionRequest;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        txAmount = ethers.BigNumber.from(amount.amount().toFixed());
                        if (asset && xchainUtil.assetToString(asset) !== xchainUtil.assetToString(xchainUtil.AssetETH)) {
                            assetAddress = getTokenAddress(asset);
                        }
                        isETHAddress = assetAddress === ETHAddress;
                        defaultGasLimit = isETHAddress ? SIMPLE_GAS_COST : BASE_TOKEN_GAS_COST;
                        overrides = {
                            gasLimit: gasLimit || defaultGasLimit,
                            gasPrice: gasPrice && ethers.BigNumber.from(gasPrice.amount().toFixed()),
                        };
                        if (!feeOption) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.estimateGasPrices()
                                .then(function (prices) { return prices[feeOption]; })
                                .catch(function () { return getDefaultGasPrices()[feeOption]; })];
                    case 1:
                        gasPrice_1 = _c.sent();
                        return [4 /*yield*/, this.estimateGasLimit({ asset: asset, recipient: recipient, amount: amount, memo: memo }).catch(function () { return defaultGasLimit; })];
                    case 2:
                        gasLimit_1 = _c.sent();
                        overrides = {
                            gasLimit: gasLimit_1,
                            gasPrice: ethers.BigNumber.from(gasPrice_1.amount().toFixed()),
                        };
                        _c.label = 3;
                    case 3:
                        if (!(assetAddress && !isETHAddress)) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.call({
                                walletIndex: walletIndex,
                                contractAddress: assetAddress,
                                abi: erc20ABI,
                                funcName: 'transfer',
                                funcParams: [recipient, txAmount, Object.assign({}, overrides)],
                            })];
                    case 4:
                        // Transfer ERC20
                        txResult = _c.sent();
                        return [3 /*break*/, 7];
                    case 5:
                        transactionRequest = Object.assign({ to: recipient, value: txAmount }, __assign(__assign({}, overrides), { data: memo ? utils.toUtf8Bytes(memo) : undefined }));
                        return [4 /*yield*/, this.getWallet().sendTransaction(transactionRequest)];
                    case 6:
                        txResult = _c.sent();
                        _c.label = 7;
                    case 7: return [2 /*return*/, txResult.hash];
                }
            });
        });
    };
    /**
     * Estimate gas price.
     * @see https://etherscan.io/apis#gastracker
     *
     * @returns {GasPrices} The gas prices (average, fast, fastest) in `Wei` (`BaseAmount`)
     */
    Client.prototype.estimateGasPrices = function () {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var ratesInGwei, _b, error_1, error_2;
            var _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _d.trys.push([0, 2, , 3]);
                        _b = xchainClient.standardFeeRates;
                        return [4 /*yield*/, this.getFeeRateFromThorchain()];
                    case 1:
                        ratesInGwei = _b.apply(void 0, [_d.sent()]);
                        return [2 /*return*/, (_c = {},
                                _c[xchainClient.FeeOption.Average] = xchainUtil.baseAmount(ratesInGwei[xchainClient.FeeOption.Average] * Math.pow(10, 9), ETH_DECIMAL),
                                _c[xchainClient.FeeOption.Fast] = xchainUtil.baseAmount(ratesInGwei[xchainClient.FeeOption.Fast] * Math.pow(10, 9), ETH_DECIMAL),
                                _c[xchainClient.FeeOption.Fastest] = xchainUtil.baseAmount(ratesInGwei[xchainClient.FeeOption.Fastest] * Math.pow(10, 9), ETH_DECIMAL),
                                _c)];
                    case 2:
                        error_1 = _d.sent();
                        return [3 /*break*/, 3];
                    case 3:
                        _d.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, this.estimateGasPricesFromEtherscan()];
                    case 4: return [2 /*return*/, _d.sent()];
                    case 5:
                        error_2 = _d.sent();
                        return [2 /*return*/, Promise.reject(new Error("Failed to estimate gas price: " + ((_a = error_2.msg) !== null && _a !== void 0 ? _a : error_2.toString())))];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Estimate gas price.
     * @see https://etherscan.io/apis#gastracker
     *
     * @returns {GasPrices} The gas prices (average, fast, fastest) in `Wei` (`BaseAmount`)
     *
     * @throws {"Failed to estimate gas price"} Thrown if failed to estimate gas price.
     */
    Client.prototype.estimateGasPricesFromEtherscan = function () {
        return __awaiter(this, void 0, void 0, function () {
            var etherscan, response, averageWei, fastWei, fastestWei;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        etherscan = this.getEtherscanProvider();
                        return [4 /*yield*/, getGasOracle(etherscan.baseUrl, etherscan.apiKey)
                            // Convert result of gas prices: `Gwei` -> `Wei`
                        ];
                    case 1:
                        response = _a.sent();
                        averageWei = utils.parseUnits(response.SafeGasPrice, 'gwei');
                        fastWei = utils.parseUnits(response.ProposeGasPrice, 'gwei');
                        fastestWei = utils.parseUnits(response.FastGasPrice, 'gwei');
                        return [2 /*return*/, {
                                average: xchainUtil.baseAmount(averageWei.toString(), ETH_DECIMAL),
                                fast: xchainUtil.baseAmount(fastWei.toString(), ETH_DECIMAL),
                                fastest: xchainUtil.baseAmount(fastestWei.toString(), ETH_DECIMAL),
                            }];
                }
            });
        });
    };
    /**
     * Estimate gas.
     *
     * @param {TxParams} params The transaction and fees options.
     * @returns {BaseAmount} The estimated gas fee.
     */
    Client.prototype.estimateGasLimit = function (_a) {
        var asset = _a.asset, recipient = _a.recipient, amount = _a.amount, memo = _a.memo;
        return __awaiter(this, void 0, void 0, function () {
            var txAmount, assetAddress, estimate, contract, transactionRequest;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        txAmount = ethers.BigNumber.from(amount.amount().toFixed());
                        if (asset && xchainUtil.assetToString(asset) !== xchainUtil.assetToString(xchainUtil.AssetETH)) {
                            assetAddress = getTokenAddress(asset);
                        }
                        if (!(assetAddress && assetAddress !== ETHAddress)) return [3 /*break*/, 2];
                        contract = new ethers.ethers.Contract(assetAddress, erc20ABI, this.getProvider());
                        return [4 /*yield*/, contract.estimateGas.transfer(recipient, txAmount, {
                                from: this.getAddress(),
                            })];
                    case 1:
                        estimate = _b.sent();
                        return [3 /*break*/, 4];
                    case 2:
                        transactionRequest = {
                            from: this.getAddress(),
                            to: recipient,
                            value: txAmount,
                            data: memo ? utils.toUtf8Bytes(memo) : undefined,
                        };
                        return [4 /*yield*/, this.getProvider().estimateGas(transactionRequest)];
                    case 3:
                        estimate = _b.sent();
                        _b.label = 4;
                    case 4: return [2 /*return*/, estimate];
                }
            });
        });
    };
    /**
     * Estimate gas prices/limits (average, fast fastest).
     *
     * @param {TxParams} params
     * @returns {FeesWithGasPricesAndLimits} The estimated gas prices/limits.
     */
    Client.prototype.estimateFeesWithGasPricesAndLimits = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            var gasPrices, fastGP, fastestGP, averageGP, gasLimit;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.estimateGasPrices()];
                    case 1:
                        gasPrices = _a.sent();
                        fastGP = gasPrices.fast, fastestGP = gasPrices.fastest, averageGP = gasPrices.average;
                        return [4 /*yield*/, this.estimateGasLimit({
                                asset: params.asset,
                                amount: params.amount,
                                recipient: params.recipient,
                                memo: params.memo,
                            })];
                    case 2:
                        gasLimit = _a.sent();
                        return [2 /*return*/, {
                                gasPrices: gasPrices,
                                fees: {
                                    type: xchainClient.FeeType.PerByte,
                                    average: getFee({ gasPrice: averageGP, gasLimit: gasLimit }),
                                    fast: getFee({ gasPrice: fastGP, gasLimit: gasLimit }),
                                    fastest: getFee({ gasPrice: fastestGP, gasLimit: gasLimit }),
                                },
                                gasLimit: gasLimit,
                            }];
                }
            });
        });
    };
    Client.prototype.getFees = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            var fees;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!params)
                            throw new Error('Params need to be passed');
                        return [4 /*yield*/, this.estimateFeesWithGasPricesAndLimits(params)];
                    case 1:
                        fees = (_a.sent()).fees;
                        return [2 /*return*/, fees];
                }
            });
        });
    };
    return Client;
}(xchainClient.BaseXChainClient));

exports.Client = Client;
exports.ETHAddress = ETHAddress;
exports.ETH_DECIMAL = ETH_DECIMAL;
exports.estimateDefaultFeesWithGasPricesAndLimits = estimateDefaultFeesWithGasPricesAndLimits;
exports.getDecimal = getDecimal;
exports.getDefaultFees = getDefaultFees;
exports.getFee = getFee;
exports.getPrefix = getPrefix;
exports.getTokenAddress = getTokenAddress;
exports.validateAddress = validateAddress;
//# sourceMappingURL=index.js.map
