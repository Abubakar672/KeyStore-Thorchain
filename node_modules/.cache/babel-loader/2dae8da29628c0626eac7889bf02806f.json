{"ast":null,"code":"import _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\"; // Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\nimport { assert, hexToU8a, isBoolean, isFunction, isHex, isObject, isU8a, isUndefined, stringCamelCase, stringify, u8aConcat, u8aToHex } from '@polkadot/util';\nimport { compareMap, decodeU8a, mapToTypeMap } from \"./utils/index.js\";\n/** @internal */\n\nfunction decodeStructFromObject(registry, Types, value, jsonMap) {\n  let jsonObj;\n  const inputKeys = Object.keys(Types);\n  assert(!Array.isArray(value) || value.length === inputKeys.length, () => `Struct: Unable to map ${stringify(value)} array to object with known keys ${inputKeys.join(', ')}`);\n  return inputKeys.reduce((raw, key, index) => {\n    // The key in the JSON can be snake_case (or other cases), but in our\n    // Types, result or any other maps, it's camelCase\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    const jsonKey = jsonMap.get(key) && !value[key] ? jsonMap.get(key) : key;\n    const Type = Types[key];\n\n    try {\n      if (Array.isArray(value)) {\n        // TS2322: Type 'Codec' is not assignable to type 'T[keyof S]'.\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access\n        raw[key] = value[index] instanceof Type ? value[index] : new Type(registry, value[index]);\n      } else if (value instanceof Map) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const mapped = value.get(jsonKey); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n        raw[key] = mapped instanceof Type ? mapped : new Type(registry, mapped);\n      } else if (isObject(value)) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        let assign = value[jsonKey];\n\n        if (isUndefined(assign)) {\n          if (isUndefined(jsonObj)) {\n            jsonObj = Object.entries(value).reduce((all, [key, value]) => {\n              // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n              all[stringCamelCase(key)] = value;\n              return all;\n            }, {});\n          } // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\n\n          assign = jsonObj[jsonKey];\n        } // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access\n\n\n        raw[key] = assign instanceof Type ? assign : new Type(registry, assign);\n      } else {\n        throw new Error(`Cannot decode value ${stringify(value)} (typeof ${typeof value}), expected an input object with known keys`);\n      }\n    } catch (error) {\n      let type = Type.name;\n\n      try {\n        type = new Type(registry).toRawType();\n      } catch (error) {// ignore\n      }\n\n      throw new Error(`Struct: failed on ${jsonKey}: ${type}:: ${error.message}`);\n    }\n\n    return raw;\n  }, {});\n}\n/**\n * Decode input to pass into constructor.\n *\n * @param Types - Types definition.\n * @param value - Value to decode, one of:\n * - null\n * - undefined\n * - hex\n * - Uint8Array\n * - object with `{ key1: value1, key2: value2 }`, assuming `key1` and `key2`\n * are also keys in `Types`\n * - array with `[value1, value2]` assuming the array has the same length as\n * `Object.keys(Types)`\n * @param jsonMap\n * @internal\n */\n\n\nfunction decodeStruct(registry, Types, value, jsonMap) {\n  if (isHex(value)) {\n    return decodeStruct(registry, Types, hexToU8a(value), jsonMap);\n  } else if (isU8a(value)) {\n    const keys = Object.keys(Types);\n    const values = decodeU8a(registry, value, Object.values(Types), keys); // Transform array of values to {key: value} mapping\n\n    return keys.reduce((raw, key, index) => {\n      // TS2322: Type 'Codec' is not assignable to type 'T[keyof S]'.\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      raw[key] = values[index];\n      return raw;\n    }, {});\n  } else if (!value) {\n    return {};\n  } // We assume from here that value is a JS object (Array, Map, Object)\n\n\n  return decodeStructFromObject(registry, Types, value, jsonMap);\n}\n/**\n * @name Struct\n * @description\n * A Struct defines an Object with key-value pairs - where the values are Codec values. It removes\n * a lot of repetition from the actual coding, define a structure type, pass it the key/Codec\n * values in the constructor and it manages the decoding. It is important that the constructor\n * values matches 100% to the order in th Rust code, i.e. don't go crazy and make it alphabetical,\n * it needs to decoded in the specific defined order.\n * @noInheritDoc\n */\n\n\nvar _jsonMap = /*#__PURE__*/_classPrivateFieldLooseKey(\"jsonMap\");\n\nvar _Types = /*#__PURE__*/_classPrivateFieldLooseKey(\"Types\");\n\nexport class Struct extends Map {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  constructor(registry, Types, value = {}, jsonMap = new Map()) {\n    super(Object.entries(decodeStruct(registry, mapToTypeMap(registry, Types), value, jsonMap)));\n    this.registry = void 0;\n    this.createdAtHash = void 0;\n    Object.defineProperty(this, _jsonMap, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _Types, {\n      writable: true,\n      value: void 0\n    });\n    this.registry = registry;\n    _classPrivateFieldLooseBase(this, _jsonMap)[_jsonMap] = jsonMap;\n    _classPrivateFieldLooseBase(this, _Types)[_Types] = mapToTypeMap(registry, Types);\n  }\n\n  static with(Types, jsonMap) {\n    return class extends Struct {\n      constructor(registry, value) {\n        super(registry, Types, value, jsonMap);\n        Object.keys(Types).forEach(key => {\n          isUndefined(this[key]) && Object.defineProperty(this, key, {\n            enumerable: true,\n            get: () => this.get(key)\n          });\n        });\n      }\n\n    };\n  }\n\n  static typesToMap(registry, Types) {\n    return Object.entries(Types).reduce((result, [key, Type]) => {\n      result[key] = registry.getClassName(Type) || new Type(registry).toRawType();\n      return result;\n    }, {});\n  }\n  /**\n   * @description The available keys for this struct\n   */\n\n\n  get defKeys() {\n    return Object.keys(_classPrivateFieldLooseBase(this, _Types)[_Types]);\n  }\n  /**\n   * @description Checks if the value is an empty value\n   */\n\n\n  get isEmpty() {\n    const items = this.toArray();\n\n    for (let i = 0; i < items.length; i++) {\n      if (!items[i].isEmpty) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * @description Returns the Type description to sthe structure\n   */\n\n\n  get Type() {\n    return Object.entries(_classPrivateFieldLooseBase(this, _Types)[_Types]).reduce((result, [key, Type]) => {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      result[key] = new Type(this.registry).toRawType();\n      return result;\n    }, {});\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return this.toArray().reduce((length, entry) => {\n      length += entry.encodedLength;\n      return length;\n    }, 0);\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n\n\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n\n\n  eq(other) {\n    return compareMap(this, other);\n  }\n  /**\n   * @description Returns a specific names entry in the structure\n   * @param name The name of the entry to retrieve\n   */\n\n\n  get(name) {\n    return super.get(name);\n  }\n  /**\n   * @description Returns the values of a member at a specific index (Rather use get(name) for performance)\n   */\n\n\n  getAtIndex(index) {\n    return this.toArray()[index];\n  }\n  /**\n   * @description Converts the Object to an standard JavaScript Array\n   */\n\n\n  toArray() {\n    return [...this.values()];\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n\n\n  toHex() {\n    return u8aToHex(this.toU8a());\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman(isExtended) {\n    return [...this.keys()].reduce((json, key) => {\n      const value = this.get(key);\n      json[key] = value && value.toHuman(isExtended);\n      return json;\n    }, {});\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n\n\n  toJSON() {\n    return [...this.keys()].reduce((json, key) => {\n      const jsonKey = _classPrivateFieldLooseBase(this, _jsonMap)[_jsonMap].get(key) || key;\n      const value = this.get(key);\n      json[jsonKey] = value && value.toJSON();\n      return json;\n    }, {});\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return stringify(Struct.typesToMap(this.registry, _classPrivateFieldLooseBase(this, _Types)[_Types]));\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n\n\n  toString() {\n    return stringify(this.toJSON());\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    // we have keyof S here, cast to string to make it compatible with isBare\n    const entries = [...this.entries()];\n    return u8aConcat(...entries // eslint-disable-next-line @typescript-eslint/unbound-method\n    .filter(([, value]) => isFunction(value === null || value === void 0 ? void 0 : value.toU8a)).map(([key, value]) => value.toU8a(!isBare || isBoolean(isBare) ? isBare : isBare[key])));\n  }\n\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/types/codec/Struct.js"],"names":["_classPrivateFieldLooseBase","_classPrivateFieldLooseKey","assert","hexToU8a","isBoolean","isFunction","isHex","isObject","isU8a","isUndefined","stringCamelCase","stringify","u8aConcat","u8aToHex","compareMap","decodeU8a","mapToTypeMap","decodeStructFromObject","registry","Types","value","jsonMap","jsonObj","inputKeys","Object","keys","Array","isArray","length","join","reduce","raw","key","index","jsonKey","get","Type","Map","mapped","assign","entries","all","Error","error","type","name","toRawType","message","decodeStruct","values","_jsonMap","_Types","Struct","constructor","createdAtHash","defineProperty","writable","with","forEach","enumerable","typesToMap","result","getClassName","defKeys","isEmpty","items","toArray","i","encodedLength","entry","hash","toU8a","eq","other","getAtIndex","toHex","toHuman","isExtended","json","toJSON","toString","isBare","filter","map"],"mappings":"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","sourcesContent":["import _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, hexToU8a, isBoolean, isFunction, isHex, isObject, isU8a, isUndefined, stringCamelCase, stringify, u8aConcat, u8aToHex } from '@polkadot/util';\nimport { compareMap, decodeU8a, mapToTypeMap } from \"./utils/index.js\";\n\n/** @internal */\nfunction decodeStructFromObject(registry, Types, value, jsonMap) {\n  let jsonObj;\n  const inputKeys = Object.keys(Types);\n  assert(!Array.isArray(value) || value.length === inputKeys.length, () => `Struct: Unable to map ${stringify(value)} array to object with known keys ${inputKeys.join(', ')}`);\n  return inputKeys.reduce((raw, key, index) => {\n    // The key in the JSON can be snake_case (or other cases), but in our\n    // Types, result or any other maps, it's camelCase\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    const jsonKey = jsonMap.get(key) && !value[key] ? jsonMap.get(key) : key;\n    const Type = Types[key];\n\n    try {\n      if (Array.isArray(value)) {\n        // TS2322: Type 'Codec' is not assignable to type 'T[keyof S]'.\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access\n        raw[key] = value[index] instanceof Type ? value[index] : new Type(registry, value[index]);\n      } else if (value instanceof Map) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const mapped = value.get(jsonKey); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n        raw[key] = mapped instanceof Type ? mapped : new Type(registry, mapped);\n      } else if (isObject(value)) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        let assign = value[jsonKey];\n\n        if (isUndefined(assign)) {\n          if (isUndefined(jsonObj)) {\n            jsonObj = Object.entries(value).reduce((all, [key, value]) => {\n              // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n              all[stringCamelCase(key)] = value;\n              return all;\n            }, {});\n          } // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\n\n          assign = jsonObj[jsonKey];\n        } // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access\n\n\n        raw[key] = assign instanceof Type ? assign : new Type(registry, assign);\n      } else {\n        throw new Error(`Cannot decode value ${stringify(value)} (typeof ${typeof value}), expected an input object with known keys`);\n      }\n    } catch (error) {\n      let type = Type.name;\n\n      try {\n        type = new Type(registry).toRawType();\n      } catch (error) {// ignore\n      }\n\n      throw new Error(`Struct: failed on ${jsonKey}: ${type}:: ${error.message}`);\n    }\n\n    return raw;\n  }, {});\n}\n/**\n * Decode input to pass into constructor.\n *\n * @param Types - Types definition.\n * @param value - Value to decode, one of:\n * - null\n * - undefined\n * - hex\n * - Uint8Array\n * - object with `{ key1: value1, key2: value2 }`, assuming `key1` and `key2`\n * are also keys in `Types`\n * - array with `[value1, value2]` assuming the array has the same length as\n * `Object.keys(Types)`\n * @param jsonMap\n * @internal\n */\n\n\nfunction decodeStruct(registry, Types, value, jsonMap) {\n  if (isHex(value)) {\n    return decodeStruct(registry, Types, hexToU8a(value), jsonMap);\n  } else if (isU8a(value)) {\n    const keys = Object.keys(Types);\n    const values = decodeU8a(registry, value, Object.values(Types), keys); // Transform array of values to {key: value} mapping\n\n    return keys.reduce((raw, key, index) => {\n      // TS2322: Type 'Codec' is not assignable to type 'T[keyof S]'.\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      raw[key] = values[index];\n      return raw;\n    }, {});\n  } else if (!value) {\n    return {};\n  } // We assume from here that value is a JS object (Array, Map, Object)\n\n\n  return decodeStructFromObject(registry, Types, value, jsonMap);\n}\n/**\n * @name Struct\n * @description\n * A Struct defines an Object with key-value pairs - where the values are Codec values. It removes\n * a lot of repetition from the actual coding, define a structure type, pass it the key/Codec\n * values in the constructor and it manages the decoding. It is important that the constructor\n * values matches 100% to the order in th Rust code, i.e. don't go crazy and make it alphabetical,\n * it needs to decoded in the specific defined order.\n * @noInheritDoc\n */\n\n\nvar _jsonMap = /*#__PURE__*/_classPrivateFieldLooseKey(\"jsonMap\");\n\nvar _Types = /*#__PURE__*/_classPrivateFieldLooseKey(\"Types\");\n\nexport class Struct extends Map {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  constructor(registry, Types, value = {}, jsonMap = new Map()) {\n    super(Object.entries(decodeStruct(registry, mapToTypeMap(registry, Types), value, jsonMap)));\n    this.registry = void 0;\n    this.createdAtHash = void 0;\n    Object.defineProperty(this, _jsonMap, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _Types, {\n      writable: true,\n      value: void 0\n    });\n    this.registry = registry;\n    _classPrivateFieldLooseBase(this, _jsonMap)[_jsonMap] = jsonMap;\n    _classPrivateFieldLooseBase(this, _Types)[_Types] = mapToTypeMap(registry, Types);\n  }\n\n  static with(Types, jsonMap) {\n    return class extends Struct {\n      constructor(registry, value) {\n        super(registry, Types, value, jsonMap);\n        Object.keys(Types).forEach(key => {\n          isUndefined(this[key]) && Object.defineProperty(this, key, {\n            enumerable: true,\n            get: () => this.get(key)\n          });\n        });\n      }\n\n    };\n  }\n\n  static typesToMap(registry, Types) {\n    return Object.entries(Types).reduce((result, [key, Type]) => {\n      result[key] = registry.getClassName(Type) || new Type(registry).toRawType();\n      return result;\n    }, {});\n  }\n  /**\n   * @description The available keys for this struct\n   */\n\n\n  get defKeys() {\n    return Object.keys(_classPrivateFieldLooseBase(this, _Types)[_Types]);\n  }\n  /**\n   * @description Checks if the value is an empty value\n   */\n\n\n  get isEmpty() {\n    const items = this.toArray();\n\n    for (let i = 0; i < items.length; i++) {\n      if (!items[i].isEmpty) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * @description Returns the Type description to sthe structure\n   */\n\n\n  get Type() {\n    return Object.entries(_classPrivateFieldLooseBase(this, _Types)[_Types]).reduce((result, [key, Type]) => {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      result[key] = new Type(this.registry).toRawType();\n      return result;\n    }, {});\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return this.toArray().reduce((length, entry) => {\n      length += entry.encodedLength;\n      return length;\n    }, 0);\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n\n\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n\n\n  eq(other) {\n    return compareMap(this, other);\n  }\n  /**\n   * @description Returns a specific names entry in the structure\n   * @param name The name of the entry to retrieve\n   */\n\n\n  get(name) {\n    return super.get(name);\n  }\n  /**\n   * @description Returns the values of a member at a specific index (Rather use get(name) for performance)\n   */\n\n\n  getAtIndex(index) {\n    return this.toArray()[index];\n  }\n  /**\n   * @description Converts the Object to an standard JavaScript Array\n   */\n\n\n  toArray() {\n    return [...this.values()];\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n\n\n  toHex() {\n    return u8aToHex(this.toU8a());\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman(isExtended) {\n    return [...this.keys()].reduce((json, key) => {\n      const value = this.get(key);\n      json[key] = value && value.toHuman(isExtended);\n      return json;\n    }, {});\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n\n\n  toJSON() {\n    return [...this.keys()].reduce((json, key) => {\n      const jsonKey = _classPrivateFieldLooseBase(this, _jsonMap)[_jsonMap].get(key) || key;\n      const value = this.get(key);\n      json[jsonKey] = value && value.toJSON();\n      return json;\n    }, {});\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return stringify(Struct.typesToMap(this.registry, _classPrivateFieldLooseBase(this, _Types)[_Types]));\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n\n\n  toString() {\n    return stringify(this.toJSON());\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    // we have keyof S here, cast to string to make it compatible with isBare\n    const entries = [...this.entries()];\n    return u8aConcat(...entries // eslint-disable-next-line @typescript-eslint/unbound-method\n    .filter(([, value]) => isFunction(value === null || value === void 0 ? void 0 : value.toU8a)).map(([key, value]) => value.toU8a(!isBare || isBoolean(isBare) ? isBare : isBare[key])));\n  }\n\n}"]},"metadata":{},"sourceType":"module"}