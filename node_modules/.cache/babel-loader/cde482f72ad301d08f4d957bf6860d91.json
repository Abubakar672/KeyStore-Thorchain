{"ast":null,"code":"// Copyright 2017-2021 @polkadot/keyring authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isUndefined, u8aEq } from '@polkadot/util';\nimport { jsonDecryptData } from '@polkadot/util-crypto';\nimport { PKCS8_DIVIDER, PKCS8_HEADER, PUB_LENGTH, SEC_LENGTH, SEED_LENGTH } from \"./defaults.js\";\nconst SEED_OFFSET = PKCS8_HEADER.length;\nexport function decodePair(passphrase, encrypted, _encType) {\n  const encType = Array.isArray(_encType) || isUndefined(_encType) ? _encType : [_encType];\n  const decrypted = jsonDecryptData(encrypted, passphrase, encType);\n  const header = decrypted.subarray(0, PKCS8_HEADER.length);\n  assert(u8aEq(header, PKCS8_HEADER), 'Invalid Pkcs8 header found in body');\n  let secretKey = decrypted.subarray(SEED_OFFSET, SEED_OFFSET + SEC_LENGTH);\n  let divOffset = SEED_OFFSET + SEC_LENGTH;\n  let divider = decrypted.subarray(divOffset, divOffset + PKCS8_DIVIDER.length); // old-style, we have the seed here\n\n  if (!u8aEq(divider, PKCS8_DIVIDER)) {\n    divOffset = SEED_OFFSET + SEED_LENGTH;\n    secretKey = decrypted.subarray(SEED_OFFSET, divOffset);\n    divider = decrypted.subarray(divOffset, divOffset + PKCS8_DIVIDER.length);\n    assert(u8aEq(divider, PKCS8_DIVIDER), 'Invalid Pkcs8 divider found in body');\n  }\n\n  const pubOffset = divOffset + PKCS8_DIVIDER.length;\n  const publicKey = decrypted.subarray(pubOffset, pubOffset + PUB_LENGTH);\n  return {\n    publicKey,\n    secretKey\n  };\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/keyring/pair/decode.js"],"names":["assert","isUndefined","u8aEq","jsonDecryptData","PKCS8_DIVIDER","PKCS8_HEADER","PUB_LENGTH","SEC_LENGTH","SEED_LENGTH","SEED_OFFSET","length","decodePair","passphrase","encrypted","_encType","encType","Array","isArray","decrypted","header","subarray","secretKey","divOffset","divider","pubOffset","publicKey"],"mappings":"AAAA;AACA;AACA,SAASA,MAAT,EAAiBC,WAAjB,EAA8BC,KAA9B,QAA2C,gBAA3C;AACA,SAASC,eAAT,QAAgC,uBAAhC;AACA,SAASC,aAAT,EAAwBC,YAAxB,EAAsCC,UAAtC,EAAkDC,UAAlD,EAA8DC,WAA9D,QAAiF,eAAjF;AACA,MAAMC,WAAW,GAAGJ,YAAY,CAACK,MAAjC;AACA,OAAO,SAASC,UAAT,CAAoBC,UAApB,EAAgCC,SAAhC,EAA2CC,QAA3C,EAAqD;AAC1D,QAAMC,OAAO,GAAGC,KAAK,CAACC,OAAN,CAAcH,QAAd,KAA2Bb,WAAW,CAACa,QAAD,CAAtC,GAAmDA,QAAnD,GAA8D,CAACA,QAAD,CAA9E;AACA,QAAMI,SAAS,GAAGf,eAAe,CAACU,SAAD,EAAYD,UAAZ,EAAwBG,OAAxB,CAAjC;AACA,QAAMI,MAAM,GAAGD,SAAS,CAACE,QAAV,CAAmB,CAAnB,EAAsBf,YAAY,CAACK,MAAnC,CAAf;AACAV,EAAAA,MAAM,CAACE,KAAK,CAACiB,MAAD,EAASd,YAAT,CAAN,EAA8B,oCAA9B,CAAN;AACA,MAAIgB,SAAS,GAAGH,SAAS,CAACE,QAAV,CAAmBX,WAAnB,EAAgCA,WAAW,GAAGF,UAA9C,CAAhB;AACA,MAAIe,SAAS,GAAGb,WAAW,GAAGF,UAA9B;AACA,MAAIgB,OAAO,GAAGL,SAAS,CAACE,QAAV,CAAmBE,SAAnB,EAA8BA,SAAS,GAAGlB,aAAa,CAACM,MAAxD,CAAd,CAP0D,CAOqB;;AAE/E,MAAI,CAACR,KAAK,CAACqB,OAAD,EAAUnB,aAAV,CAAV,EAAoC;AAClCkB,IAAAA,SAAS,GAAGb,WAAW,GAAGD,WAA1B;AACAa,IAAAA,SAAS,GAAGH,SAAS,CAACE,QAAV,CAAmBX,WAAnB,EAAgCa,SAAhC,CAAZ;AACAC,IAAAA,OAAO,GAAGL,SAAS,CAACE,QAAV,CAAmBE,SAAnB,EAA8BA,SAAS,GAAGlB,aAAa,CAACM,MAAxD,CAAV;AACAV,IAAAA,MAAM,CAACE,KAAK,CAACqB,OAAD,EAAUnB,aAAV,CAAN,EAAgC,qCAAhC,CAAN;AACD;;AAED,QAAMoB,SAAS,GAAGF,SAAS,GAAGlB,aAAa,CAACM,MAA5C;AACA,QAAMe,SAAS,GAAGP,SAAS,CAACE,QAAV,CAAmBI,SAAnB,EAA8BA,SAAS,GAAGlB,UAA1C,CAAlB;AACA,SAAO;AACLmB,IAAAA,SADK;AAELJ,IAAAA;AAFK,GAAP;AAID","sourcesContent":["// Copyright 2017-2021 @polkadot/keyring authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isUndefined, u8aEq } from '@polkadot/util';\nimport { jsonDecryptData } from '@polkadot/util-crypto';\nimport { PKCS8_DIVIDER, PKCS8_HEADER, PUB_LENGTH, SEC_LENGTH, SEED_LENGTH } from \"./defaults.js\";\nconst SEED_OFFSET = PKCS8_HEADER.length;\nexport function decodePair(passphrase, encrypted, _encType) {\n  const encType = Array.isArray(_encType) || isUndefined(_encType) ? _encType : [_encType];\n  const decrypted = jsonDecryptData(encrypted, passphrase, encType);\n  const header = decrypted.subarray(0, PKCS8_HEADER.length);\n  assert(u8aEq(header, PKCS8_HEADER), 'Invalid Pkcs8 header found in body');\n  let secretKey = decrypted.subarray(SEED_OFFSET, SEED_OFFSET + SEC_LENGTH);\n  let divOffset = SEED_OFFSET + SEC_LENGTH;\n  let divider = decrypted.subarray(divOffset, divOffset + PKCS8_DIVIDER.length); // old-style, we have the seed here\n\n  if (!u8aEq(divider, PKCS8_DIVIDER)) {\n    divOffset = SEED_OFFSET + SEED_LENGTH;\n    secretKey = decrypted.subarray(SEED_OFFSET, divOffset);\n    divider = decrypted.subarray(divOffset, divOffset + PKCS8_DIVIDER.length);\n    assert(u8aEq(divider, PKCS8_DIVIDER), 'Invalid Pkcs8 divider found in body');\n  }\n\n  const pubOffset = divOffset + PKCS8_DIVIDER.length;\n  const publicKey = decrypted.subarray(pubOffset, pubOffset + PUB_LENGTH);\n  return {\n    publicKey,\n    secretKey\n  };\n}"]},"metadata":{},"sourceType":"module"}