{"ast":null,"code":"var Buffer = require(\"safe-buffer\").Buffer;\n\nvar bip66 = require(\"bip66\");\n\nvar pushdata = require(\"@psf/pushdata-bitcoin\");\n\nvar typeforce = require(\"typeforce\");\n\nvar types = require(\"./types\");\n\nvar scriptNumber = require(\"./script_number\");\n\nvar OPS = require(\"@psf/bitcoincash-ops\");\n\nvar REVERSE_OPS = require(\"@psf/bitcoincash-ops/map\");\n\nvar OP_INT_BASE = OPS.OP_RESERVED; // OP_1 - 1\n\nfunction isOPInt(value) {\n  return types.Number(value) && (value === OPS.OP_0 || value >= OPS.OP_1 && value <= OPS.OP_16 || value === OPS.OP_1NEGATE);\n}\n\nfunction isPushOnlyChunk(value) {\n  return types.Buffer(value) || isOPInt(value);\n}\n\nfunction isPushOnly(value) {\n  return types.Array(value) && value.every(isPushOnlyChunk);\n} // This function reaks havoc on the OP_RETURN call of an SLP transaction.\n\n\nfunction asMinimalOP(buffer) {\n  if (buffer.length === 0) return OPS.OP_0;\n  if (buffer.length !== 1) return;\n  if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];\n  if (buffer[0] === 0x81) return OPS.OP_1NEGATE;\n} // Originalize compile() function. This will not correctly compile some scripts,\n// including the OP_RETURN for SLP tokens. Use compile2() for that.\n\n\nfunction compile(chunks) {\n  // TODO: remove me\n  if (Buffer.isBuffer(chunks)) return chunks;\n  typeforce(types.Array, chunks);\n  var bufferSize = chunks.reduce(function (accum, chunk) {\n    // data chunk\n    if (Buffer.isBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {\n        return accum + 1;\n      }\n\n      return accum + pushdata.encodingLength(chunk.length) + chunk.length;\n    } // opcode\n\n\n    return accum + 1;\n  }, 0.0);\n  var buffer = Buffer.allocUnsafe(bufferSize);\n  var offset = 0;\n  chunks.forEach(function (chunk) {\n    // data chunk\n    if (Buffer.isBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      var opcode = asMinimalOP(chunk);\n\n      if (opcode !== undefined) {\n        buffer.writeUInt8(opcode, offset);\n        offset += 1;\n        return;\n      }\n\n      offset += pushdata.encode(buffer, chunk.length, offset);\n      chunk.copy(buffer, offset);\n      offset += chunk.length; // opcode\n    } else {\n      buffer.writeUInt8(chunk, offset);\n      offset += 1;\n    }\n  });\n  if (offset !== buffer.length) throw new Error(\"Could not decode chunks\");\n  return buffer;\n} // Compile for non-minimal Script, like for SLP OP_RETURNs.\n// Expects an array of Buffers, to be compiled into a binary blob returned\n// as a Buffer. This final blob is ready to used as an output of a Bitcoin\n// Cash transaction.\n\n\nfunction compile2(chunks) {\n  // If the chunks object is a Buffer, return it.\n  if (Buffer.isBuffer(chunks)) return chunks; // Calculate the final size the buffer should be. Allows error checking in\n  // case compilation goes wonky.\n\n  var bufferSize = chunks.reduce(function (accum, chunk) {\n    // If the chunk is of type Buffer.\n    if (Buffer.isBuffer(chunk)) {\n      // Return the final complied length this Buffer will take up.\n      return accum + pushdata.encodingLength(chunk.length) + chunk.length;\n    } // Otherwise the chunk object is an OP code. It will take up 1 byte.\n\n\n    return accum + 1;\n  }, 0.0); // buffer will hold final compiled Buffer.\n\n  var buffer = Buffer.allocUnsafe(bufferSize);\n  var offset = 0; // Loop through each element in the chunks Array.\n\n  chunks.forEach(function (chunk, index) {\n    // If the chunk is a Buffer and not an OP code.\n    if (Buffer.isBuffer(chunk)) {\n      // console.log(\" \")\n      // console.log(`index: ${index}`)\n      // console.log(`chunk: ${chunk.toString(\"hex\")}`)\n      // console.log(`original buffer: ${buffer.toString(\"hex\")}`)\n      // Calculate the offset for adding this new chunk.\n      offset += pushdata.encode(buffer, chunk.length, offset); // Copy the current chunk into the buffer.\n\n      chunk.copy(buffer, offset); // Calculate the new offset.\n\n      offset += chunk.length; // The chunk is an OP code and not a Buffer.\n    } else {\n      // Add the 1-byte OP code to the final Buffer output.\n      buffer.writeUInt8(chunk, offset);\n      offset += 1;\n    }\n  }); // If the calculated offset and buffer length don't match, then something\n  // went wrong. Throw an error.\n\n  if (offset !== buffer.length) throw new Error(\"Could not decode chunks\"); // Return the final, compiled binary blog as a buffer.\n\n  return buffer;\n}\n\nfunction decompile(buffer) {\n  // TODO: remove me\n  if (types.Array(buffer)) return buffer;\n  typeforce(types.Buffer, buffer);\n  var chunks = [];\n  var i = 0;\n\n  while (i < buffer.length) {\n    var opcode = buffer[i]; // data chunk\n\n    if (opcode > OPS.OP_0 && opcode <= OPS.OP_PUSHDATA4) {\n      var d = pushdata.decode(buffer, i); // did reading a pushDataInt fail? empty script\n\n      if (d === null) return [];\n      i += d.size; // attempt to read too much data? empty script\n      // if (i + d.number > buffer.length) return []\n\n      var data = buffer.slice(i, i + d.number);\n      i += d.number; // decompile minimally\n\n      var op = asMinimalOP(data);\n\n      if (op !== undefined) {\n        chunks.push(op);\n      } else {\n        chunks.push(data);\n      } // opcode\n\n    } else {\n      chunks.push(opcode);\n      i += 1;\n    }\n  }\n\n  return chunks;\n}\n\nfunction toASM(chunks) {\n  if (Buffer.isBuffer(chunks)) {\n    chunks = decompile(chunks);\n  }\n\n  return chunks.map(function (chunk) {\n    // data?\n    if (Buffer.isBuffer(chunk)) {\n      var op = asMinimalOP(chunk);\n      if (op === undefined) return chunk.toString(\"hex\");\n      chunk = op;\n    } // opcode!\n\n\n    return REVERSE_OPS[chunk];\n  }).join(\" \");\n}\n\nfunction fromASM(asm) {\n  typeforce(types.String, asm);\n  return compile(asm.split(\" \").map(function (chunkStr) {\n    // opcode?\n    if (OPS[chunkStr] !== undefined) return OPS[chunkStr]; // typeforce(types.Hex, chunkStr)\n    // data!\n\n    return Buffer.from(chunkStr, \"hex\");\n  }));\n}\n\nfunction toStack(chunks) {\n  chunks = decompile(chunks);\n  typeforce(isPushOnly, chunks);\n  return chunks.map(function (op) {\n    if (Buffer.isBuffer(op)) return op;\n    if (op === OPS.OP_0) return Buffer.allocUnsafe(0);\n    return scriptNumber.encode(op - OP_INT_BASE);\n  });\n}\n\nfunction isCanonicalPubKey(buffer) {\n  if (!Buffer.isBuffer(buffer)) return false;\n  if (buffer.length < 33) return false;\n\n  switch (buffer[0]) {\n    case 0x02:\n    case 0x03:\n      return buffer.length === 33;\n\n    case 0x04:\n      return buffer.length === 65;\n  }\n\n  return false;\n}\n\nfunction isDefinedHashType(hashType) {\n  var hashTypeMod = hashType & ~0xc0; // return hashTypeMod > SIGHASH_ALL && hashTypeMod < SIGHASH_SINGLE\n\n  return hashTypeMod > 0x00 && hashTypeMod < 0x04;\n}\n\nfunction isCanonicalSignature(buffer) {\n  if (!Buffer.isBuffer(buffer)) return false;\n  if (!isDefinedHashType(buffer[buffer.length - 1])) return false;\n  if (buffer.length === 65) return true;\n  return bip66.check(buffer.slice(0, -1));\n}\n\nmodule.exports = {\n  compile: compile,\n  compile2: compile2,\n  decompile: decompile,\n  fromASM: fromASM,\n  toASM: toASM,\n  toStack: toStack,\n  number: require(\"./script_number\"),\n  isCanonicalPubKey: isCanonicalPubKey,\n  isCanonicalSignature: isCanonicalSignature,\n  isPushOnly: isPushOnly,\n  isDefinedHashType: isDefinedHashType\n};","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@psf/bitcoincashjs-lib/src/script.js"],"names":["Buffer","require","bip66","pushdata","typeforce","types","scriptNumber","OPS","REVERSE_OPS","OP_INT_BASE","OP_RESERVED","isOPInt","value","Number","OP_0","OP_1","OP_16","OP_1NEGATE","isPushOnlyChunk","isPushOnly","Array","every","asMinimalOP","buffer","length","compile","chunks","isBuffer","bufferSize","reduce","accum","chunk","undefined","encodingLength","allocUnsafe","offset","forEach","opcode","writeUInt8","encode","copy","Error","compile2","index","decompile","i","OP_PUSHDATA4","d","decode","size","data","slice","number","op","push","toASM","map","toString","join","fromASM","asm","String","split","chunkStr","from","toStack","isCanonicalPubKey","isDefinedHashType","hashType","hashTypeMod","isCanonicalSignature","check","module","exports"],"mappings":"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","sourcesContent":["var Buffer = require(\"safe-buffer\").Buffer;\nvar bip66 = require(\"bip66\");\nvar pushdata = require(\"@psf/pushdata-bitcoin\");\nvar typeforce = require(\"typeforce\");\nvar types = require(\"./types\");\nvar scriptNumber = require(\"./script_number\");\n\nvar OPS = require(\"@psf/bitcoincash-ops\");\nvar REVERSE_OPS = require(\"@psf/bitcoincash-ops/map\");\nvar OP_INT_BASE = OPS.OP_RESERVED; // OP_1 - 1\n\nfunction isOPInt(value) {\n  return (\n    types.Number(value) &&\n    (value === OPS.OP_0 ||\n      (value >= OPS.OP_1 && value <= OPS.OP_16) ||\n      value === OPS.OP_1NEGATE)\n  );\n}\n\nfunction isPushOnlyChunk(value) {\n  return types.Buffer(value) || isOPInt(value);\n}\n\nfunction isPushOnly(value) {\n  return types.Array(value) && value.every(isPushOnlyChunk);\n}\n\n// This function reaks havoc on the OP_RETURN call of an SLP transaction.\nfunction asMinimalOP(buffer) {\n  if (buffer.length === 0) return OPS.OP_0;\n  if (buffer.length !== 1) return;\n  if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];\n  if (buffer[0] === 0x81) return OPS.OP_1NEGATE;\n}\n\n// Originalize compile() function. This will not correctly compile some scripts,\n// including the OP_RETURN for SLP tokens. Use compile2() for that.\nfunction compile(chunks) {\n  // TODO: remove me\n  if (Buffer.isBuffer(chunks)) return chunks;\n\n  typeforce(types.Array, chunks);\n\n  var bufferSize = chunks.reduce(function(accum, chunk) {\n    // data chunk\n    if (Buffer.isBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {\n        return accum + 1;\n      }\n\n      return accum + pushdata.encodingLength(chunk.length) + chunk.length;\n    }\n\n    // opcode\n    return accum + 1;\n  }, 0.0);\n\n  var buffer = Buffer.allocUnsafe(bufferSize);\n  var offset = 0;\n\n  chunks.forEach(function(chunk) {\n    // data chunk\n    if (Buffer.isBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      var opcode = asMinimalOP(chunk);\n      if (opcode !== undefined) {\n        buffer.writeUInt8(opcode, offset);\n        offset += 1;\n        return;\n      }\n\n      offset += pushdata.encode(buffer, chunk.length, offset);\n      chunk.copy(buffer, offset);\n      offset += chunk.length;\n\n      // opcode\n    } else {\n      buffer.writeUInt8(chunk, offset);\n      offset += 1;\n    }\n  });\n\n  if (offset !== buffer.length) throw new Error(\"Could not decode chunks\");\n  return buffer;\n}\n\n// Compile for non-minimal Script, like for SLP OP_RETURNs.\n// Expects an array of Buffers, to be compiled into a binary blob returned\n// as a Buffer. This final blob is ready to used as an output of a Bitcoin\n// Cash transaction.\nfunction compile2(chunks) {\n  // If the chunks object is a Buffer, return it.\n  if (Buffer.isBuffer(chunks)) return chunks\n\n  // Calculate the final size the buffer should be. Allows error checking in\n  // case compilation goes wonky.\n  var bufferSize = chunks.reduce(function(accum, chunk) {\n    // If the chunk is of type Buffer.\n    if (Buffer.isBuffer(chunk)) {\n      // Return the final complied length this Buffer will take up.\n      return accum + pushdata.encodingLength(chunk.length) + chunk.length\n    }\n\n    // Otherwise the chunk object is an OP code. It will take up 1 byte.\n    return accum + 1\n  }, 0.0)\n\n  // buffer will hold final compiled Buffer.\n  var buffer = Buffer.allocUnsafe(bufferSize)\n  var offset = 0\n\n  // Loop through each element in the chunks Array.\n  chunks.forEach(function(chunk, index) {\n    // If the chunk is a Buffer and not an OP code.\n    if (Buffer.isBuffer(chunk)) {\n      // console.log(\" \")\n      // console.log(`index: ${index}`)\n      // console.log(`chunk: ${chunk.toString(\"hex\")}`)\n      // console.log(`original buffer: ${buffer.toString(\"hex\")}`)\n\n      // Calculate the offset for adding this new chunk.\n      offset += pushdata.encode(buffer, chunk.length, offset)\n\n      // Copy the current chunk into the buffer.\n      chunk.copy(buffer, offset)\n\n      // Calculate the new offset.\n      offset += chunk.length\n\n      // The chunk is an OP code and not a Buffer.\n    } else {\n      // Add the 1-byte OP code to the final Buffer output.\n      buffer.writeUInt8(chunk, offset)\n      offset += 1\n    }\n  })\n\n  // If the calculated offset and buffer length don't match, then something\n  // went wrong. Throw an error.\n  if (offset !== buffer.length) throw new Error(\"Could not decode chunks\")\n\n  // Return the final, compiled binary blog as a buffer.\n  return buffer\n}\n\nfunction decompile(buffer) {\n  // TODO: remove me\n  if (types.Array(buffer)) return buffer;\n\n  typeforce(types.Buffer, buffer);\n\n  var chunks = [];\n  var i = 0;\n\n  while (i < buffer.length) {\n    var opcode = buffer[i];\n\n    // data chunk\n    if (opcode > OPS.OP_0 && opcode <= OPS.OP_PUSHDATA4) {\n      var d = pushdata.decode(buffer, i);\n\n      // did reading a pushDataInt fail? empty script\n      if (d === null) return [];\n      i += d.size;\n\n      // attempt to read too much data? empty script\n      // if (i + d.number > buffer.length) return []\n\n      var data = buffer.slice(i, i + d.number);\n      i += d.number;\n\n      // decompile minimally\n      var op = asMinimalOP(data);\n      if (op !== undefined) {\n        chunks.push(op);\n      } else {\n        chunks.push(data);\n      }\n\n      // opcode\n    } else {\n      chunks.push(opcode);\n\n      i += 1;\n    }\n  }\n\n  return chunks;\n}\n\nfunction toASM(chunks) {\n  if (Buffer.isBuffer(chunks)) {\n    chunks = decompile(chunks);\n  }\n\n  return chunks\n    .map(function(chunk) {\n      // data?\n      if (Buffer.isBuffer(chunk)) {\n        var op = asMinimalOP(chunk);\n        if (op === undefined) return chunk.toString(\"hex\");\n        chunk = op;\n      }\n\n      // opcode!\n      return REVERSE_OPS[chunk];\n    })\n    .join(\" \");\n}\n\nfunction fromASM(asm) {\n  typeforce(types.String, asm);\n\n  return compile(\n    asm.split(\" \").map(function(chunkStr) {\n      // opcode?\n      if (OPS[chunkStr] !== undefined) return OPS[chunkStr];\n      // typeforce(types.Hex, chunkStr)\n\n      // data!\n      return Buffer.from(chunkStr, \"hex\");\n    })\n  );\n}\n\nfunction toStack(chunks) {\n  chunks = decompile(chunks);\n  typeforce(isPushOnly, chunks);\n\n  return chunks.map(function(op) {\n    if (Buffer.isBuffer(op)) return op;\n    if (op === OPS.OP_0) return Buffer.allocUnsafe(0);\n\n    return scriptNumber.encode(op - OP_INT_BASE);\n  });\n}\n\nfunction isCanonicalPubKey(buffer) {\n  if (!Buffer.isBuffer(buffer)) return false;\n  if (buffer.length < 33) return false;\n\n  switch (buffer[0]) {\n    case 0x02:\n    case 0x03:\n      return buffer.length === 33;\n    case 0x04:\n      return buffer.length === 65;\n  }\n\n  return false;\n}\n\nfunction isDefinedHashType(hashType) {\n  var hashTypeMod = hashType & ~0xc0;\n\n  // return hashTypeMod > SIGHASH_ALL && hashTypeMod < SIGHASH_SINGLE\n  return hashTypeMod > 0x00 && hashTypeMod < 0x04;\n}\n\nfunction isCanonicalSignature(buffer) {\n  if (!Buffer.isBuffer(buffer)) return false;\n  if (!isDefinedHashType(buffer[buffer.length - 1])) return false;\n\n  if(buffer.length === 65) return true;\n\n  return bip66.check(buffer.slice(0, -1));\n}\n\nmodule.exports = {\n  compile: compile,\n  compile2: compile2,\n  decompile: decompile,\n  fromASM: fromASM,\n  toASM: toASM,\n  toStack: toStack,\n\n  number: require(\"./script_number\"),\n\n  isCanonicalPubKey: isCanonicalPubKey,\n  isCanonicalSignature: isCanonicalSignature,\n  isPushOnly: isPushOnly,\n  isDefinedHashType: isDefinedHashType\n};\n"]},"metadata":{},"sourceType":"script"}