{"ast":null,"code":"import _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { assert, assertReturn, BN_ZERO, formatBalance, isFunction, isString, isU8a, logger, stringCamelCase, stringify, u8aToHex } from '@polkadot/util';\nimport { blake2AsU8a } from '@polkadot/util-crypto';\nimport { DoNotConstruct } from \"../codec/DoNotConstruct.js\";\nimport { Json } from \"../codec/Json.js\";\nimport { Raw } from \"../codec/Raw.js\";\nimport { expandExtensionTypes, fallbackExtensions, findUnknownExtensions } from \"../extrinsic/signedExtensions/index.js\";\nimport { GenericEventData } from \"../generic/Event.js\";\nimport * as baseTypes from \"../index.types.js\";\nimport * as definitions from \"../interfaces/definitions.js\";\nimport { decorateConstants, decorateExtrinsics } from \"../metadata/decorate/index.js\";\nimport { Metadata } from \"../metadata/Metadata.js\";\nimport { createClass } from \"./createClass.js\";\nimport { createTypeUnsafe } from \"./createType.js\";\nconst l = logger('registry'); // create error mapping from metadata\n\nfunction injectErrors(_, metadata, metadataErrors) {\n  const {\n    lookup,\n    pallets\n  } = metadata.asLatest; // decorate the errors\n\n  pallets.forEach(({\n    errors,\n    index,\n    name\n  }, _sectionIndex) => {\n    if (errors.isNone) {\n      return;\n    }\n\n    const sectionIndex = metadata.version >= 12 ? index.toNumber() : _sectionIndex;\n    const sectionName = stringCamelCase(name);\n    lookup.getSiType(errors.unwrap().type).def.asVariant.variants.forEach(({\n      docs,\n      fields,\n      index,\n      name\n    }) => {\n      const variantIndex = index.toNumber();\n      const eventIndex = new Uint8Array([sectionIndex, variantIndex]);\n      metadataErrors[u8aToHex(eventIndex)] = {\n        args: fields.map(({\n          type\n        }) => lookup.getTypeDef(type).type),\n        docs: docs.map(d => d.toString()),\n        fields,\n        index: variantIndex,\n        method: name.toString(),\n        name: name.toString(),\n        section: sectionName\n      };\n    });\n  });\n} // create event classes from metadata\n\n\nfunction injectEvents(registry, metadata, metadataEvents) {\n  const {\n    lookup,\n    pallets\n  } = metadata.asLatest; // decorate the events\n\n  pallets.filter(({\n    events\n  }) => events.isSome).forEach(({\n    events,\n    index,\n    name\n  }, _sectionIndex) => {\n    const sectionIndex = metadata.version >= 12 ? index.toNumber() : _sectionIndex;\n    const sectionName = stringCamelCase(name);\n    lookup.getSiType(events.unwrap().type).def.asVariant.variants.forEach(variant => {\n      const variantIndex = variant.index.toNumber();\n      const eventIndex = new Uint8Array([sectionIndex, variantIndex]);\n      const meta = registry.createType('EventMetadataLatest', _objectSpread(_objectSpread({}, variant), {}, {\n        args: variant.fields.map(({\n          type\n        }) => lookup.getTypeDef(type).type)\n      }));\n      metadataEvents[u8aToHex(eventIndex)] = class extends GenericEventData {\n        constructor(registry, value) {\n          super(registry, value, meta, sectionName, variant.name.toString());\n        }\n\n      };\n    });\n  });\n} // create extrinsic mapping from metadata\n\n\nfunction injectExtrinsics(registry, metadata, metadataCalls) {\n  const extrinsics = decorateExtrinsics(registry, metadata.asLatest, metadata.version); // decorate the extrinsics\n\n  Object.values(extrinsics).forEach(methods => Object.values(methods).forEach(method => {\n    metadataCalls[u8aToHex(method.callIndex)] = method;\n  }));\n} // extract additional properties from the metadata\n\n\nfunction extractProperties(registry, metadata) {\n  var _constants$system;\n\n  const original = registry.getChainProperties();\n  const constants = decorateConstants(registry, metadata.asLatest, metadata.version);\n  const ss58Format = (_constants$system = constants.system) === null || _constants$system === void 0 ? void 0 : _constants$system.ss58Prefix;\n\n  if (!ss58Format) {\n    return original;\n  }\n\n  const {\n    tokenDecimals,\n    tokenSymbol\n  } = original || {};\n  return registry.createType('ChainProperties', {\n    ss58Format,\n    tokenDecimals,\n    tokenSymbol\n  });\n}\n\nvar _classes = /*#__PURE__*/_classPrivateFieldLooseKey(\"classes\");\n\nvar _definitions = /*#__PURE__*/_classPrivateFieldLooseKey(\"definitions\");\n\nvar _metadata = /*#__PURE__*/_classPrivateFieldLooseKey(\"metadata\");\n\nvar _metadataCalls = /*#__PURE__*/_classPrivateFieldLooseKey(\"metadataCalls\");\n\nvar _metadataErrors = /*#__PURE__*/_classPrivateFieldLooseKey(\"metadataErrors\");\n\nvar _metadataEvents = /*#__PURE__*/_classPrivateFieldLooseKey(\"metadataEvents\");\n\nvar _unknownTypes = /*#__PURE__*/_classPrivateFieldLooseKey(\"unknownTypes\");\n\nvar _chainProperties = /*#__PURE__*/_classPrivateFieldLooseKey(\"chainProperties\");\n\nvar _hasher = /*#__PURE__*/_classPrivateFieldLooseKey(\"hasher\");\n\nvar _knownDefaults = /*#__PURE__*/_classPrivateFieldLooseKey(\"knownDefaults\");\n\nvar _knownDefinitions = /*#__PURE__*/_classPrivateFieldLooseKey(\"knownDefinitions\");\n\nvar _knownTypes = /*#__PURE__*/_classPrivateFieldLooseKey(\"knownTypes\");\n\nvar _signedExtensions = /*#__PURE__*/_classPrivateFieldLooseKey(\"signedExtensions\");\n\nvar _userExtensions = /*#__PURE__*/_classPrivateFieldLooseKey(\"userExtensions\");\n\nexport class TypeRegistry {\n  constructor(createdAtHash) {\n    Object.defineProperty(this, _classes, {\n      writable: true,\n      value: new Map()\n    });\n    Object.defineProperty(this, _definitions, {\n      writable: true,\n      value: new Map()\n    });\n    Object.defineProperty(this, _metadata, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _metadataCalls, {\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, _metadataErrors, {\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, _metadataEvents, {\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, _unknownTypes, {\n      writable: true,\n      value: new Map()\n    });\n    Object.defineProperty(this, _chainProperties, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _hasher, {\n      writable: true,\n      value: blake2AsU8a\n    });\n    Object.defineProperty(this, _knownDefaults, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _knownDefinitions, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _knownTypes, {\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, _signedExtensions, {\n      writable: true,\n      value: fallbackExtensions\n    });\n    Object.defineProperty(this, _userExtensions, {\n      writable: true,\n      value: void 0\n    });\n    this.createdAtHash = void 0;\n    _classPrivateFieldLooseBase(this, _knownDefaults)[_knownDefaults] = _objectSpread({\n      Json,\n      Metadata,\n      Raw\n    }, baseTypes);\n    _classPrivateFieldLooseBase(this, _knownDefinitions)[_knownDefinitions] = definitions;\n    this.init();\n\n    if (createdAtHash) {\n      this.createdAtHash = this.createType('Hash', createdAtHash);\n    }\n  }\n\n  init() {\n    // start clean\n    _classPrivateFieldLooseBase(this, _classes)[_classes] = new Map();\n    _classPrivateFieldLooseBase(this, _definitions)[_definitions] = new Map();\n    _classPrivateFieldLooseBase(this, _unknownTypes)[_unknownTypes] = new Map();\n    _classPrivateFieldLooseBase(this, _knownTypes)[_knownTypes] = {}; // register know, first classes then on-demand-created definitions\n\n    this.register(_classPrivateFieldLooseBase(this, _knownDefaults)[_knownDefaults]);\n    Object.values(_classPrivateFieldLooseBase(this, _knownDefinitions)[_knownDefinitions]).forEach(({\n      types\n    }) => this.register(types));\n    return this;\n  }\n\n  get chainDecimals() {\n    var _classPrivateFieldLoo;\n\n    if ((_classPrivateFieldLoo = _classPrivateFieldLooseBase(this, _chainProperties)[_chainProperties]) !== null && _classPrivateFieldLoo !== void 0 && _classPrivateFieldLoo.tokenDecimals.isSome) {\n      const allDecimals = _classPrivateFieldLooseBase(this, _chainProperties)[_chainProperties].tokenDecimals.unwrap();\n\n      if (allDecimals.length) {\n        return allDecimals.map(b => b.toNumber());\n      }\n    }\n\n    return [12];\n  }\n\n  get chainSS58() {\n    var _classPrivateFieldLoo2;\n\n    return (_classPrivateFieldLoo2 = _classPrivateFieldLooseBase(this, _chainProperties)[_chainProperties]) !== null && _classPrivateFieldLoo2 !== void 0 && _classPrivateFieldLoo2.ss58Format.isSome ? _classPrivateFieldLooseBase(this, _chainProperties)[_chainProperties].ss58Format.unwrap().toNumber() : undefined;\n  }\n\n  get chainTokens() {\n    var _classPrivateFieldLoo3;\n\n    if ((_classPrivateFieldLoo3 = _classPrivateFieldLooseBase(this, _chainProperties)[_chainProperties]) !== null && _classPrivateFieldLoo3 !== void 0 && _classPrivateFieldLoo3.tokenSymbol.isSome) {\n      const allTokens = _classPrivateFieldLooseBase(this, _chainProperties)[_chainProperties].tokenSymbol.unwrap();\n\n      if (allTokens.length) {\n        return allTokens.map(s => s.toString());\n      }\n    }\n\n    return [formatBalance.getDefaults().unit];\n  }\n  /**\n   * @description Returns tru if the type is in a Compat format\n   */\n\n\n  isLookupType(value) {\n    return /Lookup\\d+$/.test(value);\n  }\n  /**\n   * @description Creates a lookup string from the supplied id\n   */\n\n\n  createLookupType(lookupId) {\n    return `Lookup${lookupId.toString()}`;\n  }\n\n  get knownTypes() {\n    return _classPrivateFieldLooseBase(this, _knownTypes)[_knownTypes];\n  }\n\n  get lookup() {\n    return this.metadata.lookup;\n  }\n\n  get metadata() {\n    assert(_classPrivateFieldLooseBase(this, _metadata)[_metadata], 'Metadata has not been set on this registry');\n    return _classPrivateFieldLooseBase(this, _metadata)[_metadata];\n  }\n\n  get unknownTypes() {\n    return [..._classPrivateFieldLooseBase(this, _unknownTypes)[_unknownTypes].keys()];\n  }\n\n  get signedExtensions() {\n    return _classPrivateFieldLooseBase(this, _signedExtensions)[_signedExtensions];\n  }\n  /**\n   * @describe Creates an instance of the class\n   */\n\n\n  createClass(type) {\n    return createClass(this, type);\n  }\n  /**\n   * @description Creates an instance of a type as registered\n   */\n\n\n  createType(type, ...params) {\n    return this.createTypeUnsafe(type, params);\n  }\n  /**\n   * @description Creates an instance of a type as registered\n   */\n\n\n  createTypeUnsafe(type, params, options) {\n    return createTypeUnsafe(this, type, params, options);\n  } // find a specific call\n\n\n  findMetaCall(callIndex) {\n    const hexIndex = u8aToHex(callIndex);\n    return assertReturn(_classPrivateFieldLooseBase(this, _metadataCalls)[_metadataCalls][hexIndex], `findMetaCall: Unable to find Call with index ${hexIndex}/[${callIndex.toString()}]`);\n  } // finds an error\n\n\n  findMetaError(errorIndex) {\n    const hexIndex = u8aToHex(isU8a(errorIndex) ? errorIndex : new Uint8Array([errorIndex.index.toNumber(), errorIndex.error.toNumber()]));\n    return assertReturn(_classPrivateFieldLooseBase(this, _metadataErrors)[_metadataErrors][hexIndex], `findMetaError: Unable to find Error with index ${hexIndex}/[${errorIndex.toString()}]`);\n  }\n\n  findMetaEvent(eventIndex) {\n    const hexIndex = u8aToHex(eventIndex);\n    return assertReturn(_classPrivateFieldLooseBase(this, _metadataEvents)[_metadataEvents][hexIndex], `findMetaEvent: Unable to find Event with index ${hexIndex}/[${eventIndex.toString()}]`);\n  }\n\n  get(name, withUnknown) {\n    let Type = _classPrivateFieldLooseBase(this, _classes)[_classes].get(name); // we have not already created the type, attempt it\n\n\n    if (!Type) {\n      const definition = _classPrivateFieldLooseBase(this, _definitions)[_definitions].get(name);\n\n      let BaseType; // we have a definition, so create the class now (lazily)\n\n      if (definition) {\n        BaseType = createClass(this, definition);\n\n        _classPrivateFieldLooseBase(this, _classes)[_classes].set(name, BaseType);\n      } else if (withUnknown) {\n        l.warn(`Unable to resolve type ${name}, it will fail on construction`);\n\n        _classPrivateFieldLooseBase(this, _unknownTypes)[_unknownTypes].set(name, true);\n\n        BaseType = DoNotConstruct.with(name);\n      }\n\n      if (BaseType) {\n        // NOTE If we didn't extend here, we would have strange artifacts. An example is\n        // Balance, with this, new Balance() instanceof u128 is true, but Balance !== u128\n        // Additionally, we now pass through the registry, which is a link to ourselves\n        Type = class extends BaseType {};\n\n        _classPrivateFieldLooseBase(this, _classes)[_classes].set(name, Type);\n      }\n    }\n\n    return Type;\n  }\n\n  getChainProperties() {\n    return _classPrivateFieldLooseBase(this, _chainProperties)[_chainProperties];\n  }\n\n  getClassName(Type) {\n    const entry = [..._classPrivateFieldLooseBase(this, _classes)[_classes].entries()].find(([, Clazz]) => Type === Clazz);\n    return entry ? entry[0] : undefined;\n  }\n\n  getDefinition(typeName) {\n    return _classPrivateFieldLooseBase(this, _definitions)[_definitions].get(typeName);\n  }\n\n  getModuleInstances(specName, moduleName) {\n    var _classPrivateFieldLoo4, _classPrivateFieldLoo5, _classPrivateFieldLoo6, _classPrivateFieldLoo7, _classPrivateFieldLoo8;\n\n    return (_classPrivateFieldLoo4 = _classPrivateFieldLooseBase(this, _knownTypes)[_knownTypes]) === null || _classPrivateFieldLoo4 === void 0 ? void 0 : (_classPrivateFieldLoo5 = _classPrivateFieldLoo4.typesBundle) === null || _classPrivateFieldLoo5 === void 0 ? void 0 : (_classPrivateFieldLoo6 = _classPrivateFieldLoo5.spec) === null || _classPrivateFieldLoo6 === void 0 ? void 0 : (_classPrivateFieldLoo7 = _classPrivateFieldLoo6[specName]) === null || _classPrivateFieldLoo7 === void 0 ? void 0 : (_classPrivateFieldLoo8 = _classPrivateFieldLoo7.instances) === null || _classPrivateFieldLoo8 === void 0 ? void 0 : _classPrivateFieldLoo8[moduleName];\n  }\n\n  getOrThrow(name, msg) {\n    const Clazz = this.get(name);\n    assert(Clazz, msg || `type ${name} not found`);\n    return Clazz;\n  }\n\n  getOrUnknown(name) {\n    return this.get(name, true);\n  }\n\n  getSignedExtensionExtra() {\n    return expandExtensionTypes(_classPrivateFieldLooseBase(this, _signedExtensions)[_signedExtensions], 'payload', _classPrivateFieldLooseBase(this, _userExtensions)[_userExtensions]);\n  }\n\n  getSignedExtensionTypes() {\n    return expandExtensionTypes(_classPrivateFieldLooseBase(this, _signedExtensions)[_signedExtensions], 'extrinsic', _classPrivateFieldLooseBase(this, _userExtensions)[_userExtensions]);\n  }\n\n  hasClass(name) {\n    return _classPrivateFieldLooseBase(this, _classes)[_classes].has(name);\n  }\n\n  hasDef(name) {\n    return _classPrivateFieldLooseBase(this, _definitions)[_definitions].has(name);\n  }\n\n  hasType(name) {\n    return !_classPrivateFieldLooseBase(this, _unknownTypes)[_unknownTypes].get(name) && (this.hasClass(name) || this.hasDef(name));\n  }\n\n  hash(data) {\n    return this.createType('CodecHash', _classPrivateFieldLooseBase(this, _hasher)[_hasher](data));\n  } // eslint-disable-next-line no-dupe-class-members\n\n\n  register(arg1, arg2) {\n    // NOTE Constructors appear as functions here\n    if (isFunction(arg1)) {\n      _classPrivateFieldLooseBase(this, _classes)[_classes].set(arg1.name, arg1);\n    } else if (isString(arg1)) {\n      assert(isFunction(arg2), () => `Expected class definition passed to '${arg1}' registration`);\n      assert(arg1 !== arg2.toString(), () => `Unable to register circular ${arg1} === ${arg1}`);\n\n      _classPrivateFieldLooseBase(this, _classes)[_classes].set(arg1, arg2);\n    } else {\n      this._registerObject(arg1);\n    }\n  }\n\n  _registerObject(obj) {\n    Object.entries(obj).forEach(([name, type]) => {\n      if (isFunction(type)) {\n        // This _looks_ a bit funny, but `typeof Clazz === 'function'\n        _classPrivateFieldLooseBase(this, _classes)[_classes].set(name, type);\n      } else {\n        const def = isString(type) ? type : stringify(type);\n        assert(name !== def, () => `Unable to register circular ${name} === ${def}`); // we already have this type, remove the classes registered for it\n\n        if (_classPrivateFieldLooseBase(this, _classes)[_classes].has(name)) {\n          _classPrivateFieldLooseBase(this, _classes)[_classes].delete(name);\n        }\n\n        _classPrivateFieldLooseBase(this, _definitions)[_definitions].set(name, def);\n      }\n    });\n  } // sets the chain properties\n\n\n  setChainProperties(properties) {\n    if (properties) {\n      _classPrivateFieldLooseBase(this, _chainProperties)[_chainProperties] = properties;\n    }\n  }\n\n  setHasher(hasher) {\n    _classPrivateFieldLooseBase(this, _hasher)[_hasher] = hasher || blake2AsU8a;\n  }\n\n  setKnownTypes(knownTypes) {\n    _classPrivateFieldLooseBase(this, _knownTypes)[_knownTypes] = knownTypes;\n  } // sets the metadata\n\n\n  setMetadata(metadata, signedExtensions, userExtensions) {\n    _classPrivateFieldLooseBase(this, _metadata)[_metadata] = metadata.asLatest;\n    injectExtrinsics(this, metadata, _classPrivateFieldLooseBase(this, _metadataCalls)[_metadataCalls]);\n    injectErrors(this, metadata, _classPrivateFieldLooseBase(this, _metadataErrors)[_metadataErrors]);\n    injectEvents(this, metadata, _classPrivateFieldLooseBase(this, _metadataEvents)[_metadataEvents]); // setup the available extensions\n\n    this.setSignedExtensions(signedExtensions || (metadata.asLatest.extrinsic.version.gt(BN_ZERO) // FIXME Use the extension and their injected types\n    ? metadata.asLatest.extrinsic.signedExtensions.map(({\n      identifier\n    }) => identifier.toString()) : fallbackExtensions), userExtensions); // setup the chain properties with format overrides\n\n    this.setChainProperties(extractProperties(this, metadata));\n  } // sets the available signed extensions\n\n\n  setSignedExtensions(signedExtensions = fallbackExtensions, userExtensions) {\n    _classPrivateFieldLooseBase(this, _signedExtensions)[_signedExtensions] = signedExtensions;\n    _classPrivateFieldLooseBase(this, _userExtensions)[_userExtensions] = userExtensions;\n    const unknown = findUnknownExtensions(_classPrivateFieldLooseBase(this, _signedExtensions)[_signedExtensions], _classPrivateFieldLooseBase(this, _userExtensions)[_userExtensions]);\n\n    if (unknown.length) {\n      l.warn(`Unknown signed extensions ${unknown.join(', ')} found, treating them as no-effect`);\n    }\n  }\n\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/types/create/registry.js"],"names":["_classPrivateFieldLooseBase","_classPrivateFieldLooseKey","_defineProperty","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","assert","assertReturn","BN_ZERO","formatBalance","isFunction","isString","isU8a","logger","stringCamelCase","stringify","u8aToHex","blake2AsU8a","DoNotConstruct","Json","Raw","expandExtensionTypes","fallbackExtensions","findUnknownExtensions","GenericEventData","baseTypes","definitions","decorateConstants","decorateExtrinsics","Metadata","createClass","createTypeUnsafe","l","injectErrors","_","metadata","metadataErrors","lookup","pallets","asLatest","errors","index","name","_sectionIndex","isNone","sectionIndex","version","toNumber","sectionName","getSiType","unwrap","type","def","asVariant","variants","docs","fields","variantIndex","eventIndex","Uint8Array","args","map","getTypeDef","d","toString","method","section","injectEvents","registry","metadataEvents","events","isSome","variant","meta","createType","constructor","value","injectExtrinsics","metadataCalls","extrinsics","values","methods","callIndex","extractProperties","_constants$system","original","getChainProperties","constants","ss58Format","system","ss58Prefix","tokenDecimals","tokenSymbol","_classes","_definitions","_metadata","_metadataCalls","_metadataErrors","_metadataEvents","_unknownTypes","_chainProperties","_hasher","_knownDefaults","_knownDefinitions","_knownTypes","_signedExtensions","_userExtensions","TypeRegistry","createdAtHash","writable","Map","init","register","types","chainDecimals","_classPrivateFieldLoo","allDecimals","b","chainSS58","_classPrivateFieldLoo2","undefined","chainTokens","_classPrivateFieldLoo3","allTokens","s","getDefaults","unit","isLookupType","test","createLookupType","lookupId","knownTypes","unknownTypes","signedExtensions","params","options","findMetaCall","hexIndex","findMetaError","errorIndex","error","findMetaEvent","get","withUnknown","Type","definition","BaseType","set","warn","with","getClassName","entry","entries","find","Clazz","getDefinition","typeName","getModuleInstances","specName","moduleName","_classPrivateFieldLoo4","_classPrivateFieldLoo5","_classPrivateFieldLoo6","_classPrivateFieldLoo7","_classPrivateFieldLoo8","typesBundle","spec","instances","getOrThrow","msg","getOrUnknown","getSignedExtensionExtra","getSignedExtensionTypes","hasClass","has","hasDef","hasType","hash","data","arg1","arg2","_registerObject","obj","delete","setChainProperties","properties","setHasher","hasher","setKnownTypes","setMetadata","userExtensions","setSignedExtensions","extrinsic","gt","identifier","unknown","join"],"mappings":"AAAA,OAAOA,2BAAP,MAAwC,uDAAxC;AACA,OAAOC,0BAAP,MAAuC,sDAAvC;AACA,OAAOC,eAAP,MAA4B,2CAA5B;;AAEA,SAASC,OAAT,CAAiBC,MAAjB,EAAyBC,cAAzB,EAAyC;AAAE,MAAIC,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYF,MAAZ,CAAX;;AAAgC,MAAIG,MAAM,CAACC,qBAAX,EAAkC;AAAE,QAAIC,OAAO,GAAGF,MAAM,CAACC,qBAAP,CAA6BJ,MAA7B,CAAd;;AAAoD,QAAIC,cAAJ,EAAoB;AAAEI,MAAAA,OAAO,GAAGA,OAAO,CAACC,MAAR,CAAe,UAAUC,GAAV,EAAe;AAAE,eAAOJ,MAAM,CAACK,wBAAP,CAAgCR,MAAhC,EAAwCO,GAAxC,EAA6CE,UAApD;AAAiE,OAAjG,CAAV;AAA+G;;AAACP,IAAAA,IAAI,CAACQ,IAAL,CAAUC,KAAV,CAAgBT,IAAhB,EAAsBG,OAAtB;AAAiC;;AAAC,SAAOH,IAAP;AAAc;;AAEzV,SAASU,aAAT,CAAuBC,MAAvB,EAA+B;AAAE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,SAAS,CAACC,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;AAAE,QAAIG,MAAM,GAAGF,SAAS,CAACD,CAAD,CAAT,IAAgB,IAAhB,GAAuBC,SAAS,CAACD,CAAD,CAAhC,GAAsC,EAAnD;;AAAuD,QAAIA,CAAC,GAAG,CAAR,EAAW;AAAEf,MAAAA,OAAO,CAACI,MAAM,CAACc,MAAD,CAAP,EAAiB,IAAjB,CAAP,CAA8BC,OAA9B,CAAsC,UAAUC,GAAV,EAAe;AAAErB,QAAAA,eAAe,CAACe,MAAD,EAASM,GAAT,EAAcF,MAAM,CAACE,GAAD,CAApB,CAAf;AAA4C,OAAnG;AAAuG,KAApH,MAA0H,IAAIhB,MAAM,CAACiB,yBAAX,EAAsC;AAAEjB,MAAAA,MAAM,CAACkB,gBAAP,CAAwBR,MAAxB,EAAgCV,MAAM,CAACiB,yBAAP,CAAiCH,MAAjC,CAAhC;AAA4E,KAApH,MAA0H;AAAElB,MAAAA,OAAO,CAACI,MAAM,CAACc,MAAD,CAAP,CAAP,CAAwBC,OAAxB,CAAgC,UAAUC,GAAV,EAAe;AAAEhB,QAAAA,MAAM,CAACmB,cAAP,CAAsBT,MAAtB,EAA8BM,GAA9B,EAAmChB,MAAM,CAACK,wBAAP,CAAgCS,MAAhC,EAAwCE,GAAxC,CAAnC;AAAmF,OAApI;AAAwI;AAAE;;AAAC,SAAON,MAAP;AAAgB,C,CAEthB;AACA;;;AACA,SAASU,MAAT,EAAiBC,YAAjB,EAA+BC,OAA/B,EAAwCC,aAAxC,EAAuDC,UAAvD,EAAmEC,QAAnE,EAA6EC,KAA7E,EAAoFC,MAApF,EAA4FC,eAA5F,EAA6GC,SAA7G,EAAwHC,QAAxH,QAAwI,gBAAxI;AACA,SAASC,WAAT,QAA4B,uBAA5B;AACA,SAASC,cAAT,QAA+B,4BAA/B;AACA,SAASC,IAAT,QAAqB,kBAArB;AACA,SAASC,GAAT,QAAoB,iBAApB;AACA,SAASC,oBAAT,EAA+BC,kBAA/B,EAAmDC,qBAAnD,QAAgF,wCAAhF;AACA,SAASC,gBAAT,QAAiC,qBAAjC;AACA,OAAO,KAAKC,SAAZ,MAA2B,mBAA3B;AACA,OAAO,KAAKC,WAAZ,MAA6B,8BAA7B;AACA,SAASC,iBAAT,EAA4BC,kBAA5B,QAAsD,+BAAtD;AACA,SAASC,QAAT,QAAyB,yBAAzB;AACA,SAASC,WAAT,QAA4B,kBAA5B;AACA,SAASC,gBAAT,QAAiC,iBAAjC;AACA,MAAMC,CAAC,GAAGnB,MAAM,CAAC,UAAD,CAAhB,C,CAA8B;;AAE9B,SAASoB,YAAT,CAAsBC,CAAtB,EAAyBC,QAAzB,EAAmCC,cAAnC,EAAmD;AACjD,QAAM;AACJC,IAAAA,MADI;AAEJC,IAAAA;AAFI,MAGFH,QAAQ,CAACI,QAHb,CADiD,CAI1B;;AAEvBD,EAAAA,OAAO,CAACrC,OAAR,CAAgB,CAAC;AACfuC,IAAAA,MADe;AAEfC,IAAAA,KAFe;AAGfC,IAAAA;AAHe,GAAD,EAIbC,aAJa,KAIK;AACnB,QAAIH,MAAM,CAACI,MAAX,EAAmB;AACjB;AACD;;AAED,UAAMC,YAAY,GAAGV,QAAQ,CAACW,OAAT,IAAoB,EAApB,GAAyBL,KAAK,CAACM,QAAN,EAAzB,GAA4CJ,aAAjE;AACA,UAAMK,WAAW,GAAGlC,eAAe,CAAC4B,IAAD,CAAnC;AACAL,IAAAA,MAAM,CAACY,SAAP,CAAiBT,MAAM,CAACU,MAAP,GAAgBC,IAAjC,EAAuCC,GAAvC,CAA2CC,SAA3C,CAAqDC,QAArD,CAA8DrD,OAA9D,CAAsE,CAAC;AACrEsD,MAAAA,IADqE;AAErEC,MAAAA,MAFqE;AAGrEf,MAAAA,KAHqE;AAIrEC,MAAAA;AAJqE,KAAD,KAKhE;AACJ,YAAMe,YAAY,GAAGhB,KAAK,CAACM,QAAN,EAArB;AACA,YAAMW,UAAU,GAAG,IAAIC,UAAJ,CAAe,CAACd,YAAD,EAAeY,YAAf,CAAf,CAAnB;AACArB,MAAAA,cAAc,CAACpB,QAAQ,CAAC0C,UAAD,CAAT,CAAd,GAAuC;AACrCE,QAAAA,IAAI,EAAEJ,MAAM,CAACK,GAAP,CAAW,CAAC;AAChBV,UAAAA;AADgB,SAAD,KAEXd,MAAM,CAACyB,UAAP,CAAkBX,IAAlB,EAAwBA,IAFxB,CAD+B;AAIrCI,QAAAA,IAAI,EAAEA,IAAI,CAACM,GAAL,CAASE,CAAC,IAAIA,CAAC,CAACC,QAAF,EAAd,CAJ+B;AAKrCR,QAAAA,MALqC;AAMrCf,QAAAA,KAAK,EAAEgB,YAN8B;AAOrCQ,QAAAA,MAAM,EAAEvB,IAAI,CAACsB,QAAL,EAP6B;AAQrCtB,QAAAA,IAAI,EAAEA,IAAI,CAACsB,QAAL,EAR+B;AASrCE,QAAAA,OAAO,EAAElB;AAT4B,OAAvC;AAWD,KAnBD;AAoBD,GA/BD;AAgCD,C,CAAC;;;AAGF,SAASmB,YAAT,CAAsBC,QAAtB,EAAgCjC,QAAhC,EAA0CkC,cAA1C,EAA0D;AACxD,QAAM;AACJhC,IAAAA,MADI;AAEJC,IAAAA;AAFI,MAGFH,QAAQ,CAACI,QAHb,CADwD,CAIjC;;AAEvBD,EAAAA,OAAO,CAACjD,MAAR,CAAe,CAAC;AACdiF,IAAAA;AADc,GAAD,KAETA,MAAM,CAACC,MAFb,EAEqBtE,OAFrB,CAE6B,CAAC;AAC5BqE,IAAAA,MAD4B;AAE5B7B,IAAAA,KAF4B;AAG5BC,IAAAA;AAH4B,GAAD,EAI1BC,aAJ0B,KAIR;AACnB,UAAME,YAAY,GAAGV,QAAQ,CAACW,OAAT,IAAoB,EAApB,GAAyBL,KAAK,CAACM,QAAN,EAAzB,GAA4CJ,aAAjE;AACA,UAAMK,WAAW,GAAGlC,eAAe,CAAC4B,IAAD,CAAnC;AACAL,IAAAA,MAAM,CAACY,SAAP,CAAiBqB,MAAM,CAACpB,MAAP,GAAgBC,IAAjC,EAAuCC,GAAvC,CAA2CC,SAA3C,CAAqDC,QAArD,CAA8DrD,OAA9D,CAAsEuE,OAAO,IAAI;AAC/E,YAAMf,YAAY,GAAGe,OAAO,CAAC/B,KAAR,CAAcM,QAAd,EAArB;AACA,YAAMW,UAAU,GAAG,IAAIC,UAAJ,CAAe,CAACd,YAAD,EAAeY,YAAf,CAAf,CAAnB;AACA,YAAMgB,IAAI,GAAGL,QAAQ,CAACM,UAAT,CAAoB,qBAApB,EAA2C/E,aAAa,CAACA,aAAa,CAAC,EAAD,EAAK6E,OAAL,CAAd,EAA6B,EAA7B,EAAiC;AACpGZ,QAAAA,IAAI,EAAEY,OAAO,CAAChB,MAAR,CAAeK,GAAf,CAAmB,CAAC;AACxBV,UAAAA;AADwB,SAAD,KAEnBd,MAAM,CAACyB,UAAP,CAAkBX,IAAlB,EAAwBA,IAFxB;AAD8F,OAAjC,CAAxD,CAAb;AAKAkB,MAAAA,cAAc,CAACrD,QAAQ,CAAC0C,UAAD,CAAT,CAAd,GAAuC,cAAclC,gBAAd,CAA+B;AACpEmD,QAAAA,WAAW,CAACP,QAAD,EAAWQ,KAAX,EAAkB;AAC3B,gBAAMR,QAAN,EAAgBQ,KAAhB,EAAuBH,IAAvB,EAA6BzB,WAA7B,EAA0CwB,OAAO,CAAC9B,IAAR,CAAasB,QAAb,EAA1C;AACD;;AAHmE,OAAtE;AAMD,KAdD;AAeD,GAxBD;AAyBD,C,CAAC;;;AAGF,SAASa,gBAAT,CAA0BT,QAA1B,EAAoCjC,QAApC,EAA8C2C,aAA9C,EAA6D;AAC3D,QAAMC,UAAU,GAAGnD,kBAAkB,CAACwC,QAAD,EAAWjC,QAAQ,CAACI,QAApB,EAA8BJ,QAAQ,CAACW,OAAvC,CAArC,CAD2D,CAC2B;;AAEtF5D,EAAAA,MAAM,CAAC8F,MAAP,CAAcD,UAAd,EAA0B9E,OAA1B,CAAkCgF,OAAO,IAAI/F,MAAM,CAAC8F,MAAP,CAAcC,OAAd,EAAuBhF,OAAvB,CAA+BgE,MAAM,IAAI;AACpFa,IAAAA,aAAa,CAAC9D,QAAQ,CAACiD,MAAM,CAACiB,SAAR,CAAT,CAAb,GAA4CjB,MAA5C;AACD,GAF4C,CAA7C;AAGD,C,CAAC;;;AAGF,SAASkB,iBAAT,CAA2Bf,QAA3B,EAAqCjC,QAArC,EAA+C;AAC7C,MAAIiD,iBAAJ;;AAEA,QAAMC,QAAQ,GAAGjB,QAAQ,CAACkB,kBAAT,EAAjB;AACA,QAAMC,SAAS,GAAG5D,iBAAiB,CAACyC,QAAD,EAAWjC,QAAQ,CAACI,QAApB,EAA8BJ,QAAQ,CAACW,OAAvC,CAAnC;AACA,QAAM0C,UAAU,GAAG,CAACJ,iBAAiB,GAAGG,SAAS,CAACE,MAA/B,MAA2C,IAA3C,IAAmDL,iBAAiB,KAAK,KAAK,CAA9E,GAAkF,KAAK,CAAvF,GAA2FA,iBAAiB,CAACM,UAAhI;;AAEA,MAAI,CAACF,UAAL,EAAiB;AACf,WAAOH,QAAP;AACD;;AAED,QAAM;AACJM,IAAAA,aADI;AAEJC,IAAAA;AAFI,MAGFP,QAAQ,IAAI,EAHhB;AAIA,SAAOjB,QAAQ,CAACM,UAAT,CAAoB,iBAApB,EAAuC;AAC5Cc,IAAAA,UAD4C;AAE5CG,IAAAA,aAF4C;AAG5CC,IAAAA;AAH4C,GAAvC,CAAP;AAKD;;AAED,IAAIC,QAAQ,GAAG,aAAajH,0BAA0B,CAAC,SAAD,CAAtD;;AAEA,IAAIkH,YAAY,GAAG,aAAalH,0BAA0B,CAAC,aAAD,CAA1D;;AAEA,IAAImH,SAAS,GAAG,aAAanH,0BAA0B,CAAC,UAAD,CAAvD;;AAEA,IAAIoH,cAAc,GAAG,aAAapH,0BAA0B,CAAC,eAAD,CAA5D;;AAEA,IAAIqH,eAAe,GAAG,aAAarH,0BAA0B,CAAC,gBAAD,CAA7D;;AAEA,IAAIsH,eAAe,GAAG,aAAatH,0BAA0B,CAAC,gBAAD,CAA7D;;AAEA,IAAIuH,aAAa,GAAG,aAAavH,0BAA0B,CAAC,cAAD,CAA3D;;AAEA,IAAIwH,gBAAgB,GAAG,aAAaxH,0BAA0B,CAAC,iBAAD,CAA9D;;AAEA,IAAIyH,OAAO,GAAG,aAAazH,0BAA0B,CAAC,QAAD,CAArD;;AAEA,IAAI0H,cAAc,GAAG,aAAa1H,0BAA0B,CAAC,eAAD,CAA5D;;AAEA,IAAI2H,iBAAiB,GAAG,aAAa3H,0BAA0B,CAAC,kBAAD,CAA/D;;AAEA,IAAI4H,WAAW,GAAG,aAAa5H,0BAA0B,CAAC,YAAD,CAAzD;;AAEA,IAAI6H,iBAAiB,GAAG,aAAa7H,0BAA0B,CAAC,kBAAD,CAA/D;;AAEA,IAAI8H,eAAe,GAAG,aAAa9H,0BAA0B,CAAC,gBAAD,CAA7D;;AAEA,OAAO,MAAM+H,YAAN,CAAmB;AACxBhC,EAAAA,WAAW,CAACiC,aAAD,EAAgB;AACzB1H,IAAAA,MAAM,CAACmB,cAAP,CAAsB,IAAtB,EAA4BwF,QAA5B,EAAsC;AACpCgB,MAAAA,QAAQ,EAAE,IAD0B;AAEpCjC,MAAAA,KAAK,EAAE,IAAIkC,GAAJ;AAF6B,KAAtC;AAIA5H,IAAAA,MAAM,CAACmB,cAAP,CAAsB,IAAtB,EAA4ByF,YAA5B,EAA0C;AACxCe,MAAAA,QAAQ,EAAE,IAD8B;AAExCjC,MAAAA,KAAK,EAAE,IAAIkC,GAAJ;AAFiC,KAA1C;AAIA5H,IAAAA,MAAM,CAACmB,cAAP,CAAsB,IAAtB,EAA4B0F,SAA5B,EAAuC;AACrCc,MAAAA,QAAQ,EAAE,IAD2B;AAErCjC,MAAAA,KAAK,EAAE,KAAK;AAFyB,KAAvC;AAIA1F,IAAAA,MAAM,CAACmB,cAAP,CAAsB,IAAtB,EAA4B2F,cAA5B,EAA4C;AAC1Ca,MAAAA,QAAQ,EAAE,IADgC;AAE1CjC,MAAAA,KAAK,EAAE;AAFmC,KAA5C;AAIA1F,IAAAA,MAAM,CAACmB,cAAP,CAAsB,IAAtB,EAA4B4F,eAA5B,EAA6C;AAC3CY,MAAAA,QAAQ,EAAE,IADiC;AAE3CjC,MAAAA,KAAK,EAAE;AAFoC,KAA7C;AAIA1F,IAAAA,MAAM,CAACmB,cAAP,CAAsB,IAAtB,EAA4B6F,eAA5B,EAA6C;AAC3CW,MAAAA,QAAQ,EAAE,IADiC;AAE3CjC,MAAAA,KAAK,EAAE;AAFoC,KAA7C;AAIA1F,IAAAA,MAAM,CAACmB,cAAP,CAAsB,IAAtB,EAA4B8F,aAA5B,EAA2C;AACzCU,MAAAA,QAAQ,EAAE,IAD+B;AAEzCjC,MAAAA,KAAK,EAAE,IAAIkC,GAAJ;AAFkC,KAA3C;AAIA5H,IAAAA,MAAM,CAACmB,cAAP,CAAsB,IAAtB,EAA4B+F,gBAA5B,EAA8C;AAC5CS,MAAAA,QAAQ,EAAE,IADkC;AAE5CjC,MAAAA,KAAK,EAAE,KAAK;AAFgC,KAA9C;AAIA1F,IAAAA,MAAM,CAACmB,cAAP,CAAsB,IAAtB,EAA4BgG,OAA5B,EAAqC;AACnCQ,MAAAA,QAAQ,EAAE,IADyB;AAEnCjC,MAAAA,KAAK,EAAE3D;AAF4B,KAArC;AAIA/B,IAAAA,MAAM,CAACmB,cAAP,CAAsB,IAAtB,EAA4BiG,cAA5B,EAA4C;AAC1CO,MAAAA,QAAQ,EAAE,IADgC;AAE1CjC,MAAAA,KAAK,EAAE,KAAK;AAF8B,KAA5C;AAIA1F,IAAAA,MAAM,CAACmB,cAAP,CAAsB,IAAtB,EAA4BkG,iBAA5B,EAA+C;AAC7CM,MAAAA,QAAQ,EAAE,IADmC;AAE7CjC,MAAAA,KAAK,EAAE,KAAK;AAFiC,KAA/C;AAIA1F,IAAAA,MAAM,CAACmB,cAAP,CAAsB,IAAtB,EAA4BmG,WAA5B,EAAyC;AACvCK,MAAAA,QAAQ,EAAE,IAD6B;AAEvCjC,MAAAA,KAAK,EAAE;AAFgC,KAAzC;AAIA1F,IAAAA,MAAM,CAACmB,cAAP,CAAsB,IAAtB,EAA4BoG,iBAA5B,EAA+C;AAC7CI,MAAAA,QAAQ,EAAE,IADmC;AAE7CjC,MAAAA,KAAK,EAAEtD;AAFsC,KAA/C;AAIApC,IAAAA,MAAM,CAACmB,cAAP,CAAsB,IAAtB,EAA4BqG,eAA5B,EAA6C;AAC3CG,MAAAA,QAAQ,EAAE,IADiC;AAE3CjC,MAAAA,KAAK,EAAE,KAAK;AAF+B,KAA7C;AAIA,SAAKgC,aAAL,GAAqB,KAAK,CAA1B;AACAjI,IAAAA,2BAA2B,CAAC,IAAD,EAAO2H,cAAP,CAA3B,CAAkDA,cAAlD,IAAoE3G,aAAa,CAAC;AAChFwB,MAAAA,IADgF;AAEhFU,MAAAA,QAFgF;AAGhFT,MAAAA;AAHgF,KAAD,EAI9EK,SAJ8E,CAAjF;AAKA9C,IAAAA,2BAA2B,CAAC,IAAD,EAAO4H,iBAAP,CAA3B,CAAqDA,iBAArD,IAA0E7E,WAA1E;AACA,SAAKqF,IAAL;;AAEA,QAAIH,aAAJ,EAAmB;AACjB,WAAKA,aAAL,GAAqB,KAAKlC,UAAL,CAAgB,MAAhB,EAAwBkC,aAAxB,CAArB;AACD;AACF;;AAEDG,EAAAA,IAAI,GAAG;AACL;AACApI,IAAAA,2BAA2B,CAAC,IAAD,EAAOkH,QAAP,CAA3B,CAA4CA,QAA5C,IAAwD,IAAIiB,GAAJ,EAAxD;AACAnI,IAAAA,2BAA2B,CAAC,IAAD,EAAOmH,YAAP,CAA3B,CAAgDA,YAAhD,IAAgE,IAAIgB,GAAJ,EAAhE;AACAnI,IAAAA,2BAA2B,CAAC,IAAD,EAAOwH,aAAP,CAA3B,CAAiDA,aAAjD,IAAkE,IAAIW,GAAJ,EAAlE;AACAnI,IAAAA,2BAA2B,CAAC,IAAD,EAAO6H,WAAP,CAA3B,CAA+CA,WAA/C,IAA8D,EAA9D,CALK,CAK6D;;AAElE,SAAKQ,QAAL,CAAcrI,2BAA2B,CAAC,IAAD,EAAO2H,cAAP,CAA3B,CAAkDA,cAAlD,CAAd;AACApH,IAAAA,MAAM,CAAC8F,MAAP,CAAcrG,2BAA2B,CAAC,IAAD,EAAO4H,iBAAP,CAA3B,CAAqDA,iBAArD,CAAd,EAAuFtG,OAAvF,CAA+F,CAAC;AAC9FgH,MAAAA;AAD8F,KAAD,KAEzF,KAAKD,QAAL,CAAcC,KAAd,CAFN;AAGA,WAAO,IAAP;AACD;;AAEgB,MAAbC,aAAa,GAAG;AAClB,QAAIC,qBAAJ;;AAEA,QAAI,CAACA,qBAAqB,GAAGxI,2BAA2B,CAAC,IAAD,EAAOyH,gBAAP,CAA3B,CAAoDA,gBAApD,CAAzB,MAAoG,IAApG,IAA4Ge,qBAAqB,KAAK,KAAK,CAA3I,IAAgJA,qBAAqB,CAACxB,aAAtB,CAAoCpB,MAAxL,EAAgM;AAC9L,YAAM6C,WAAW,GAAGzI,2BAA2B,CAAC,IAAD,EAAOyH,gBAAP,CAA3B,CAAoDA,gBAApD,EAAsET,aAAtE,CAAoFzC,MAApF,EAApB;;AAEA,UAAIkE,WAAW,CAACrH,MAAhB,EAAwB;AACtB,eAAOqH,WAAW,CAACvD,GAAZ,CAAgBwD,CAAC,IAAIA,CAAC,CAACtE,QAAF,EAArB,CAAP;AACD;AACF;;AAED,WAAO,CAAC,EAAD,CAAP;AACD;;AAEY,MAATuE,SAAS,GAAG;AACd,QAAIC,sBAAJ;;AAEA,WAAO,CAACA,sBAAsB,GAAG5I,2BAA2B,CAAC,IAAD,EAAOyH,gBAAP,CAA3B,CAAoDA,gBAApD,CAA1B,MAAqG,IAArG,IAA6GmB,sBAAsB,KAAK,KAAK,CAA7I,IAAkJA,sBAAsB,CAAC/B,UAAvB,CAAkCjB,MAApL,GAA6L5F,2BAA2B,CAAC,IAAD,EAAOyH,gBAAP,CAA3B,CAAoDA,gBAApD,EAAsEZ,UAAtE,CAAiFtC,MAAjF,GAA0FH,QAA1F,EAA7L,GAAoSyE,SAA3S;AACD;;AAEc,MAAXC,WAAW,GAAG;AAChB,QAAIC,sBAAJ;;AAEA,QAAI,CAACA,sBAAsB,GAAG/I,2BAA2B,CAAC,IAAD,EAAOyH,gBAAP,CAA3B,CAAoDA,gBAApD,CAA1B,MAAqG,IAArG,IAA6GsB,sBAAsB,KAAK,KAAK,CAA7I,IAAkJA,sBAAsB,CAAC9B,WAAvB,CAAmCrB,MAAzL,EAAiM;AAC/L,YAAMoD,SAAS,GAAGhJ,2BAA2B,CAAC,IAAD,EAAOyH,gBAAP,CAA3B,CAAoDA,gBAApD,EAAsER,WAAtE,CAAkF1C,MAAlF,EAAlB;;AAEA,UAAIyE,SAAS,CAAC5H,MAAd,EAAsB;AACpB,eAAO4H,SAAS,CAAC9D,GAAV,CAAc+D,CAAC,IAAIA,CAAC,CAAC5D,QAAF,EAAnB,CAAP;AACD;AACF;;AAED,WAAO,CAACvD,aAAa,CAACoH,WAAd,GAA4BC,IAA7B,CAAP;AACD;AACD;AACF;AACA;;;AAGEC,EAAAA,YAAY,CAACnD,KAAD,EAAQ;AAClB,WAAO,aAAaoD,IAAb,CAAkBpD,KAAlB,CAAP;AACD;AACD;AACF;AACA;;;AAGEqD,EAAAA,gBAAgB,CAACC,QAAD,EAAW;AACzB,WAAQ,SAAQA,QAAQ,CAAClE,QAAT,EAAoB,EAApC;AACD;;AAEa,MAAVmE,UAAU,GAAG;AACf,WAAOxJ,2BAA2B,CAAC,IAAD,EAAO6H,WAAP,CAA3B,CAA+CA,WAA/C,CAAP;AACD;;AAES,MAANnE,MAAM,GAAG;AACX,WAAO,KAAKF,QAAL,CAAcE,MAArB;AACD;;AAEW,MAARF,QAAQ,GAAG;AACb7B,IAAAA,MAAM,CAAC3B,2BAA2B,CAAC,IAAD,EAAOoH,SAAP,CAA3B,CAA6CA,SAA7C,CAAD,EAA0D,4CAA1D,CAAN;AACA,WAAOpH,2BAA2B,CAAC,IAAD,EAAOoH,SAAP,CAA3B,CAA6CA,SAA7C,CAAP;AACD;;AAEe,MAAZqC,YAAY,GAAG;AACjB,WAAO,CAAC,GAAGzJ,2BAA2B,CAAC,IAAD,EAAOwH,aAAP,CAA3B,CAAiDA,aAAjD,EAAgElH,IAAhE,EAAJ,CAAP;AACD;;AAEmB,MAAhBoJ,gBAAgB,GAAG;AACrB,WAAO1J,2BAA2B,CAAC,IAAD,EAAO8H,iBAAP,CAA3B,CAAqDA,iBAArD,CAAP;AACD;AACD;AACF;AACA;;;AAGE3E,EAAAA,WAAW,CAACqB,IAAD,EAAO;AAChB,WAAOrB,WAAW,CAAC,IAAD,EAAOqB,IAAP,CAAlB;AACD;AACD;AACF;AACA;;;AAGEuB,EAAAA,UAAU,CAACvB,IAAD,EAAO,GAAGmF,MAAV,EAAkB;AAC1B,WAAO,KAAKvG,gBAAL,CAAsBoB,IAAtB,EAA4BmF,MAA5B,CAAP;AACD;AACD;AACF;AACA;;;AAGEvG,EAAAA,gBAAgB,CAACoB,IAAD,EAAOmF,MAAP,EAAeC,OAAf,EAAwB;AACtC,WAAOxG,gBAAgB,CAAC,IAAD,EAAOoB,IAAP,EAAamF,MAAb,EAAqBC,OAArB,CAAvB;AACD,GAnLuB,CAmLtB;;;AAGFC,EAAAA,YAAY,CAACtD,SAAD,EAAY;AACtB,UAAMuD,QAAQ,GAAGzH,QAAQ,CAACkE,SAAD,CAAzB;AACA,WAAO3E,YAAY,CAAC5B,2BAA2B,CAAC,IAAD,EAAOqH,cAAP,CAA3B,CAAkDA,cAAlD,EAAkEyC,QAAlE,CAAD,EAA+E,gDAA+CA,QAAS,KAAIvD,SAAS,CAAClB,QAAV,EAAqB,GAAhK,CAAnB;AACD,GAzLuB,CAyLtB;;;AAGF0E,EAAAA,aAAa,CAACC,UAAD,EAAa;AACxB,UAAMF,QAAQ,GAAGzH,QAAQ,CAACJ,KAAK,CAAC+H,UAAD,CAAL,GAAoBA,UAApB,GAAiC,IAAIhF,UAAJ,CAAe,CAACgF,UAAU,CAAClG,KAAX,CAAiBM,QAAjB,EAAD,EAA8B4F,UAAU,CAACC,KAAX,CAAiB7F,QAAjB,EAA9B,CAAf,CAAlC,CAAzB;AACA,WAAOxC,YAAY,CAAC5B,2BAA2B,CAAC,IAAD,EAAOsH,eAAP,CAA3B,CAAmDA,eAAnD,EAAoEwC,QAApE,CAAD,EAAiF,kDAAiDA,QAAS,KAAIE,UAAU,CAAC3E,QAAX,EAAsB,GAArK,CAAnB;AACD;;AAED6E,EAAAA,aAAa,CAACnF,UAAD,EAAa;AACxB,UAAM+E,QAAQ,GAAGzH,QAAQ,CAAC0C,UAAD,CAAzB;AACA,WAAOnD,YAAY,CAAC5B,2BAA2B,CAAC,IAAD,EAAOuH,eAAP,CAA3B,CAAmDA,eAAnD,EAAoEuC,QAApE,CAAD,EAAiF,kDAAiDA,QAAS,KAAI/E,UAAU,CAACM,QAAX,EAAsB,GAArK,CAAnB;AACD;;AAED8E,EAAAA,GAAG,CAACpG,IAAD,EAAOqG,WAAP,EAAoB;AACrB,QAAIC,IAAI,GAAGrK,2BAA2B,CAAC,IAAD,EAAOkH,QAAP,CAA3B,CAA4CA,QAA5C,EAAsDiD,GAAtD,CAA0DpG,IAA1D,CAAX,CADqB,CACuD;;;AAG5E,QAAI,CAACsG,IAAL,EAAW;AACT,YAAMC,UAAU,GAAGtK,2BAA2B,CAAC,IAAD,EAAOmH,YAAP,CAA3B,CAAgDA,YAAhD,EAA8DgD,GAA9D,CAAkEpG,IAAlE,CAAnB;;AAEA,UAAIwG,QAAJ,CAHS,CAGK;;AAEd,UAAID,UAAJ,EAAgB;AACdC,QAAAA,QAAQ,GAAGpH,WAAW,CAAC,IAAD,EAAOmH,UAAP,CAAtB;;AAEAtK,QAAAA,2BAA2B,CAAC,IAAD,EAAOkH,QAAP,CAA3B,CAA4CA,QAA5C,EAAsDsD,GAAtD,CAA0DzG,IAA1D,EAAgEwG,QAAhE;AACD,OAJD,MAIO,IAAIH,WAAJ,EAAiB;AACtB/G,QAAAA,CAAC,CAACoH,IAAF,CAAQ,0BAAyB1G,IAAK,gCAAtC;;AAEA/D,QAAAA,2BAA2B,CAAC,IAAD,EAAOwH,aAAP,CAA3B,CAAiDA,aAAjD,EAAgEgD,GAAhE,CAAoEzG,IAApE,EAA0E,IAA1E;;AAEAwG,QAAAA,QAAQ,GAAGhI,cAAc,CAACmI,IAAf,CAAoB3G,IAApB,CAAX;AACD;;AAED,UAAIwG,QAAJ,EAAc;AACZ;AACA;AACA;AACAF,QAAAA,IAAI,GAAG,cAAcE,QAAd,CAAuB,EAA9B;;AAEAvK,QAAAA,2BAA2B,CAAC,IAAD,EAAOkH,QAAP,CAA3B,CAA4CA,QAA5C,EAAsDsD,GAAtD,CAA0DzG,IAA1D,EAAgEsG,IAAhE;AACD;AACF;;AAED,WAAOA,IAAP;AACD;;AAED1D,EAAAA,kBAAkB,GAAG;AACnB,WAAO3G,2BAA2B,CAAC,IAAD,EAAOyH,gBAAP,CAA3B,CAAoDA,gBAApD,CAAP;AACD;;AAEDkD,EAAAA,YAAY,CAACN,IAAD,EAAO;AACjB,UAAMO,KAAK,GAAG,CAAC,GAAG5K,2BAA2B,CAAC,IAAD,EAAOkH,QAAP,CAA3B,CAA4CA,QAA5C,EAAsD2D,OAAtD,EAAJ,EAAqEC,IAArE,CAA0E,CAAC,GAAGC,KAAH,CAAD,KAAeV,IAAI,KAAKU,KAAlG,CAAd;AACA,WAAOH,KAAK,GAAGA,KAAK,CAAC,CAAD,CAAR,GAAc/B,SAA1B;AACD;;AAEDmC,EAAAA,aAAa,CAACC,QAAD,EAAW;AACtB,WAAOjL,2BAA2B,CAAC,IAAD,EAAOmH,YAAP,CAA3B,CAAgDA,YAAhD,EAA8DgD,GAA9D,CAAkEc,QAAlE,CAAP;AACD;;AAEDC,EAAAA,kBAAkB,CAACC,QAAD,EAAWC,UAAX,EAAuB;AACvC,QAAIC,sBAAJ,EAA4BC,sBAA5B,EAAoDC,sBAApD,EAA4EC,sBAA5E,EAAoGC,sBAApG;;AAEA,WAAO,CAACJ,sBAAsB,GAAGrL,2BAA2B,CAAC,IAAD,EAAO6H,WAAP,CAA3B,CAA+CA,WAA/C,CAA1B,MAA2F,IAA3F,IAAmGwD,sBAAsB,KAAK,KAAK,CAAnI,GAAuI,KAAK,CAA5I,GAAgJ,CAACC,sBAAsB,GAAGD,sBAAsB,CAACK,WAAjD,MAAkE,IAAlE,IAA0EJ,sBAAsB,KAAK,KAAK,CAA1G,GAA8G,KAAK,CAAnH,GAAuH,CAACC,sBAAsB,GAAGD,sBAAsB,CAACK,IAAjD,MAA2D,IAA3D,IAAmEJ,sBAAsB,KAAK,KAAK,CAAnG,GAAuG,KAAK,CAA5G,GAAgH,CAACC,sBAAsB,GAAGD,sBAAsB,CAACJ,QAAD,CAAhD,MAAgE,IAAhE,IAAwEK,sBAAsB,KAAK,KAAK,CAAxG,GAA4G,KAAK,CAAjH,GAAqH,CAACC,sBAAsB,GAAGD,sBAAsB,CAACI,SAAjD,MAAgE,IAAhE,IAAwEH,sBAAsB,KAAK,KAAK,CAAxG,GAA4G,KAAK,CAAjH,GAAqHA,sBAAsB,CAACL,UAAD,CAA9nB;AACD;;AAEDS,EAAAA,UAAU,CAAC9H,IAAD,EAAO+H,GAAP,EAAY;AACpB,UAAMf,KAAK,GAAG,KAAKZ,GAAL,CAASpG,IAAT,CAAd;AACApC,IAAAA,MAAM,CAACoJ,KAAD,EAAQe,GAAG,IAAK,QAAO/H,IAAK,YAA5B,CAAN;AACA,WAAOgH,KAAP;AACD;;AAEDgB,EAAAA,YAAY,CAAChI,IAAD,EAAO;AACjB,WAAO,KAAKoG,GAAL,CAASpG,IAAT,EAAe,IAAf,CAAP;AACD;;AAEDiI,EAAAA,uBAAuB,GAAG;AACxB,WAAOtJ,oBAAoB,CAAC1C,2BAA2B,CAAC,IAAD,EAAO8H,iBAAP,CAA3B,CAAqDA,iBAArD,CAAD,EAA0E,SAA1E,EAAqF9H,2BAA2B,CAAC,IAAD,EAAO+H,eAAP,CAA3B,CAAmDA,eAAnD,CAArF,CAA3B;AACD;;AAEDkE,EAAAA,uBAAuB,GAAG;AACxB,WAAOvJ,oBAAoB,CAAC1C,2BAA2B,CAAC,IAAD,EAAO8H,iBAAP,CAA3B,CAAqDA,iBAArD,CAAD,EAA0E,WAA1E,EAAuF9H,2BAA2B,CAAC,IAAD,EAAO+H,eAAP,CAA3B,CAAmDA,eAAnD,CAAvF,CAA3B;AACD;;AAEDmE,EAAAA,QAAQ,CAACnI,IAAD,EAAO;AACb,WAAO/D,2BAA2B,CAAC,IAAD,EAAOkH,QAAP,CAA3B,CAA4CA,QAA5C,EAAsDiF,GAAtD,CAA0DpI,IAA1D,CAAP;AACD;;AAEDqI,EAAAA,MAAM,CAACrI,IAAD,EAAO;AACX,WAAO/D,2BAA2B,CAAC,IAAD,EAAOmH,YAAP,CAA3B,CAAgDA,YAAhD,EAA8DgF,GAA9D,CAAkEpI,IAAlE,CAAP;AACD;;AAEDsI,EAAAA,OAAO,CAACtI,IAAD,EAAO;AACZ,WAAO,CAAC/D,2BAA2B,CAAC,IAAD,EAAOwH,aAAP,CAA3B,CAAiDA,aAAjD,EAAgE2C,GAAhE,CAAoEpG,IAApE,CAAD,KAA+E,KAAKmI,QAAL,CAAcnI,IAAd,KAAuB,KAAKqI,MAAL,CAAYrI,IAAZ,CAAtG,CAAP;AACD;;AAEDuI,EAAAA,IAAI,CAACC,IAAD,EAAO;AACT,WAAO,KAAKxG,UAAL,CAAgB,WAAhB,EAA6B/F,2BAA2B,CAAC,IAAD,EAAO0H,OAAP,CAA3B,CAA2CA,OAA3C,EAAoD6E,IAApD,CAA7B,CAAP;AACD,GA3RuB,CA6RxB;;;AACAlE,EAAAA,QAAQ,CAACmE,IAAD,EAAOC,IAAP,EAAa;AACnB;AACA,QAAI1K,UAAU,CAACyK,IAAD,CAAd,EAAsB;AACpBxM,MAAAA,2BAA2B,CAAC,IAAD,EAAOkH,QAAP,CAA3B,CAA4CA,QAA5C,EAAsDsD,GAAtD,CAA0DgC,IAAI,CAACzI,IAA/D,EAAqEyI,IAArE;AACD,KAFD,MAEO,IAAIxK,QAAQ,CAACwK,IAAD,CAAZ,EAAoB;AACzB7K,MAAAA,MAAM,CAACI,UAAU,CAAC0K,IAAD,CAAX,EAAmB,MAAO,wCAAuCD,IAAK,gBAAtE,CAAN;AACA7K,MAAAA,MAAM,CAAC6K,IAAI,KAAKC,IAAI,CAACpH,QAAL,EAAV,EAA2B,MAAO,+BAA8BmH,IAAK,QAAOA,IAAK,EAAjF,CAAN;;AAEAxM,MAAAA,2BAA2B,CAAC,IAAD,EAAOkH,QAAP,CAA3B,CAA4CA,QAA5C,EAAsDsD,GAAtD,CAA0DgC,IAA1D,EAAgEC,IAAhE;AACD,KALM,MAKA;AACL,WAAKC,eAAL,CAAqBF,IAArB;AACD;AACF;;AAEDE,EAAAA,eAAe,CAACC,GAAD,EAAM;AACnBpM,IAAAA,MAAM,CAACsK,OAAP,CAAe8B,GAAf,EAAoBrL,OAApB,CAA4B,CAAC,CAACyC,IAAD,EAAOS,IAAP,CAAD,KAAkB;AAC5C,UAAIzC,UAAU,CAACyC,IAAD,CAAd,EAAsB;AACpB;AACAxE,QAAAA,2BAA2B,CAAC,IAAD,EAAOkH,QAAP,CAA3B,CAA4CA,QAA5C,EAAsDsD,GAAtD,CAA0DzG,IAA1D,EAAgES,IAAhE;AACD,OAHD,MAGO;AACL,cAAMC,GAAG,GAAGzC,QAAQ,CAACwC,IAAD,CAAR,GAAiBA,IAAjB,GAAwBpC,SAAS,CAACoC,IAAD,CAA7C;AACA7C,QAAAA,MAAM,CAACoC,IAAI,KAAKU,GAAV,EAAe,MAAO,+BAA8BV,IAAK,QAAOU,GAAI,EAApE,CAAN,CAFK,CAEyE;;AAE9E,YAAIzE,2BAA2B,CAAC,IAAD,EAAOkH,QAAP,CAA3B,CAA4CA,QAA5C,EAAsDiF,GAAtD,CAA0DpI,IAA1D,CAAJ,EAAqE;AACnE/D,UAAAA,2BAA2B,CAAC,IAAD,EAAOkH,QAAP,CAA3B,CAA4CA,QAA5C,EAAsD0F,MAAtD,CAA6D7I,IAA7D;AACD;;AAED/D,QAAAA,2BAA2B,CAAC,IAAD,EAAOmH,YAAP,CAA3B,CAAgDA,YAAhD,EAA8DqD,GAA9D,CAAkEzG,IAAlE,EAAwEU,GAAxE;AACD;AACF,KAdD;AAeD,GA5TuB,CA4TtB;;;AAGFoI,EAAAA,kBAAkB,CAACC,UAAD,EAAa;AAC7B,QAAIA,UAAJ,EAAgB;AACd9M,MAAAA,2BAA2B,CAAC,IAAD,EAAOyH,gBAAP,CAA3B,CAAoDA,gBAApD,IAAwEqF,UAAxE;AACD;AACF;;AAEDC,EAAAA,SAAS,CAACC,MAAD,EAAS;AAChBhN,IAAAA,2BAA2B,CAAC,IAAD,EAAO0H,OAAP,CAA3B,CAA2CA,OAA3C,IAAsDsF,MAAM,IAAI1K,WAAhE;AACD;;AAED2K,EAAAA,aAAa,CAACzD,UAAD,EAAa;AACxBxJ,IAAAA,2BAA2B,CAAC,IAAD,EAAO6H,WAAP,CAA3B,CAA+CA,WAA/C,IAA8D2B,UAA9D;AACD,GA3UuB,CA2UtB;;;AAGF0D,EAAAA,WAAW,CAAC1J,QAAD,EAAWkG,gBAAX,EAA6ByD,cAA7B,EAA6C;AACtDnN,IAAAA,2BAA2B,CAAC,IAAD,EAAOoH,SAAP,CAA3B,CAA6CA,SAA7C,IAA0D5D,QAAQ,CAACI,QAAnE;AACAsC,IAAAA,gBAAgB,CAAC,IAAD,EAAO1C,QAAP,EAAiBxD,2BAA2B,CAAC,IAAD,EAAOqH,cAAP,CAA3B,CAAkDA,cAAlD,CAAjB,CAAhB;AACA/D,IAAAA,YAAY,CAAC,IAAD,EAAOE,QAAP,EAAiBxD,2BAA2B,CAAC,IAAD,EAAOsH,eAAP,CAA3B,CAAmDA,eAAnD,CAAjB,CAAZ;AACA9B,IAAAA,YAAY,CAAC,IAAD,EAAOhC,QAAP,EAAiBxD,2BAA2B,CAAC,IAAD,EAAOuH,eAAP,CAA3B,CAAmDA,eAAnD,CAAjB,CAAZ,CAJsD,CAI6C;;AAEnG,SAAK6F,mBAAL,CAAyB1D,gBAAgB,KAAKlG,QAAQ,CAACI,QAAT,CAAkByJ,SAAlB,CAA4BlJ,OAA5B,CAAoCmJ,EAApC,CAAuCzL,OAAvC,EAAgD;AAAhD,MAC5C2B,QAAQ,CAACI,QAAT,CAAkByJ,SAAlB,CAA4B3D,gBAA5B,CAA6CxE,GAA7C,CAAiD,CAAC;AAClDqI,MAAAA;AADkD,KAAD,KAE7CA,UAAU,CAAClI,QAAX,EAFJ,CAD4C,GAGf1C,kBAHU,CAAzC,EAGoDwK,cAHpD,EANsD,CASe;;AAErE,SAAKN,kBAAL,CAAwBrG,iBAAiB,CAAC,IAAD,EAAOhD,QAAP,CAAzC;AACD,GA1VuB,CA0VtB;;;AAGF4J,EAAAA,mBAAmB,CAAC1D,gBAAgB,GAAG/G,kBAApB,EAAwCwK,cAAxC,EAAwD;AACzEnN,IAAAA,2BAA2B,CAAC,IAAD,EAAO8H,iBAAP,CAA3B,CAAqDA,iBAArD,IAA0E4B,gBAA1E;AACA1J,IAAAA,2BAA2B,CAAC,IAAD,EAAO+H,eAAP,CAA3B,CAAmDA,eAAnD,IAAsEoF,cAAtE;AACA,UAAMK,OAAO,GAAG5K,qBAAqB,CAAC5C,2BAA2B,CAAC,IAAD,EAAO8H,iBAAP,CAA3B,CAAqDA,iBAArD,CAAD,EAA0E9H,2BAA2B,CAAC,IAAD,EAAO+H,eAAP,CAA3B,CAAmDA,eAAnD,CAA1E,CAArC;;AAEA,QAAIyF,OAAO,CAACpM,MAAZ,EAAoB;AAClBiC,MAAAA,CAAC,CAACoH,IAAF,CAAQ,6BAA4B+C,OAAO,CAACC,IAAR,CAAa,IAAb,CAAmB,oCAAvD;AACD;AACF;;AArWuB","sourcesContent":["import _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, assertReturn, BN_ZERO, formatBalance, isFunction, isString, isU8a, logger, stringCamelCase, stringify, u8aToHex } from '@polkadot/util';\nimport { blake2AsU8a } from '@polkadot/util-crypto';\nimport { DoNotConstruct } from \"../codec/DoNotConstruct.js\";\nimport { Json } from \"../codec/Json.js\";\nimport { Raw } from \"../codec/Raw.js\";\nimport { expandExtensionTypes, fallbackExtensions, findUnknownExtensions } from \"../extrinsic/signedExtensions/index.js\";\nimport { GenericEventData } from \"../generic/Event.js\";\nimport * as baseTypes from \"../index.types.js\";\nimport * as definitions from \"../interfaces/definitions.js\";\nimport { decorateConstants, decorateExtrinsics } from \"../metadata/decorate/index.js\";\nimport { Metadata } from \"../metadata/Metadata.js\";\nimport { createClass } from \"./createClass.js\";\nimport { createTypeUnsafe } from \"./createType.js\";\nconst l = logger('registry'); // create error mapping from metadata\n\nfunction injectErrors(_, metadata, metadataErrors) {\n  const {\n    lookup,\n    pallets\n  } = metadata.asLatest; // decorate the errors\n\n  pallets.forEach(({\n    errors,\n    index,\n    name\n  }, _sectionIndex) => {\n    if (errors.isNone) {\n      return;\n    }\n\n    const sectionIndex = metadata.version >= 12 ? index.toNumber() : _sectionIndex;\n    const sectionName = stringCamelCase(name);\n    lookup.getSiType(errors.unwrap().type).def.asVariant.variants.forEach(({\n      docs,\n      fields,\n      index,\n      name\n    }) => {\n      const variantIndex = index.toNumber();\n      const eventIndex = new Uint8Array([sectionIndex, variantIndex]);\n      metadataErrors[u8aToHex(eventIndex)] = {\n        args: fields.map(({\n          type\n        }) => lookup.getTypeDef(type).type),\n        docs: docs.map(d => d.toString()),\n        fields,\n        index: variantIndex,\n        method: name.toString(),\n        name: name.toString(),\n        section: sectionName\n      };\n    });\n  });\n} // create event classes from metadata\n\n\nfunction injectEvents(registry, metadata, metadataEvents) {\n  const {\n    lookup,\n    pallets\n  } = metadata.asLatest; // decorate the events\n\n  pallets.filter(({\n    events\n  }) => events.isSome).forEach(({\n    events,\n    index,\n    name\n  }, _sectionIndex) => {\n    const sectionIndex = metadata.version >= 12 ? index.toNumber() : _sectionIndex;\n    const sectionName = stringCamelCase(name);\n    lookup.getSiType(events.unwrap().type).def.asVariant.variants.forEach(variant => {\n      const variantIndex = variant.index.toNumber();\n      const eventIndex = new Uint8Array([sectionIndex, variantIndex]);\n      const meta = registry.createType('EventMetadataLatest', _objectSpread(_objectSpread({}, variant), {}, {\n        args: variant.fields.map(({\n          type\n        }) => lookup.getTypeDef(type).type)\n      }));\n      metadataEvents[u8aToHex(eventIndex)] = class extends GenericEventData {\n        constructor(registry, value) {\n          super(registry, value, meta, sectionName, variant.name.toString());\n        }\n\n      };\n    });\n  });\n} // create extrinsic mapping from metadata\n\n\nfunction injectExtrinsics(registry, metadata, metadataCalls) {\n  const extrinsics = decorateExtrinsics(registry, metadata.asLatest, metadata.version); // decorate the extrinsics\n\n  Object.values(extrinsics).forEach(methods => Object.values(methods).forEach(method => {\n    metadataCalls[u8aToHex(method.callIndex)] = method;\n  }));\n} // extract additional properties from the metadata\n\n\nfunction extractProperties(registry, metadata) {\n  var _constants$system;\n\n  const original = registry.getChainProperties();\n  const constants = decorateConstants(registry, metadata.asLatest, metadata.version);\n  const ss58Format = (_constants$system = constants.system) === null || _constants$system === void 0 ? void 0 : _constants$system.ss58Prefix;\n\n  if (!ss58Format) {\n    return original;\n  }\n\n  const {\n    tokenDecimals,\n    tokenSymbol\n  } = original || {};\n  return registry.createType('ChainProperties', {\n    ss58Format,\n    tokenDecimals,\n    tokenSymbol\n  });\n}\n\nvar _classes = /*#__PURE__*/_classPrivateFieldLooseKey(\"classes\");\n\nvar _definitions = /*#__PURE__*/_classPrivateFieldLooseKey(\"definitions\");\n\nvar _metadata = /*#__PURE__*/_classPrivateFieldLooseKey(\"metadata\");\n\nvar _metadataCalls = /*#__PURE__*/_classPrivateFieldLooseKey(\"metadataCalls\");\n\nvar _metadataErrors = /*#__PURE__*/_classPrivateFieldLooseKey(\"metadataErrors\");\n\nvar _metadataEvents = /*#__PURE__*/_classPrivateFieldLooseKey(\"metadataEvents\");\n\nvar _unknownTypes = /*#__PURE__*/_classPrivateFieldLooseKey(\"unknownTypes\");\n\nvar _chainProperties = /*#__PURE__*/_classPrivateFieldLooseKey(\"chainProperties\");\n\nvar _hasher = /*#__PURE__*/_classPrivateFieldLooseKey(\"hasher\");\n\nvar _knownDefaults = /*#__PURE__*/_classPrivateFieldLooseKey(\"knownDefaults\");\n\nvar _knownDefinitions = /*#__PURE__*/_classPrivateFieldLooseKey(\"knownDefinitions\");\n\nvar _knownTypes = /*#__PURE__*/_classPrivateFieldLooseKey(\"knownTypes\");\n\nvar _signedExtensions = /*#__PURE__*/_classPrivateFieldLooseKey(\"signedExtensions\");\n\nvar _userExtensions = /*#__PURE__*/_classPrivateFieldLooseKey(\"userExtensions\");\n\nexport class TypeRegistry {\n  constructor(createdAtHash) {\n    Object.defineProperty(this, _classes, {\n      writable: true,\n      value: new Map()\n    });\n    Object.defineProperty(this, _definitions, {\n      writable: true,\n      value: new Map()\n    });\n    Object.defineProperty(this, _metadata, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _metadataCalls, {\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, _metadataErrors, {\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, _metadataEvents, {\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, _unknownTypes, {\n      writable: true,\n      value: new Map()\n    });\n    Object.defineProperty(this, _chainProperties, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _hasher, {\n      writable: true,\n      value: blake2AsU8a\n    });\n    Object.defineProperty(this, _knownDefaults, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _knownDefinitions, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _knownTypes, {\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, _signedExtensions, {\n      writable: true,\n      value: fallbackExtensions\n    });\n    Object.defineProperty(this, _userExtensions, {\n      writable: true,\n      value: void 0\n    });\n    this.createdAtHash = void 0;\n    _classPrivateFieldLooseBase(this, _knownDefaults)[_knownDefaults] = _objectSpread({\n      Json,\n      Metadata,\n      Raw\n    }, baseTypes);\n    _classPrivateFieldLooseBase(this, _knownDefinitions)[_knownDefinitions] = definitions;\n    this.init();\n\n    if (createdAtHash) {\n      this.createdAtHash = this.createType('Hash', createdAtHash);\n    }\n  }\n\n  init() {\n    // start clean\n    _classPrivateFieldLooseBase(this, _classes)[_classes] = new Map();\n    _classPrivateFieldLooseBase(this, _definitions)[_definitions] = new Map();\n    _classPrivateFieldLooseBase(this, _unknownTypes)[_unknownTypes] = new Map();\n    _classPrivateFieldLooseBase(this, _knownTypes)[_knownTypes] = {}; // register know, first classes then on-demand-created definitions\n\n    this.register(_classPrivateFieldLooseBase(this, _knownDefaults)[_knownDefaults]);\n    Object.values(_classPrivateFieldLooseBase(this, _knownDefinitions)[_knownDefinitions]).forEach(({\n      types\n    }) => this.register(types));\n    return this;\n  }\n\n  get chainDecimals() {\n    var _classPrivateFieldLoo;\n\n    if ((_classPrivateFieldLoo = _classPrivateFieldLooseBase(this, _chainProperties)[_chainProperties]) !== null && _classPrivateFieldLoo !== void 0 && _classPrivateFieldLoo.tokenDecimals.isSome) {\n      const allDecimals = _classPrivateFieldLooseBase(this, _chainProperties)[_chainProperties].tokenDecimals.unwrap();\n\n      if (allDecimals.length) {\n        return allDecimals.map(b => b.toNumber());\n      }\n    }\n\n    return [12];\n  }\n\n  get chainSS58() {\n    var _classPrivateFieldLoo2;\n\n    return (_classPrivateFieldLoo2 = _classPrivateFieldLooseBase(this, _chainProperties)[_chainProperties]) !== null && _classPrivateFieldLoo2 !== void 0 && _classPrivateFieldLoo2.ss58Format.isSome ? _classPrivateFieldLooseBase(this, _chainProperties)[_chainProperties].ss58Format.unwrap().toNumber() : undefined;\n  }\n\n  get chainTokens() {\n    var _classPrivateFieldLoo3;\n\n    if ((_classPrivateFieldLoo3 = _classPrivateFieldLooseBase(this, _chainProperties)[_chainProperties]) !== null && _classPrivateFieldLoo3 !== void 0 && _classPrivateFieldLoo3.tokenSymbol.isSome) {\n      const allTokens = _classPrivateFieldLooseBase(this, _chainProperties)[_chainProperties].tokenSymbol.unwrap();\n\n      if (allTokens.length) {\n        return allTokens.map(s => s.toString());\n      }\n    }\n\n    return [formatBalance.getDefaults().unit];\n  }\n  /**\n   * @description Returns tru if the type is in a Compat format\n   */\n\n\n  isLookupType(value) {\n    return /Lookup\\d+$/.test(value);\n  }\n  /**\n   * @description Creates a lookup string from the supplied id\n   */\n\n\n  createLookupType(lookupId) {\n    return `Lookup${lookupId.toString()}`;\n  }\n\n  get knownTypes() {\n    return _classPrivateFieldLooseBase(this, _knownTypes)[_knownTypes];\n  }\n\n  get lookup() {\n    return this.metadata.lookup;\n  }\n\n  get metadata() {\n    assert(_classPrivateFieldLooseBase(this, _metadata)[_metadata], 'Metadata has not been set on this registry');\n    return _classPrivateFieldLooseBase(this, _metadata)[_metadata];\n  }\n\n  get unknownTypes() {\n    return [..._classPrivateFieldLooseBase(this, _unknownTypes)[_unknownTypes].keys()];\n  }\n\n  get signedExtensions() {\n    return _classPrivateFieldLooseBase(this, _signedExtensions)[_signedExtensions];\n  }\n  /**\n   * @describe Creates an instance of the class\n   */\n\n\n  createClass(type) {\n    return createClass(this, type);\n  }\n  /**\n   * @description Creates an instance of a type as registered\n   */\n\n\n  createType(type, ...params) {\n    return this.createTypeUnsafe(type, params);\n  }\n  /**\n   * @description Creates an instance of a type as registered\n   */\n\n\n  createTypeUnsafe(type, params, options) {\n    return createTypeUnsafe(this, type, params, options);\n  } // find a specific call\n\n\n  findMetaCall(callIndex) {\n    const hexIndex = u8aToHex(callIndex);\n    return assertReturn(_classPrivateFieldLooseBase(this, _metadataCalls)[_metadataCalls][hexIndex], `findMetaCall: Unable to find Call with index ${hexIndex}/[${callIndex.toString()}]`);\n  } // finds an error\n\n\n  findMetaError(errorIndex) {\n    const hexIndex = u8aToHex(isU8a(errorIndex) ? errorIndex : new Uint8Array([errorIndex.index.toNumber(), errorIndex.error.toNumber()]));\n    return assertReturn(_classPrivateFieldLooseBase(this, _metadataErrors)[_metadataErrors][hexIndex], `findMetaError: Unable to find Error with index ${hexIndex}/[${errorIndex.toString()}]`);\n  }\n\n  findMetaEvent(eventIndex) {\n    const hexIndex = u8aToHex(eventIndex);\n    return assertReturn(_classPrivateFieldLooseBase(this, _metadataEvents)[_metadataEvents][hexIndex], `findMetaEvent: Unable to find Event with index ${hexIndex}/[${eventIndex.toString()}]`);\n  }\n\n  get(name, withUnknown) {\n    let Type = _classPrivateFieldLooseBase(this, _classes)[_classes].get(name); // we have not already created the type, attempt it\n\n\n    if (!Type) {\n      const definition = _classPrivateFieldLooseBase(this, _definitions)[_definitions].get(name);\n\n      let BaseType; // we have a definition, so create the class now (lazily)\n\n      if (definition) {\n        BaseType = createClass(this, definition);\n\n        _classPrivateFieldLooseBase(this, _classes)[_classes].set(name, BaseType);\n      } else if (withUnknown) {\n        l.warn(`Unable to resolve type ${name}, it will fail on construction`);\n\n        _classPrivateFieldLooseBase(this, _unknownTypes)[_unknownTypes].set(name, true);\n\n        BaseType = DoNotConstruct.with(name);\n      }\n\n      if (BaseType) {\n        // NOTE If we didn't extend here, we would have strange artifacts. An example is\n        // Balance, with this, new Balance() instanceof u128 is true, but Balance !== u128\n        // Additionally, we now pass through the registry, which is a link to ourselves\n        Type = class extends BaseType {};\n\n        _classPrivateFieldLooseBase(this, _classes)[_classes].set(name, Type);\n      }\n    }\n\n    return Type;\n  }\n\n  getChainProperties() {\n    return _classPrivateFieldLooseBase(this, _chainProperties)[_chainProperties];\n  }\n\n  getClassName(Type) {\n    const entry = [..._classPrivateFieldLooseBase(this, _classes)[_classes].entries()].find(([, Clazz]) => Type === Clazz);\n    return entry ? entry[0] : undefined;\n  }\n\n  getDefinition(typeName) {\n    return _classPrivateFieldLooseBase(this, _definitions)[_definitions].get(typeName);\n  }\n\n  getModuleInstances(specName, moduleName) {\n    var _classPrivateFieldLoo4, _classPrivateFieldLoo5, _classPrivateFieldLoo6, _classPrivateFieldLoo7, _classPrivateFieldLoo8;\n\n    return (_classPrivateFieldLoo4 = _classPrivateFieldLooseBase(this, _knownTypes)[_knownTypes]) === null || _classPrivateFieldLoo4 === void 0 ? void 0 : (_classPrivateFieldLoo5 = _classPrivateFieldLoo4.typesBundle) === null || _classPrivateFieldLoo5 === void 0 ? void 0 : (_classPrivateFieldLoo6 = _classPrivateFieldLoo5.spec) === null || _classPrivateFieldLoo6 === void 0 ? void 0 : (_classPrivateFieldLoo7 = _classPrivateFieldLoo6[specName]) === null || _classPrivateFieldLoo7 === void 0 ? void 0 : (_classPrivateFieldLoo8 = _classPrivateFieldLoo7.instances) === null || _classPrivateFieldLoo8 === void 0 ? void 0 : _classPrivateFieldLoo8[moduleName];\n  }\n\n  getOrThrow(name, msg) {\n    const Clazz = this.get(name);\n    assert(Clazz, msg || `type ${name} not found`);\n    return Clazz;\n  }\n\n  getOrUnknown(name) {\n    return this.get(name, true);\n  }\n\n  getSignedExtensionExtra() {\n    return expandExtensionTypes(_classPrivateFieldLooseBase(this, _signedExtensions)[_signedExtensions], 'payload', _classPrivateFieldLooseBase(this, _userExtensions)[_userExtensions]);\n  }\n\n  getSignedExtensionTypes() {\n    return expandExtensionTypes(_classPrivateFieldLooseBase(this, _signedExtensions)[_signedExtensions], 'extrinsic', _classPrivateFieldLooseBase(this, _userExtensions)[_userExtensions]);\n  }\n\n  hasClass(name) {\n    return _classPrivateFieldLooseBase(this, _classes)[_classes].has(name);\n  }\n\n  hasDef(name) {\n    return _classPrivateFieldLooseBase(this, _definitions)[_definitions].has(name);\n  }\n\n  hasType(name) {\n    return !_classPrivateFieldLooseBase(this, _unknownTypes)[_unknownTypes].get(name) && (this.hasClass(name) || this.hasDef(name));\n  }\n\n  hash(data) {\n    return this.createType('CodecHash', _classPrivateFieldLooseBase(this, _hasher)[_hasher](data));\n  }\n\n  // eslint-disable-next-line no-dupe-class-members\n  register(arg1, arg2) {\n    // NOTE Constructors appear as functions here\n    if (isFunction(arg1)) {\n      _classPrivateFieldLooseBase(this, _classes)[_classes].set(arg1.name, arg1);\n    } else if (isString(arg1)) {\n      assert(isFunction(arg2), () => `Expected class definition passed to '${arg1}' registration`);\n      assert(arg1 !== arg2.toString(), () => `Unable to register circular ${arg1} === ${arg1}`);\n\n      _classPrivateFieldLooseBase(this, _classes)[_classes].set(arg1, arg2);\n    } else {\n      this._registerObject(arg1);\n    }\n  }\n\n  _registerObject(obj) {\n    Object.entries(obj).forEach(([name, type]) => {\n      if (isFunction(type)) {\n        // This _looks_ a bit funny, but `typeof Clazz === 'function'\n        _classPrivateFieldLooseBase(this, _classes)[_classes].set(name, type);\n      } else {\n        const def = isString(type) ? type : stringify(type);\n        assert(name !== def, () => `Unable to register circular ${name} === ${def}`); // we already have this type, remove the classes registered for it\n\n        if (_classPrivateFieldLooseBase(this, _classes)[_classes].has(name)) {\n          _classPrivateFieldLooseBase(this, _classes)[_classes].delete(name);\n        }\n\n        _classPrivateFieldLooseBase(this, _definitions)[_definitions].set(name, def);\n      }\n    });\n  } // sets the chain properties\n\n\n  setChainProperties(properties) {\n    if (properties) {\n      _classPrivateFieldLooseBase(this, _chainProperties)[_chainProperties] = properties;\n    }\n  }\n\n  setHasher(hasher) {\n    _classPrivateFieldLooseBase(this, _hasher)[_hasher] = hasher || blake2AsU8a;\n  }\n\n  setKnownTypes(knownTypes) {\n    _classPrivateFieldLooseBase(this, _knownTypes)[_knownTypes] = knownTypes;\n  } // sets the metadata\n\n\n  setMetadata(metadata, signedExtensions, userExtensions) {\n    _classPrivateFieldLooseBase(this, _metadata)[_metadata] = metadata.asLatest;\n    injectExtrinsics(this, metadata, _classPrivateFieldLooseBase(this, _metadataCalls)[_metadataCalls]);\n    injectErrors(this, metadata, _classPrivateFieldLooseBase(this, _metadataErrors)[_metadataErrors]);\n    injectEvents(this, metadata, _classPrivateFieldLooseBase(this, _metadataEvents)[_metadataEvents]); // setup the available extensions\n\n    this.setSignedExtensions(signedExtensions || (metadata.asLatest.extrinsic.version.gt(BN_ZERO) // FIXME Use the extension and their injected types\n    ? metadata.asLatest.extrinsic.signedExtensions.map(({\n      identifier\n    }) => identifier.toString()) : fallbackExtensions), userExtensions); // setup the chain properties with format overrides\n\n    this.setChainProperties(extractProperties(this, metadata));\n  } // sets the available signed extensions\n\n\n  setSignedExtensions(signedExtensions = fallbackExtensions, userExtensions) {\n    _classPrivateFieldLooseBase(this, _signedExtensions)[_signedExtensions] = signedExtensions;\n    _classPrivateFieldLooseBase(this, _userExtensions)[_userExtensions] = userExtensions;\n    const unknown = findUnknownExtensions(_classPrivateFieldLooseBase(this, _signedExtensions)[_signedExtensions], _classPrivateFieldLooseBase(this, _userExtensions)[_userExtensions]);\n\n    if (unknown.length) {\n      l.warn(`Unknown signed extensions ${unknown.join(', ')} found, treating them as no-effect`);\n    }\n  }\n\n}"]},"metadata":{},"sourceType":"module"}