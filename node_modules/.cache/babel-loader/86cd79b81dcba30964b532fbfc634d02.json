{"ast":null,"code":"// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isFunction, isString, isU8a } from '@polkadot/util';\nimport { getSiName } from \"../metadata/util/index.js\";\nimport { Bytes } from \"./Bytes.js\"; // hasher type -> [initialHashLength, canDecodeKey]\n\nconst HASHER_MAP = {\n  // opaque\n  Blake2_128: [16, false],\n  // eslint-disable-line camelcase\n  Blake2_128Concat: [16, true],\n  // eslint-disable-line camelcase\n  Blake2_256: [32, false],\n  // eslint-disable-line camelcase\n  Identity: [0, true],\n  Twox128: [16, false],\n  Twox256: [32, false],\n  Twox64Concat: [8, true]\n};\nexport function unwrapStorageSi(type) {\n  return type.isPlain ? type.asPlain : type.asMap.value;\n}\n/** @internal */\n\nexport function unwrapStorageType(registry, type, isOptional) {\n  const outputType = getSiName(registry.lookup, unwrapStorageSi(type));\n  return isOptional ? `Option<${outputType}>` : outputType;\n}\n/** @internal */\n\nfunction decodeStorageKey(value) {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  if (value instanceof StorageKey) {\n    return {\n      key: value,\n      method: value.method,\n      section: value.section\n    };\n  } else if (!value || isString(value) || isU8a(value)) {\n    // let Bytes handle these inputs\n    return {\n      key: value\n    };\n  } else if (isFunction(value)) {\n    return {\n      key: value(),\n      method: value.method,\n      section: value.section\n    };\n  } else if (Array.isArray(value)) {\n    const [fn, args = []] = value;\n    assert(isFunction(fn), 'Expected function input for key construction');\n    return {\n      key: fn(...args),\n      method: fn.method,\n      section: fn.section\n    };\n  }\n\n  throw new Error(`Unable to convert input ${value} to StorageKey`);\n}\n/** @internal */\n\n\nfunction decodeHashers(registry, value, hashers) {\n  // the storage entry is xxhashAsU8a(prefix, 128) + xxhashAsU8a(method, 128), 256 bits total\n  let offset = 32;\n  return hashers.reduce((result, [hasher, type]) => {\n    const [hashLen, canDecode] = HASHER_MAP[hasher.type];\n    const decoded = canDecode ? registry.createType(registry.createLookupType(type), value.subarray(offset + hashLen)) : registry.createType('Raw', value.subarray(offset, offset + hashLen));\n    offset += hashLen + (canDecode ? decoded.encodedLength : 0);\n    result.push(decoded);\n    return result;\n  }, []);\n}\n/** @internal */\n\n\nfunction decodeArgsFromMeta(registry, value, meta) {\n  if (!meta || !meta.type.isMap) {\n    return [];\n  }\n\n  const {\n    hashers,\n    key\n  } = meta.type.asMap;\n  const keys = hashers.length === 1 ? [key] : registry.lookup.getSiType(key).def.asTuple;\n  return decodeHashers(registry, value, hashers.map((h, i) => [h, keys[i]]));\n}\n/** @internal */\n\n\nfunction getMeta(value) {\n  if (value instanceof StorageKey) {\n    return value.meta;\n  } else if (isFunction(value)) {\n    return value.meta;\n  } else if (Array.isArray(value)) {\n    const [fn] = value;\n    return fn.meta;\n  }\n\n  return undefined;\n}\n/** @internal */\n\n\nfunction getType(registry, value) {\n  if (value instanceof StorageKey) {\n    return value.outputType;\n  } else if (isFunction(value)) {\n    return unwrapStorageType(registry, value.meta.type);\n  } else if (Array.isArray(value)) {\n    const [fn] = value;\n\n    if (fn.meta) {\n      return unwrapStorageType(registry, fn.meta.type);\n    }\n  } // If we have no type set, default to Raw\n\n\n  return 'Raw';\n}\n/**\n * @name StorageKey\n * @description\n * A representation of a storage key (typically hashed) in the system. It can be\n * constructed by passing in a raw key or a StorageEntry with (optional) arguments.\n */\n\n\nexport class StorageKey extends Bytes {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore This is assigned via this.decodeArgsFromMeta()\n  constructor(registry, value, override = {}) {\n    const {\n      key,\n      method,\n      section\n    } = decodeStorageKey(value);\n    super(registry, key);\n    this._args = void 0;\n    this._meta = void 0;\n    this._outputType = void 0;\n    this._method = void 0;\n    this._section = void 0;\n    this._outputType = getType(registry, value); // decode the args (as applicable based on the key and the hashers, after all init)\n\n    this.setMeta(getMeta(value), override.section || section, override.method || method);\n  }\n  /**\n   * @description Return the decoded arguments (applicable to map with decodable values)\n   */\n\n\n  get args() {\n    return this._args;\n  }\n  /**\n   * @description The metadata or `undefined` when not available\n   */\n\n\n  get meta() {\n    return this._meta;\n  }\n  /**\n   * @description The key method or `undefined` when not specified\n   */\n\n\n  get method() {\n    return this._method;\n  }\n  /**\n   * @description The output type\n   */\n\n\n  get outputType() {\n    return this._outputType;\n  }\n  /**\n   * @description The key section or `undefined` when not specified\n   */\n\n\n  get section() {\n    return this._section;\n  }\n\n  is(key) {\n    return key.section === this.section && key.method === this.method;\n  }\n  /**\n   * @description Sets the meta for this key\n   */\n\n\n  setMeta(meta, section, method) {\n    this._meta = meta;\n    this._method = method || this._method;\n    this._section = section || this._section;\n\n    if (meta) {\n      this._outputType = unwrapStorageType(this.registry, meta.type);\n    }\n\n    try {\n      this._args = decodeArgsFromMeta(this.registry, this.toU8a(true), this.meta);\n    } catch (error) {// ignore...\n    }\n\n    return this;\n  }\n  /**\n   * @description Returns the Human representation for this type\n   */\n\n\n  toHuman() {\n    return this._args.length ? this._args.map(arg => arg.toHuman()) : super.toHuman();\n  }\n  /**\n   * @description Returns the raw type for this\n   */\n\n\n  toRawType() {\n    return 'StorageKey';\n  }\n\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/types/primitive/StorageKey.js"],"names":["assert","isFunction","isString","isU8a","getSiName","Bytes","HASHER_MAP","Blake2_128","Blake2_128Concat","Blake2_256","Identity","Twox128","Twox256","Twox64Concat","unwrapStorageSi","type","isPlain","asPlain","asMap","value","unwrapStorageType","registry","isOptional","outputType","lookup","decodeStorageKey","StorageKey","key","method","section","Array","isArray","fn","args","Error","decodeHashers","hashers","offset","reduce","result","hasher","hashLen","canDecode","decoded","createType","createLookupType","subarray","encodedLength","push","decodeArgsFromMeta","meta","isMap","keys","length","getSiType","def","asTuple","map","h","i","getMeta","undefined","getType","constructor","override","_args","_meta","_outputType","_method","_section","setMeta","is","toU8a","error","toHuman","arg","toRawType"],"mappings":"AAAA;AACA;AACA,SAASA,MAAT,EAAiBC,UAAjB,EAA6BC,QAA7B,EAAuCC,KAAvC,QAAoD,gBAApD;AACA,SAASC,SAAT,QAA0B,2BAA1B;AACA,SAASC,KAAT,QAAsB,YAAtB,C,CACA;;AACA,MAAMC,UAAU,GAAG;AACjB;AACAC,EAAAA,UAAU,EAAE,CAAC,EAAD,EAAK,KAAL,CAFK;AAGjB;AACAC,EAAAA,gBAAgB,EAAE,CAAC,EAAD,EAAK,IAAL,CAJD;AAKjB;AACAC,EAAAA,UAAU,EAAE,CAAC,EAAD,EAAK,KAAL,CANK;AAOjB;AACAC,EAAAA,QAAQ,EAAE,CAAC,CAAD,EAAI,IAAJ,CARO;AASjBC,EAAAA,OAAO,EAAE,CAAC,EAAD,EAAK,KAAL,CATQ;AAUjBC,EAAAA,OAAO,EAAE,CAAC,EAAD,EAAK,KAAL,CAVQ;AAWjBC,EAAAA,YAAY,EAAE,CAAC,CAAD,EAAI,IAAJ;AAXG,CAAnB;AAaA,OAAO,SAASC,eAAT,CAAyBC,IAAzB,EAA+B;AACpC,SAAOA,IAAI,CAACC,OAAL,GAAeD,IAAI,CAACE,OAApB,GAA8BF,IAAI,CAACG,KAAL,CAAWC,KAAhD;AACD;AACD;;AAEA,OAAO,SAASC,iBAAT,CAA2BC,QAA3B,EAAqCN,IAArC,EAA2CO,UAA3C,EAAuD;AAC5D,QAAMC,UAAU,GAAGnB,SAAS,CAACiB,QAAQ,CAACG,MAAV,EAAkBV,eAAe,CAACC,IAAD,CAAjC,CAA5B;AACA,SAAOO,UAAU,GAAI,UAASC,UAAW,GAAxB,GAA6BA,UAA9C;AACD;AACD;;AAEA,SAASE,gBAAT,CAA0BN,KAA1B,EAAiC;AAC/B;AACA,MAAIA,KAAK,YAAYO,UAArB,EAAiC;AAC/B,WAAO;AACLC,MAAAA,GAAG,EAAER,KADA;AAELS,MAAAA,MAAM,EAAET,KAAK,CAACS,MAFT;AAGLC,MAAAA,OAAO,EAAEV,KAAK,CAACU;AAHV,KAAP;AAKD,GAND,MAMO,IAAI,CAACV,KAAD,IAAUjB,QAAQ,CAACiB,KAAD,CAAlB,IAA6BhB,KAAK,CAACgB,KAAD,CAAtC,EAA+C;AACpD;AACA,WAAO;AACLQ,MAAAA,GAAG,EAAER;AADA,KAAP;AAGD,GALM,MAKA,IAAIlB,UAAU,CAACkB,KAAD,CAAd,EAAuB;AAC5B,WAAO;AACLQ,MAAAA,GAAG,EAAER,KAAK,EADL;AAELS,MAAAA,MAAM,EAAET,KAAK,CAACS,MAFT;AAGLC,MAAAA,OAAO,EAAEV,KAAK,CAACU;AAHV,KAAP;AAKD,GANM,MAMA,IAAIC,KAAK,CAACC,OAAN,CAAcZ,KAAd,CAAJ,EAA0B;AAC/B,UAAM,CAACa,EAAD,EAAKC,IAAI,GAAG,EAAZ,IAAkBd,KAAxB;AACAnB,IAAAA,MAAM,CAACC,UAAU,CAAC+B,EAAD,CAAX,EAAiB,8CAAjB,CAAN;AACA,WAAO;AACLL,MAAAA,GAAG,EAAEK,EAAE,CAAC,GAAGC,IAAJ,CADF;AAELL,MAAAA,MAAM,EAAEI,EAAE,CAACJ,MAFN;AAGLC,MAAAA,OAAO,EAAEG,EAAE,CAACH;AAHP,KAAP;AAKD;;AAED,QAAM,IAAIK,KAAJ,CAAW,2BAA0Bf,KAAM,gBAA3C,CAAN;AACD;AACD;;;AAGA,SAASgB,aAAT,CAAuBd,QAAvB,EAAiCF,KAAjC,EAAwCiB,OAAxC,EAAiD;AAC/C;AACA,MAAIC,MAAM,GAAG,EAAb;AACA,SAAOD,OAAO,CAACE,MAAR,CAAe,CAACC,MAAD,EAAS,CAACC,MAAD,EAASzB,IAAT,CAAT,KAA4B;AAChD,UAAM,CAAC0B,OAAD,EAAUC,SAAV,IAAuBpC,UAAU,CAACkC,MAAM,CAACzB,IAAR,CAAvC;AACA,UAAM4B,OAAO,GAAGD,SAAS,GAAGrB,QAAQ,CAACuB,UAAT,CAAoBvB,QAAQ,CAACwB,gBAAT,CAA0B9B,IAA1B,CAApB,EAAqDI,KAAK,CAAC2B,QAAN,CAAeT,MAAM,GAAGI,OAAxB,CAArD,CAAH,GAA4FpB,QAAQ,CAACuB,UAAT,CAAoB,KAApB,EAA2BzB,KAAK,CAAC2B,QAAN,CAAeT,MAAf,EAAuBA,MAAM,GAAGI,OAAhC,CAA3B,CAArH;AACAJ,IAAAA,MAAM,IAAII,OAAO,IAAIC,SAAS,GAAGC,OAAO,CAACI,aAAX,GAA2B,CAAxC,CAAjB;AACAR,IAAAA,MAAM,CAACS,IAAP,CAAYL,OAAZ;AACA,WAAOJ,MAAP;AACD,GANM,EAMJ,EANI,CAAP;AAOD;AACD;;;AAGA,SAASU,kBAAT,CAA4B5B,QAA5B,EAAsCF,KAAtC,EAA6C+B,IAA7C,EAAmD;AACjD,MAAI,CAACA,IAAD,IAAS,CAACA,IAAI,CAACnC,IAAL,CAAUoC,KAAxB,EAA+B;AAC7B,WAAO,EAAP;AACD;;AAED,QAAM;AACJf,IAAAA,OADI;AAEJT,IAAAA;AAFI,MAGFuB,IAAI,CAACnC,IAAL,CAAUG,KAHd;AAIA,QAAMkC,IAAI,GAAGhB,OAAO,CAACiB,MAAR,KAAmB,CAAnB,GAAuB,CAAC1B,GAAD,CAAvB,GAA+BN,QAAQ,CAACG,MAAT,CAAgB8B,SAAhB,CAA0B3B,GAA1B,EAA+B4B,GAA/B,CAAmCC,OAA/E;AACA,SAAOrB,aAAa,CAACd,QAAD,EAAWF,KAAX,EAAkBiB,OAAO,CAACqB,GAAR,CAAY,CAACC,CAAD,EAAIC,CAAJ,KAAU,CAACD,CAAD,EAAIN,IAAI,CAACO,CAAD,CAAR,CAAtB,CAAlB,CAApB;AACD;AACD;;;AAGA,SAASC,OAAT,CAAiBzC,KAAjB,EAAwB;AACtB,MAAIA,KAAK,YAAYO,UAArB,EAAiC;AAC/B,WAAOP,KAAK,CAAC+B,IAAb;AACD,GAFD,MAEO,IAAIjD,UAAU,CAACkB,KAAD,CAAd,EAAuB;AAC5B,WAAOA,KAAK,CAAC+B,IAAb;AACD,GAFM,MAEA,IAAIpB,KAAK,CAACC,OAAN,CAAcZ,KAAd,CAAJ,EAA0B;AAC/B,UAAM,CAACa,EAAD,IAAOb,KAAb;AACA,WAAOa,EAAE,CAACkB,IAAV;AACD;;AAED,SAAOW,SAAP;AACD;AACD;;;AAGA,SAASC,OAAT,CAAiBzC,QAAjB,EAA2BF,KAA3B,EAAkC;AAChC,MAAIA,KAAK,YAAYO,UAArB,EAAiC;AAC/B,WAAOP,KAAK,CAACI,UAAb;AACD,GAFD,MAEO,IAAItB,UAAU,CAACkB,KAAD,CAAd,EAAuB;AAC5B,WAAOC,iBAAiB,CAACC,QAAD,EAAWF,KAAK,CAAC+B,IAAN,CAAWnC,IAAtB,CAAxB;AACD,GAFM,MAEA,IAAIe,KAAK,CAACC,OAAN,CAAcZ,KAAd,CAAJ,EAA0B;AAC/B,UAAM,CAACa,EAAD,IAAOb,KAAb;;AAEA,QAAIa,EAAE,CAACkB,IAAP,EAAa;AACX,aAAO9B,iBAAiB,CAACC,QAAD,EAAWW,EAAE,CAACkB,IAAH,CAAQnC,IAAnB,CAAxB;AACD;AACF,GAX+B,CAW9B;;;AAGF,SAAO,KAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;;AAGA,OAAO,MAAMW,UAAN,SAAyBrB,KAAzB,CAA+B;AACpC;AACA;AACA0D,EAAAA,WAAW,CAAC1C,QAAD,EAAWF,KAAX,EAAkB6C,QAAQ,GAAG,EAA7B,EAAiC;AAC1C,UAAM;AACJrC,MAAAA,GADI;AAEJC,MAAAA,MAFI;AAGJC,MAAAA;AAHI,QAIFJ,gBAAgB,CAACN,KAAD,CAJpB;AAKA,UAAME,QAAN,EAAgBM,GAAhB;AACA,SAAKsC,KAAL,GAAa,KAAK,CAAlB;AACA,SAAKC,KAAL,GAAa,KAAK,CAAlB;AACA,SAAKC,WAAL,GAAmB,KAAK,CAAxB;AACA,SAAKC,OAAL,GAAe,KAAK,CAApB;AACA,SAAKC,QAAL,GAAgB,KAAK,CAArB;AACA,SAAKF,WAAL,GAAmBL,OAAO,CAACzC,QAAD,EAAWF,KAAX,CAA1B,CAZ0C,CAYG;;AAE7C,SAAKmD,OAAL,CAAaV,OAAO,CAACzC,KAAD,CAApB,EAA6B6C,QAAQ,CAACnC,OAAT,IAAoBA,OAAjD,EAA0DmC,QAAQ,CAACpC,MAAT,IAAmBA,MAA7E;AACD;AACD;AACF;AACA;;;AAGU,MAAJK,IAAI,GAAG;AACT,WAAO,KAAKgC,KAAZ;AACD;AACD;AACF;AACA;;;AAGU,MAAJf,IAAI,GAAG;AACT,WAAO,KAAKgB,KAAZ;AACD;AACD;AACF;AACA;;;AAGY,MAANtC,MAAM,GAAG;AACX,WAAO,KAAKwC,OAAZ;AACD;AACD;AACF;AACA;;;AAGgB,MAAV7C,UAAU,GAAG;AACf,WAAO,KAAK4C,WAAZ;AACD;AACD;AACF;AACA;;;AAGa,MAAPtC,OAAO,GAAG;AACZ,WAAO,KAAKwC,QAAZ;AACD;;AAEDE,EAAAA,EAAE,CAAC5C,GAAD,EAAM;AACN,WAAOA,GAAG,CAACE,OAAJ,KAAgB,KAAKA,OAArB,IAAgCF,GAAG,CAACC,MAAJ,KAAe,KAAKA,MAA3D;AACD;AACD;AACF;AACA;;;AAGE0C,EAAAA,OAAO,CAACpB,IAAD,EAAOrB,OAAP,EAAgBD,MAAhB,EAAwB;AAC7B,SAAKsC,KAAL,GAAahB,IAAb;AACA,SAAKkB,OAAL,GAAexC,MAAM,IAAI,KAAKwC,OAA9B;AACA,SAAKC,QAAL,GAAgBxC,OAAO,IAAI,KAAKwC,QAAhC;;AAEA,QAAInB,IAAJ,EAAU;AACR,WAAKiB,WAAL,GAAmB/C,iBAAiB,CAAC,KAAKC,QAAN,EAAgB6B,IAAI,CAACnC,IAArB,CAApC;AACD;;AAED,QAAI;AACF,WAAKkD,KAAL,GAAahB,kBAAkB,CAAC,KAAK5B,QAAN,EAAgB,KAAKmD,KAAL,CAAW,IAAX,CAAhB,EAAkC,KAAKtB,IAAvC,CAA/B;AACD,KAFD,CAEE,OAAOuB,KAAP,EAAc,CAAC;AAChB;;AAED,WAAO,IAAP;AACD;AACD;AACF;AACA;;;AAGEC,EAAAA,OAAO,GAAG;AACR,WAAO,KAAKT,KAAL,CAAWZ,MAAX,GAAoB,KAAKY,KAAL,CAAWR,GAAX,CAAekB,GAAG,IAAIA,GAAG,CAACD,OAAJ,EAAtB,CAApB,GAA2D,MAAMA,OAAN,EAAlE;AACD;AACD;AACF;AACA;;;AAGEE,EAAAA,SAAS,GAAG;AACV,WAAO,YAAP;AACD;;AAnGmC","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isFunction, isString, isU8a } from '@polkadot/util';\nimport { getSiName } from \"../metadata/util/index.js\";\nimport { Bytes } from \"./Bytes.js\";\n// hasher type -> [initialHashLength, canDecodeKey]\nconst HASHER_MAP = {\n  // opaque\n  Blake2_128: [16, false],\n  // eslint-disable-line camelcase\n  Blake2_128Concat: [16, true],\n  // eslint-disable-line camelcase\n  Blake2_256: [32, false],\n  // eslint-disable-line camelcase\n  Identity: [0, true],\n  Twox128: [16, false],\n  Twox256: [32, false],\n  Twox64Concat: [8, true]\n};\nexport function unwrapStorageSi(type) {\n  return type.isPlain ? type.asPlain : type.asMap.value;\n}\n/** @internal */\n\nexport function unwrapStorageType(registry, type, isOptional) {\n  const outputType = getSiName(registry.lookup, unwrapStorageSi(type));\n  return isOptional ? `Option<${outputType}>` : outputType;\n}\n/** @internal */\n\nfunction decodeStorageKey(value) {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  if (value instanceof StorageKey) {\n    return {\n      key: value,\n      method: value.method,\n      section: value.section\n    };\n  } else if (!value || isString(value) || isU8a(value)) {\n    // let Bytes handle these inputs\n    return {\n      key: value\n    };\n  } else if (isFunction(value)) {\n    return {\n      key: value(),\n      method: value.method,\n      section: value.section\n    };\n  } else if (Array.isArray(value)) {\n    const [fn, args = []] = value;\n    assert(isFunction(fn), 'Expected function input for key construction');\n    return {\n      key: fn(...args),\n      method: fn.method,\n      section: fn.section\n    };\n  }\n\n  throw new Error(`Unable to convert input ${value} to StorageKey`);\n}\n/** @internal */\n\n\nfunction decodeHashers(registry, value, hashers) {\n  // the storage entry is xxhashAsU8a(prefix, 128) + xxhashAsU8a(method, 128), 256 bits total\n  let offset = 32;\n  return hashers.reduce((result, [hasher, type]) => {\n    const [hashLen, canDecode] = HASHER_MAP[hasher.type];\n    const decoded = canDecode ? registry.createType(registry.createLookupType(type), value.subarray(offset + hashLen)) : registry.createType('Raw', value.subarray(offset, offset + hashLen));\n    offset += hashLen + (canDecode ? decoded.encodedLength : 0);\n    result.push(decoded);\n    return result;\n  }, []);\n}\n/** @internal */\n\n\nfunction decodeArgsFromMeta(registry, value, meta) {\n  if (!meta || !meta.type.isMap) {\n    return [];\n  }\n\n  const {\n    hashers,\n    key\n  } = meta.type.asMap;\n  const keys = hashers.length === 1 ? [key] : registry.lookup.getSiType(key).def.asTuple;\n  return decodeHashers(registry, value, hashers.map((h, i) => [h, keys[i]]));\n}\n/** @internal */\n\n\nfunction getMeta(value) {\n  if (value instanceof StorageKey) {\n    return value.meta;\n  } else if (isFunction(value)) {\n    return value.meta;\n  } else if (Array.isArray(value)) {\n    const [fn] = value;\n    return fn.meta;\n  }\n\n  return undefined;\n}\n/** @internal */\n\n\nfunction getType(registry, value) {\n  if (value instanceof StorageKey) {\n    return value.outputType;\n  } else if (isFunction(value)) {\n    return unwrapStorageType(registry, value.meta.type);\n  } else if (Array.isArray(value)) {\n    const [fn] = value;\n\n    if (fn.meta) {\n      return unwrapStorageType(registry, fn.meta.type);\n    }\n  } // If we have no type set, default to Raw\n\n\n  return 'Raw';\n}\n/**\n * @name StorageKey\n * @description\n * A representation of a storage key (typically hashed) in the system. It can be\n * constructed by passing in a raw key or a StorageEntry with (optional) arguments.\n */\n\n\nexport class StorageKey extends Bytes {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore This is assigned via this.decodeArgsFromMeta()\n  constructor(registry, value, override = {}) {\n    const {\n      key,\n      method,\n      section\n    } = decodeStorageKey(value);\n    super(registry, key);\n    this._args = void 0;\n    this._meta = void 0;\n    this._outputType = void 0;\n    this._method = void 0;\n    this._section = void 0;\n    this._outputType = getType(registry, value); // decode the args (as applicable based on the key and the hashers, after all init)\n\n    this.setMeta(getMeta(value), override.section || section, override.method || method);\n  }\n  /**\n   * @description Return the decoded arguments (applicable to map with decodable values)\n   */\n\n\n  get args() {\n    return this._args;\n  }\n  /**\n   * @description The metadata or `undefined` when not available\n   */\n\n\n  get meta() {\n    return this._meta;\n  }\n  /**\n   * @description The key method or `undefined` when not specified\n   */\n\n\n  get method() {\n    return this._method;\n  }\n  /**\n   * @description The output type\n   */\n\n\n  get outputType() {\n    return this._outputType;\n  }\n  /**\n   * @description The key section or `undefined` when not specified\n   */\n\n\n  get section() {\n    return this._section;\n  }\n\n  is(key) {\n    return key.section === this.section && key.method === this.method;\n  }\n  /**\n   * @description Sets the meta for this key\n   */\n\n\n  setMeta(meta, section, method) {\n    this._meta = meta;\n    this._method = method || this._method;\n    this._section = section || this._section;\n\n    if (meta) {\n      this._outputType = unwrapStorageType(this.registry, meta.type);\n    }\n\n    try {\n      this._args = decodeArgsFromMeta(this.registry, this.toU8a(true), this.meta);\n    } catch (error) {// ignore...\n    }\n\n    return this;\n  }\n  /**\n   * @description Returns the Human representation for this type\n   */\n\n\n  toHuman() {\n    return this._args.length ? this._args.map(arg => arg.toHuman()) : super.toHuman();\n  }\n  /**\n   * @description Returns the raw type for this\n   */\n\n\n  toRawType() {\n    return 'StorageKey';\n  }\n\n}"]},"metadata":{},"sourceType":"module"}