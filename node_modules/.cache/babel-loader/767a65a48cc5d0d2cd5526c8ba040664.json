{"ast":null,"code":"// Copyright 2017-2021 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n// adapted from https://github.com/multiformats/js-multibase/blob/424709195b46ffb1d6f2f69a7707598ebe751e5e/src/rfc4648.js\nimport { assert } from '@polkadot/util';\nimport { BASE32_ALPHABET, BITS_PER_CHAR } from \"./bs32.js\";\nimport { base32Validate } from \"./validate.js\"; // Build the character lookup table:\n\nconst LOOKUP = BASE32_ALPHABET.split('').reduce((lookup, char, index) => {\n  lookup[char] = index;\n  return lookup;\n}, {});\n/** @internal */\n\nfunction decode(output, input, offset) {\n  let bits = 0;\n  let buffer = 0;\n  let written = 0;\n\n  for (let i = offset; i < input.length; i++) {\n    buffer = buffer << BITS_PER_CHAR | LOOKUP[input[i]];\n    bits += BITS_PER_CHAR;\n\n    if (bits >= 8) {\n      bits -= 8;\n      output[written++] = 0xff & buffer >> bits;\n    }\n  }\n\n  return [output, bits, buffer];\n}\n/**\n * @name base32Decode\n * @summary Delookup a base32 value.\n * @description\n * From the provided input, decode the base32 and return the result as an `Uint8Array`.\n */\n\n\nexport function base32Decode(value, ipfsCompat = false) {\n  base32Validate(value, ipfsCompat);\n  const offset = ipfsCompat ? 1 : 0;\n  const [output, bits, buffer] = decode(new Uint8Array((value.length - offset) * BITS_PER_CHAR / 8 | 0), value, offset);\n  assert(!(bits >= BITS_PER_CHAR || 0xff & buffer << 8 - bits), 'Unexpected end of data');\n  return output;\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/util-crypto/base32/decode.js"],"names":["assert","BASE32_ALPHABET","BITS_PER_CHAR","base32Validate","LOOKUP","split","reduce","lookup","char","index","decode","output","input","offset","bits","buffer","written","i","length","base32Decode","value","ipfsCompat","Uint8Array"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,MAAT,QAAuB,gBAAvB;AACA,SAASC,eAAT,EAA0BC,aAA1B,QAA+C,WAA/C;AACA,SAASC,cAAT,QAA+B,eAA/B,C,CAAgD;;AAEhD,MAAMC,MAAM,GAAGH,eAAe,CAACI,KAAhB,CAAsB,EAAtB,EAA0BC,MAA1B,CAAiC,CAACC,MAAD,EAASC,IAAT,EAAeC,KAAf,KAAyB;AACvEF,EAAAA,MAAM,CAACC,IAAD,CAAN,GAAeC,KAAf;AACA,SAAOF,MAAP;AACD,CAHc,EAGZ,EAHY,CAAf;AAIA;;AAEA,SAASG,MAAT,CAAgBC,MAAhB,EAAwBC,KAAxB,EAA+BC,MAA/B,EAAuC;AACrC,MAAIC,IAAI,GAAG,CAAX;AACA,MAAIC,MAAM,GAAG,CAAb;AACA,MAAIC,OAAO,GAAG,CAAd;;AAEA,OAAK,IAAIC,CAAC,GAAGJ,MAAb,EAAqBI,CAAC,GAAGL,KAAK,CAACM,MAA/B,EAAuCD,CAAC,EAAxC,EAA4C;AAC1CF,IAAAA,MAAM,GAAGA,MAAM,IAAIb,aAAV,GAA0BE,MAAM,CAACQ,KAAK,CAACK,CAAD,CAAN,CAAzC;AACAH,IAAAA,IAAI,IAAIZ,aAAR;;AAEA,QAAIY,IAAI,IAAI,CAAZ,EAAe;AACbA,MAAAA,IAAI,IAAI,CAAR;AACAH,MAAAA,MAAM,CAACK,OAAO,EAAR,CAAN,GAAoB,OAAOD,MAAM,IAAID,IAArC;AACD;AACF;;AAED,SAAO,CAACH,MAAD,EAASG,IAAT,EAAeC,MAAf,CAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;;AAGA,OAAO,SAASI,YAAT,CAAsBC,KAAtB,EAA6BC,UAAU,GAAG,KAA1C,EAAiD;AACtDlB,EAAAA,cAAc,CAACiB,KAAD,EAAQC,UAAR,CAAd;AACA,QAAMR,MAAM,GAAGQ,UAAU,GAAG,CAAH,GAAO,CAAhC;AACA,QAAM,CAACV,MAAD,EAASG,IAAT,EAAeC,MAAf,IAAyBL,MAAM,CAAC,IAAIY,UAAJ,CAAe,CAACF,KAAK,CAACF,MAAN,GAAeL,MAAhB,IAA0BX,aAA1B,GAA0C,CAA1C,GAA8C,CAA7D,CAAD,EAAkEkB,KAAlE,EAAyEP,MAAzE,CAArC;AACAb,EAAAA,MAAM,CAAC,EAAEc,IAAI,IAAIZ,aAAR,IAAyB,OAAOa,MAAM,IAAI,IAAID,IAAhD,CAAD,EAAwD,wBAAxD,CAAN;AACA,SAAOH,MAAP;AACD","sourcesContent":["// Copyright 2017-2021 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n// adapted from https://github.com/multiformats/js-multibase/blob/424709195b46ffb1d6f2f69a7707598ebe751e5e/src/rfc4648.js\nimport { assert } from '@polkadot/util';\nimport { BASE32_ALPHABET, BITS_PER_CHAR } from \"./bs32.js\";\nimport { base32Validate } from \"./validate.js\"; // Build the character lookup table:\n\nconst LOOKUP = BASE32_ALPHABET.split('').reduce((lookup, char, index) => {\n  lookup[char] = index;\n  return lookup;\n}, {});\n/** @internal */\n\nfunction decode(output, input, offset) {\n  let bits = 0;\n  let buffer = 0;\n  let written = 0;\n\n  for (let i = offset; i < input.length; i++) {\n    buffer = buffer << BITS_PER_CHAR | LOOKUP[input[i]];\n    bits += BITS_PER_CHAR;\n\n    if (bits >= 8) {\n      bits -= 8;\n      output[written++] = 0xff & buffer >> bits;\n    }\n  }\n\n  return [output, bits, buffer];\n}\n/**\n * @name base32Decode\n * @summary Delookup a base32 value.\n * @description\n * From the provided input, decode the base32 and return the result as an `Uint8Array`.\n */\n\n\nexport function base32Decode(value, ipfsCompat = false) {\n  base32Validate(value, ipfsCompat);\n  const offset = ipfsCompat ? 1 : 0;\n  const [output, bits, buffer] = decode(new Uint8Array((value.length - offset) * BITS_PER_CHAR / 8 | 0), value, offset);\n  assert(!(bits >= BITS_PER_CHAR || 0xff & buffer << 8 - bits), 'Unexpected end of data');\n  return output;\n}"]},"metadata":{},"sourceType":"module"}