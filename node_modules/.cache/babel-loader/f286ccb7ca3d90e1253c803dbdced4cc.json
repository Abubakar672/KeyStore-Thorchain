{"ast":null,"code":"// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { logger } from '@polkadot/util';\nimport { extractTypes } from \"./extractTypes.js\";\nimport { flattenUniq } from \"./flattenUniq.js\";\nconst l = logger('metadata');\n/** @internal */\n\nexport function validateTypes(registry, throwError, types) {\n  const missing = flattenUniq(extractTypes(types)).filter(type => !registry.hasType(type)).sort();\n\n  if (missing.length !== 0) {\n    const message = `Unknown types found, no types for ${missing.join(', ')}`;\n\n    if (throwError) {\n      throw new Error(message);\n    } else {\n      l.warn(message);\n    }\n  }\n\n  return types;\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/types/metadata/util/validateTypes.js"],"names":["logger","extractTypes","flattenUniq","l","validateTypes","registry","throwError","types","missing","filter","type","hasType","sort","length","message","join","Error","warn"],"mappings":"AAAA;AACA;AACA,SAASA,MAAT,QAAuB,gBAAvB;AACA,SAASC,YAAT,QAA6B,mBAA7B;AACA,SAASC,WAAT,QAA4B,kBAA5B;AACA,MAAMC,CAAC,GAAGH,MAAM,CAAC,UAAD,CAAhB;AACA;;AAEA,OAAO,SAASI,aAAT,CAAuBC,QAAvB,EAAiCC,UAAjC,EAA6CC,KAA7C,EAAoD;AACzD,QAAMC,OAAO,GAAGN,WAAW,CAACD,YAAY,CAACM,KAAD,CAAb,CAAX,CAAiCE,MAAjC,CAAwCC,IAAI,IAAI,CAACL,QAAQ,CAACM,OAAT,CAAiBD,IAAjB,CAAjD,EAAyEE,IAAzE,EAAhB;;AAEA,MAAIJ,OAAO,CAACK,MAAR,KAAmB,CAAvB,EAA0B;AACxB,UAAMC,OAAO,GAAI,qCAAoCN,OAAO,CAACO,IAAR,CAAa,IAAb,CAAmB,EAAxE;;AAEA,QAAIT,UAAJ,EAAgB;AACd,YAAM,IAAIU,KAAJ,CAAUF,OAAV,CAAN;AACD,KAFD,MAEO;AACLX,MAAAA,CAAC,CAACc,IAAF,CAAOH,OAAP;AACD;AACF;;AAED,SAAOP,KAAP;AACD","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { logger } from '@polkadot/util';\nimport { extractTypes } from \"./extractTypes.js\";\nimport { flattenUniq } from \"./flattenUniq.js\";\nconst l = logger('metadata');\n/** @internal */\n\nexport function validateTypes(registry, throwError, types) {\n  const missing = flattenUniq(extractTypes(types)).filter(type => !registry.hasType(type)).sort();\n\n  if (missing.length !== 0) {\n    const message = `Unknown types found, no types for ${missing.join(', ')}`;\n\n    if (throwError) {\n      throw new Error(message);\n    } else {\n      l.warn(message);\n    }\n  }\n\n  return types;\n}"]},"metadata":{},"sourceType":"module"}