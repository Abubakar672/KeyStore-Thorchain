{"ast":null,"code":"// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n// we are attempting to avoid circular refs, hence the path import\nimport { getTypeDef } from \"../../create/getTypeDef.js\";\nimport { TypeDefInfo } from \"../../create/types.js\";\n/** @internal */\n\nexport function extractTypes(types) {\n  return types.map(type => {\n    const decoded = getTypeDef(type);\n\n    switch (decoded.info) {\n      case TypeDefInfo.Plain:\n        return decoded.type;\n\n      case TypeDefInfo.BTreeSet:\n      case TypeDefInfo.Compact:\n      case TypeDefInfo.Option:\n      case TypeDefInfo.Vec:\n      case TypeDefInfo.VecFixed:\n        return extractTypes([decoded.sub.type]);\n\n      case TypeDefInfo.BTreeMap:\n      case TypeDefInfo.Enum:\n      case TypeDefInfo.HashMap:\n      case TypeDefInfo.Result:\n      case TypeDefInfo.Set:\n      case TypeDefInfo.Struct:\n      case TypeDefInfo.Tuple:\n        return extractTypes(decoded.sub.map(({\n          type\n        }) => type));\n\n      default:\n        throw new Error(`Unhandled: Unable to create and validate type from ${type} (info=${decoded.info})`);\n    }\n  });\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/types/metadata/util/extractTypes.js"],"names":["getTypeDef","TypeDefInfo","extractTypes","types","map","type","decoded","info","Plain","BTreeSet","Compact","Option","Vec","VecFixed","sub","BTreeMap","Enum","HashMap","Result","Set","Struct","Tuple","Error"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,UAAT,QAA2B,4BAA3B;AACA,SAASC,WAAT,QAA4B,uBAA5B;AAEA;;AACA,OAAO,SAASC,YAAT,CAAsBC,KAAtB,EAA6B;AAClC,SAAOA,KAAK,CAACC,GAAN,CAAUC,IAAI,IAAI;AACvB,UAAMC,OAAO,GAAGN,UAAU,CAACK,IAAD,CAA1B;;AAEA,YAAQC,OAAO,CAACC,IAAhB;AACE,WAAKN,WAAW,CAACO,KAAjB;AACE,eAAOF,OAAO,CAACD,IAAf;;AAEF,WAAKJ,WAAW,CAACQ,QAAjB;AACA,WAAKR,WAAW,CAACS,OAAjB;AACA,WAAKT,WAAW,CAACU,MAAjB;AACA,WAAKV,WAAW,CAACW,GAAjB;AACA,WAAKX,WAAW,CAACY,QAAjB;AACE,eAAOX,YAAY,CAAC,CAACI,OAAO,CAACQ,GAAR,CAAYT,IAAb,CAAD,CAAnB;;AAEF,WAAKJ,WAAW,CAACc,QAAjB;AACA,WAAKd,WAAW,CAACe,IAAjB;AACA,WAAKf,WAAW,CAACgB,OAAjB;AACA,WAAKhB,WAAW,CAACiB,MAAjB;AACA,WAAKjB,WAAW,CAACkB,GAAjB;AACA,WAAKlB,WAAW,CAACmB,MAAjB;AACA,WAAKnB,WAAW,CAACoB,KAAjB;AACE,eAAOnB,YAAY,CAACI,OAAO,CAACQ,GAAR,CAAYV,GAAZ,CAAgB,CAAC;AACnCC,UAAAA;AADmC,SAAD,KAE9BA,IAFc,CAAD,CAAnB;;AAIF;AACE,cAAM,IAAIiB,KAAJ,CAAW,sDAAqDjB,IAAK,UAASC,OAAO,CAACC,IAAK,GAA3F,CAAN;AAvBJ;AAyBD,GA5BM,CAAP;AA6BD","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n// we are attempting to avoid circular refs, hence the path import\nimport { getTypeDef } from \"../../create/getTypeDef.js\";\nimport { TypeDefInfo } from \"../../create/types.js\";\n\n/** @internal */\nexport function extractTypes(types) {\n  return types.map(type => {\n    const decoded = getTypeDef(type);\n\n    switch (decoded.info) {\n      case TypeDefInfo.Plain:\n        return decoded.type;\n\n      case TypeDefInfo.BTreeSet:\n      case TypeDefInfo.Compact:\n      case TypeDefInfo.Option:\n      case TypeDefInfo.Vec:\n      case TypeDefInfo.VecFixed:\n        return extractTypes([decoded.sub.type]);\n\n      case TypeDefInfo.BTreeMap:\n      case TypeDefInfo.Enum:\n      case TypeDefInfo.HashMap:\n      case TypeDefInfo.Result:\n      case TypeDefInfo.Set:\n      case TypeDefInfo.Struct:\n      case TypeDefInfo.Tuple:\n        return extractTypes(decoded.sub.map(({\n          type\n        }) => type));\n\n      default:\n        throw new Error(`Unhandled: Unable to create and validate type from ${type} (info=${decoded.info})`);\n    }\n  });\n}"]},"metadata":{},"sourceType":"module"}