{"ast":null,"code":"// Copyright 2019-2021 @polkadot/wasm-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n// MIT License\n//\n// Copyright (c) 2014 Jameson Little\n//\n// https://github.com/beatgammit/base64-js/blob/88957c9943c7e2a0f03cdf73e71d579e433627d3/index.js\n// This only contains the toByteArray function (no encoding)\n//\n// Only tweaks make here are some TS adjustments (we use strict null checks), the code is otherwise as-is with\n// only the single required function provided\nconst CODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst lookup = [];\nconst revLookup = [];\n\nfor (let i = 0; i < CODE.length; ++i) {\n  lookup[i] = CODE[i];\n  revLookup[CODE.charCodeAt(i)] = i;\n} // Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\n\n\nrevLookup['-'.charCodeAt(0)] = 62;\nrevLookup['_'.charCodeAt(0)] = 63;\n\nfunction getLens(b64) {\n  const len = b64.length;\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4');\n  } // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n\n\n  const validLen = b64.indexOf('=');\n  return validLen === -1 ? [len, 0] : [validLen, 4 - validLen % 4];\n}\n\nexport function toByteArray(b64) {\n  const [validLen, placeHoldersLen] = getLens(b64);\n  const arr = new Uint8Array((validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen);\n  let curByte = 0;\n  let i;\n  let tmp; // if there are placeholders, only get up to the last complete 4 chars\n\n  const len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n\n  for (i = 0; i < len; i += 4) {\n    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n    arr[curByte++] = tmp >> 16 & 0xFF;\n    arr[curByte++] = tmp >> 8 & 0xFF;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n    arr[curByte++] = tmp & 0xFF;\n  } else if (placeHoldersLen === 1) {\n    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n    arr[curByte++] = tmp >> 8 & 0xFF;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  return arr;\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/wasm-crypto-wasm/base64.js"],"names":["CODE","lookup","revLookup","i","length","charCodeAt","getLens","b64","len","Error","validLen","indexOf","toByteArray","placeHoldersLen","arr","Uint8Array","curByte","tmp"],"mappings":"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","sourcesContent":["// Copyright 2019-2021 @polkadot/wasm-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n// MIT License\n//\n// Copyright (c) 2014 Jameson Little\n//\n// https://github.com/beatgammit/base64-js/blob/88957c9943c7e2a0f03cdf73e71d579e433627d3/index.js\n// This only contains the toByteArray function (no encoding)\n//\n// Only tweaks make here are some TS adjustments (we use strict null checks), the code is otherwise as-is with\n// only the single required function provided\nconst CODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst lookup = [];\nconst revLookup = [];\n\nfor (let i = 0; i < CODE.length; ++i) {\n  lookup[i] = CODE[i];\n  revLookup[CODE.charCodeAt(i)] = i;\n} // Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\n\n\nrevLookup['-'.charCodeAt(0)] = 62;\nrevLookup['_'.charCodeAt(0)] = 63;\n\nfunction getLens(b64) {\n  const len = b64.length;\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4');\n  } // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n\n\n  const validLen = b64.indexOf('=');\n  return validLen === -1 ? [len, 0] : [validLen, 4 - validLen % 4];\n}\n\nexport function toByteArray(b64) {\n  const [validLen, placeHoldersLen] = getLens(b64);\n  const arr = new Uint8Array((validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen);\n  let curByte = 0;\n  let i;\n  let tmp; // if there are placeholders, only get up to the last complete 4 chars\n\n  const len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n\n  for (i = 0; i < len; i += 4) {\n    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n    arr[curByte++] = tmp >> 16 & 0xFF;\n    arr[curByte++] = tmp >> 8 & 0xFF;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n    arr[curByte++] = tmp & 0xFF;\n  } else if (placeHoldersLen === 1) {\n    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n    arr[curByte++] = tmp >> 8 & 0xFF;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  return arr;\n}"]},"metadata":{},"sourceType":"module"}