{"ast":null,"code":"/***\n * @license\n * https://github.com/ealmansi/bchaddrjs\n * Copyright (c) 2018-2020 Emilio Almansi\n * Distributed under the MIT software license, see the accompanying\n * file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n */\nvar bs58check = require('bs58check');\n\nvar cashaddr = require('cashaddrjs');\n\nvar Buffer = require('buffer/').Buffer;\n/**\n * General purpose Bitcoin Cash address detection and translation.<br />\n * Supports all major Bitcoin Cash address formats.<br />\n * Currently:\n * <ul>\n *    <li> Legacy format </li>\n *    <li> Bitpay format </li>\n *    <li> Cashaddr format </li>\n * </ul>\n * @module bchaddr\n */\n\n/**\n * @static\n * Supported Bitcoin Cash address formats.\n */\n\n\nvar Format = {};\nFormat.Legacy = 'legacy';\nFormat.Bitpay = 'bitpay';\nFormat.Cashaddr = 'cashaddr';\n/**\n * @static\n * Supported networks.\n */\n\nvar Network = {};\nNetwork.Mainnet = 'mainnet';\nNetwork.Testnet = 'testnet';\n/**\n * @static\n * Supported address types.\n */\n\nvar Type = {};\nType.P2PKH = 'p2pkh';\nType.P2SH = 'p2sh';\n/**\n * Returns a boolean indicating whether the given input is a valid Bitcoin Cash address.\n * @static\n * @param {*} input - Any input to check for validity.\n * @returns {boolean}\n */\n\nfunction isValidAddress(input) {\n  try {\n    decodeAddress(input);\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n/**\n * Detects what is the given address' format.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {string}\n * @throws {InvalidAddressError}\n */\n\n\nfunction detectAddressFormat(address) {\n  return decodeAddress(address).format;\n}\n/**\n * Detects what is the given address' network.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {string}\n * @throws {InvalidAddressError}\n */\n\n\nfunction detectAddressNetwork(address) {\n  return decodeAddress(address).network;\n}\n/**\n * Detects what is the given address' type.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {string}\n * @throws {InvalidAddressError}\n */\n\n\nfunction detectAddressType(address) {\n  return decodeAddress(address).type;\n}\n/**\n * Translates the given address into legacy format.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {string}\n * @throws {InvalidAddressError}\n */\n\n\nfunction toLegacyAddress(address) {\n  var decoded = decodeAddress(address);\n\n  if (decoded.format === Format.Legacy) {\n    return address;\n  }\n\n  return encodeAsLegacy(decoded);\n}\n/**\n * Translates the given address into bitpay format.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {string}\n * @throws {InvalidAddressError}\n */\n\n\nfunction toBitpayAddress(address) {\n  var decoded = decodeAddress(address);\n\n  if (decoded.format === Format.Bitpay) {\n    return address;\n  }\n\n  return encodeAsBitpay(decoded);\n}\n/**\n * Translates the given address into cashaddr format.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {string}\n * @throws {InvalidAddressError}\n */\n\n\nfunction toCashAddress(address) {\n  var decoded = decodeAddress(address);\n  return encodeAsCashaddr(decoded);\n}\n/**\n * Version byte table for base58 formats.\n * @private\n */\n\n\nvar VERSION_BYTE = {};\nVERSION_BYTE[Format.Legacy] = {};\nVERSION_BYTE[Format.Legacy][Network.Mainnet] = {};\nVERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2PKH] = 0;\nVERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2SH] = 5;\nVERSION_BYTE[Format.Legacy][Network.Testnet] = {};\nVERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2PKH] = 111;\nVERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2SH] = 196;\nVERSION_BYTE[Format.Bitpay] = {};\nVERSION_BYTE[Format.Bitpay][Network.Mainnet] = {};\nVERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2PKH] = 28;\nVERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2SH] = 40;\nVERSION_BYTE[Format.Bitpay][Network.Testnet] = {};\nVERSION_BYTE[Format.Bitpay][Network.Testnet][Type.P2PKH] = 111;\nVERSION_BYTE[Format.Bitpay][Network.Testnet][Type.P2SH] = 196;\n/**\n * Decodes the given address into its constituting hash, format, network and type.\n * @private\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {object}\n * @throws {InvalidAddressError}\n */\n\nfunction decodeAddress(address) {\n  try {\n    return decodeBase58Address(address);\n  } catch (error) {}\n\n  try {\n    return decodeCashAddress(address);\n  } catch (error) {}\n\n  throw new InvalidAddressError();\n}\n/**\n * Length of a valid base58check encoding payload: 1 byte for\n * the version byte plus 20 bytes for a RIPEMD-160 hash.\n * @private\n */\n\n\nvar BASE_58_CHECK_PAYLOAD_LENGTH = 21;\n/**\n * Attempts to decode the given address assuming it is a base58 address.\n * @private\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {object}\n * @throws {InvalidAddressError}\n */\n\nfunction decodeBase58Address(address) {\n  try {\n    var payload = bs58check.decode(address);\n\n    if (payload.length !== BASE_58_CHECK_PAYLOAD_LENGTH) {\n      throw new InvalidAddressError();\n    }\n\n    var versionByte = payload[0];\n    var hash = Array.prototype.slice.call(payload, 1);\n\n    switch (versionByte) {\n      case VERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2PKH]:\n        return {\n          hash: hash,\n          format: Format.Legacy,\n          network: Network.Mainnet,\n          type: Type.P2PKH\n        };\n\n      case VERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2SH]:\n        return {\n          hash: hash,\n          format: Format.Legacy,\n          network: Network.Mainnet,\n          type: Type.P2SH\n        };\n\n      case VERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2PKH]:\n        return {\n          hash: hash,\n          format: Format.Legacy,\n          network: Network.Testnet,\n          type: Type.P2PKH\n        };\n\n      case VERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2SH]:\n        return {\n          hash: hash,\n          format: Format.Legacy,\n          network: Network.Testnet,\n          type: Type.P2SH\n        };\n\n      case VERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2PKH]:\n        return {\n          hash: hash,\n          format: Format.Bitpay,\n          network: Network.Mainnet,\n          type: Type.P2PKH\n        };\n\n      case VERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2SH]:\n        return {\n          hash: hash,\n          format: Format.Bitpay,\n          network: Network.Mainnet,\n          type: Type.P2SH\n        };\n    }\n  } catch (error) {}\n\n  throw new InvalidAddressError();\n}\n/**\n * Attempts to decode the given address assuming it is a cashaddr address.\n * @private\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {object}\n * @throws {InvalidAddressError}\n */\n\n\nfunction decodeCashAddress(address) {\n  if (address.indexOf(':') !== -1) {\n    try {\n      return decodeCashAddressWithPrefix(address);\n    } catch (error) {}\n  } else {\n    var prefixes = ['bitcoincash', 'bchtest', 'bchreg'];\n\n    for (var i = 0; i < prefixes.length; ++i) {\n      try {\n        var prefix = prefixes[i];\n        return decodeCashAddressWithPrefix(prefix + ':' + address);\n      } catch (error) {}\n    }\n  }\n\n  throw new InvalidAddressError();\n}\n/**\n * Attempts to decode the given address assuming it is a cashaddr address with explicit prefix.\n * @private\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {object}\n * @throws {InvalidAddressError}\n */\n\n\nfunction decodeCashAddressWithPrefix(address) {\n  try {\n    var decoded = cashaddr.decode(address);\n    var hash = Array.prototype.slice.call(decoded.hash, 0);\n    var type = decoded.type === 'P2PKH' ? Type.P2PKH : Type.P2SH;\n\n    switch (decoded.prefix) {\n      case 'bitcoincash':\n        return {\n          hash: hash,\n          format: Format.Cashaddr,\n          network: Network.Mainnet,\n          type: type\n        };\n\n      case 'bchtest':\n      case 'bchreg':\n        return {\n          hash: hash,\n          format: Format.Cashaddr,\n          network: Network.Testnet,\n          type: type\n        };\n    }\n  } catch (error) {}\n\n  throw new InvalidAddressError();\n}\n/**\n * Encodes the given decoded address into legacy format.\n * @private\n * @param {object} decoded\n * @returns {string}\n */\n\n\nfunction encodeAsLegacy(decoded) {\n  var versionByte = VERSION_BYTE[Format.Legacy][decoded.network][decoded.type];\n  var buffer = Buffer.alloc(1 + decoded.hash.length);\n  buffer[0] = versionByte;\n  buffer.set(decoded.hash, 1);\n  return bs58check.encode(buffer);\n}\n/**\n * Encodes the given decoded address into bitpay format.\n * @private\n * @param {object} decoded\n * @returns {string}\n */\n\n\nfunction encodeAsBitpay(decoded) {\n  var versionByte = VERSION_BYTE[Format.Bitpay][decoded.network][decoded.type];\n  var buffer = Buffer.alloc(1 + decoded.hash.length);\n  buffer[0] = versionByte;\n  buffer.set(decoded.hash, 1);\n  return bs58check.encode(buffer);\n}\n/**\n * Encodes the given decoded address into cashaddr format.\n * @private\n * @param {object} decoded\n * @returns {string}\n */\n\n\nfunction encodeAsCashaddr(decoded) {\n  var prefix = decoded.network === Network.Mainnet ? 'bitcoincash' : 'bchtest';\n  var type = decoded.type === Type.P2PKH ? 'P2PKH' : 'P2SH';\n  var hash = new Uint8Array(decoded.hash);\n  return cashaddr.encode(prefix, type, hash);\n}\n/**\n * Returns a boolean indicating whether the address is in legacy format.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @returns {boolean}\n * @throws {InvalidAddressError}\n */\n\n\nfunction isLegacyAddress(address) {\n  return detectAddressFormat(address) === Format.Legacy;\n}\n/**\n * Returns a boolean indicating whether the address is in bitpay format.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @returns {boolean}\n * @throws {InvalidAddressError}\n */\n\n\nfunction isBitpayAddress(address) {\n  return detectAddressFormat(address) === Format.Bitpay;\n}\n/**\n * Returns a boolean indicating whether the address is in cashaddr format.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @returns {boolean}\n * @throws {InvalidAddressError}\n */\n\n\nfunction isCashAddress(address) {\n  return detectAddressFormat(address) === Format.Cashaddr;\n}\n/**\n * Returns a boolean indicating whether the address is a mainnet address.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @returns {boolean}\n * @throws {InvalidAddressError}\n */\n\n\nfunction isMainnetAddress(address) {\n  return detectAddressNetwork(address) === Network.Mainnet;\n}\n/**\n * Returns a boolean indicating whether the address is a testnet address.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @returns {boolean}\n * @throws {InvalidAddressError}\n */\n\n\nfunction isTestnetAddress(address) {\n  return detectAddressNetwork(address) === Network.Testnet;\n}\n/**\n * Returns a boolean indicating whether the address is a p2pkh address.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @returns {boolean}\n * @throws {InvalidAddressError}\n */\n\n\nfunction isP2PKHAddress(address) {\n  return detectAddressType(address) === Type.P2PKH;\n}\n/**\n * Returns a boolean indicating whether the address is a p2sh address.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @returns {boolean}\n * @throws {InvalidAddressError}\n */\n\n\nfunction isP2SHAddress(address) {\n  return detectAddressType(address) === Type.P2SH;\n}\n/**\n * Error thrown when the address given as input is not a valid Bitcoin Cash address.\n * @constructor\n * InvalidAddressError\n */\n\n\nfunction InvalidAddressError() {\n  var error = new Error();\n  this.name = error.name = 'InvalidAddressError';\n  this.message = error.message = 'Received an invalid Bitcoin Cash address as input.';\n  this.stack = error.stack;\n}\n\nInvalidAddressError.prototype = Object.create(Error.prototype);\nmodule.exports = {\n  Format: Format,\n  Network: Network,\n  Type: Type,\n  isValidAddress: isValidAddress,\n  detectAddressFormat: detectAddressFormat,\n  detectAddressNetwork: detectAddressNetwork,\n  detectAddressType: detectAddressType,\n  toLegacyAddress: toLegacyAddress,\n  toBitpayAddress: toBitpayAddress,\n  toCashAddress: toCashAddress,\n  isLegacyAddress: isLegacyAddress,\n  isBitpayAddress: isBitpayAddress,\n  isCashAddress: isCashAddress,\n  isMainnetAddress: isMainnetAddress,\n  isTestnetAddress: isTestnetAddress,\n  isP2PKHAddress: isP2PKHAddress,\n  isP2SHAddress: isP2SHAddress,\n  InvalidAddressError: InvalidAddressError\n};","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/bchaddrjs/src/bchaddr.js"],"names":["bs58check","require","cashaddr","Buffer","Format","Legacy","Bitpay","Cashaddr","Network","Mainnet","Testnet","Type","P2PKH","P2SH","isValidAddress","input","decodeAddress","error","detectAddressFormat","address","format","detectAddressNetwork","network","detectAddressType","type","toLegacyAddress","decoded","encodeAsLegacy","toBitpayAddress","encodeAsBitpay","toCashAddress","encodeAsCashaddr","VERSION_BYTE","decodeBase58Address","decodeCashAddress","InvalidAddressError","BASE_58_CHECK_PAYLOAD_LENGTH","payload","decode","length","versionByte","hash","Array","prototype","slice","call","indexOf","decodeCashAddressWithPrefix","prefixes","i","prefix","buffer","alloc","set","encode","Uint8Array","isLegacyAddress","isBitpayAddress","isCashAddress","isMainnetAddress","isTestnetAddress","isP2PKHAddress","isP2SHAddress","Error","name","message","stack","Object","create","module","exports"],"mappings":"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","sourcesContent":["/***\n * @license\n * https://github.com/ealmansi/bchaddrjs\n * Copyright (c) 2018-2020 Emilio Almansi\n * Distributed under the MIT software license, see the accompanying\n * file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n */\n\nvar bs58check = require('bs58check')\nvar cashaddr = require('cashaddrjs')\nvar Buffer = require('buffer/').Buffer\n\n/**\n * General purpose Bitcoin Cash address detection and translation.<br />\n * Supports all major Bitcoin Cash address formats.<br />\n * Currently:\n * <ul>\n *    <li> Legacy format </li>\n *    <li> Bitpay format </li>\n *    <li> Cashaddr format </li>\n * </ul>\n * @module bchaddr\n */\n\n/**\n * @static\n * Supported Bitcoin Cash address formats.\n */\nvar Format = {}\nFormat.Legacy = 'legacy'\nFormat.Bitpay = 'bitpay'\nFormat.Cashaddr = 'cashaddr'\n\n/**\n * @static\n * Supported networks.\n */\nvar Network = {}\nNetwork.Mainnet = 'mainnet'\nNetwork.Testnet = 'testnet'\n\n/**\n * @static\n * Supported address types.\n */\nvar Type = {}\nType.P2PKH = 'p2pkh'\nType.P2SH = 'p2sh'\n\n/**\n * Returns a boolean indicating whether the given input is a valid Bitcoin Cash address.\n * @static\n * @param {*} input - Any input to check for validity.\n * @returns {boolean}\n */\nfunction isValidAddress (input) {\n  try {\n    decodeAddress(input)\n    return true\n  } catch (error) {\n    return false\n  }\n}\n\n/**\n * Detects what is the given address' format.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {string}\n * @throws {InvalidAddressError}\n */\nfunction detectAddressFormat (address) {\n  return decodeAddress(address).format\n}\n\n/**\n * Detects what is the given address' network.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {string}\n * @throws {InvalidAddressError}\n */\nfunction detectAddressNetwork (address) {\n  return decodeAddress(address).network\n}\n\n/**\n * Detects what is the given address' type.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {string}\n * @throws {InvalidAddressError}\n */\nfunction detectAddressType (address) {\n  return decodeAddress(address).type\n}\n\n/**\n * Translates the given address into legacy format.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {string}\n * @throws {InvalidAddressError}\n */\nfunction toLegacyAddress (address) {\n  var decoded = decodeAddress(address)\n  if (decoded.format === Format.Legacy) {\n    return address\n  }\n  return encodeAsLegacy(decoded)\n}\n\n/**\n * Translates the given address into bitpay format.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {string}\n * @throws {InvalidAddressError}\n */\nfunction toBitpayAddress (address) {\n  var decoded = decodeAddress(address)\n  if (decoded.format === Format.Bitpay) {\n    return address\n  }\n  return encodeAsBitpay(decoded)\n}\n\n/**\n * Translates the given address into cashaddr format.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {string}\n * @throws {InvalidAddressError}\n */\nfunction toCashAddress (address) {\n  var decoded = decodeAddress(address)\n  return encodeAsCashaddr(decoded)\n}\n\n/**\n * Version byte table for base58 formats.\n * @private\n */\nvar VERSION_BYTE = {}\nVERSION_BYTE[Format.Legacy] = {}\nVERSION_BYTE[Format.Legacy][Network.Mainnet] = {}\nVERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2PKH] = 0\nVERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2SH] = 5\nVERSION_BYTE[Format.Legacy][Network.Testnet] = {}\nVERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2PKH] = 111\nVERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2SH] = 196\nVERSION_BYTE[Format.Bitpay] = {}\nVERSION_BYTE[Format.Bitpay][Network.Mainnet] = {}\nVERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2PKH] = 28\nVERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2SH] = 40\nVERSION_BYTE[Format.Bitpay][Network.Testnet] = {}\nVERSION_BYTE[Format.Bitpay][Network.Testnet][Type.P2PKH] = 111\nVERSION_BYTE[Format.Bitpay][Network.Testnet][Type.P2SH] = 196\n\n/**\n * Decodes the given address into its constituting hash, format, network and type.\n * @private\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {object}\n * @throws {InvalidAddressError}\n */\nfunction decodeAddress (address) {\n  try {\n    return decodeBase58Address(address)\n  } catch (error) {\n  }\n  try {\n    return decodeCashAddress(address)\n  } catch (error) {\n  }\n  throw new InvalidAddressError()\n}\n\n/**\n * Length of a valid base58check encoding payload: 1 byte for\n * the version byte plus 20 bytes for a RIPEMD-160 hash.\n * @private\n */\nvar BASE_58_CHECK_PAYLOAD_LENGTH = 21\n\n/**\n * Attempts to decode the given address assuming it is a base58 address.\n * @private\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {object}\n * @throws {InvalidAddressError}\n */\nfunction decodeBase58Address (address) {\n  try {\n    var payload = bs58check.decode(address)\n    if (payload.length !== BASE_58_CHECK_PAYLOAD_LENGTH) {\n      throw new InvalidAddressError()\n    }\n    var versionByte = payload[0]\n    var hash = Array.prototype.slice.call(payload, 1)\n    switch (versionByte) {\n      case VERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2PKH]:\n        return {\n          hash: hash,\n          format: Format.Legacy,\n          network: Network.Mainnet,\n          type: Type.P2PKH\n        }\n      case VERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2SH]:\n        return {\n          hash: hash,\n          format: Format.Legacy,\n          network: Network.Mainnet,\n          type: Type.P2SH\n        }\n      case VERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2PKH]:\n        return {\n          hash: hash,\n          format: Format.Legacy,\n          network: Network.Testnet,\n          type: Type.P2PKH\n        }\n      case VERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2SH]:\n        return {\n          hash: hash,\n          format: Format.Legacy,\n          network: Network.Testnet,\n          type: Type.P2SH\n        }\n      case VERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2PKH]:\n        return {\n          hash: hash,\n          format: Format.Bitpay,\n          network: Network.Mainnet,\n          type: Type.P2PKH\n        }\n      case VERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2SH]:\n        return {\n          hash: hash,\n          format: Format.Bitpay,\n          network: Network.Mainnet,\n          type: Type.P2SH\n        }\n    }\n  } catch (error) {\n  }\n  throw new InvalidAddressError()\n}\n\n/**\n * Attempts to decode the given address assuming it is a cashaddr address.\n * @private\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {object}\n * @throws {InvalidAddressError}\n */\nfunction decodeCashAddress (address) {\n  if (address.indexOf(':') !== -1) {\n    try {\n      return decodeCashAddressWithPrefix(address)\n    } catch (error) {\n    }\n  } else {\n    var prefixes = ['bitcoincash', 'bchtest', 'bchreg']\n    for (var i = 0; i < prefixes.length; ++i) {\n      try {\n        var prefix = prefixes[i]\n        return decodeCashAddressWithPrefix(prefix + ':' + address)\n      } catch (error) {\n      }\n    }\n  }\n  throw new InvalidAddressError()\n}\n\n/**\n * Attempts to decode the given address assuming it is a cashaddr address with explicit prefix.\n * @private\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @return {object}\n * @throws {InvalidAddressError}\n */\nfunction decodeCashAddressWithPrefix (address) {\n  try {\n    var decoded = cashaddr.decode(address)\n    var hash = Array.prototype.slice.call(decoded.hash, 0)\n    var type = decoded.type === 'P2PKH' ? Type.P2PKH : Type.P2SH\n    switch (decoded.prefix) {\n      case 'bitcoincash':\n        return {\n          hash: hash,\n          format: Format.Cashaddr,\n          network: Network.Mainnet,\n          type: type\n        }\n      case 'bchtest':\n      case 'bchreg':\n        return {\n          hash: hash,\n          format: Format.Cashaddr,\n          network: Network.Testnet,\n          type: type\n        }\n    }\n  } catch (error) {\n  }\n  throw new InvalidAddressError()\n}\n\n/**\n * Encodes the given decoded address into legacy format.\n * @private\n * @param {object} decoded\n * @returns {string}\n */\nfunction encodeAsLegacy (decoded) {\n  var versionByte = VERSION_BYTE[Format.Legacy][decoded.network][decoded.type]\n  var buffer = Buffer.alloc(1 + decoded.hash.length)\n  buffer[0] = versionByte\n  buffer.set(decoded.hash, 1)\n  return bs58check.encode(buffer)\n}\n\n/**\n * Encodes the given decoded address into bitpay format.\n * @private\n * @param {object} decoded\n * @returns {string}\n */\nfunction encodeAsBitpay (decoded) {\n  var versionByte = VERSION_BYTE[Format.Bitpay][decoded.network][decoded.type]\n  var buffer = Buffer.alloc(1 + decoded.hash.length)\n  buffer[0] = versionByte\n  buffer.set(decoded.hash, 1)\n  return bs58check.encode(buffer)\n}\n\n/**\n * Encodes the given decoded address into cashaddr format.\n * @private\n * @param {object} decoded\n * @returns {string}\n */\nfunction encodeAsCashaddr (decoded) {\n  var prefix = decoded.network === Network.Mainnet ? 'bitcoincash' : 'bchtest'\n  var type = decoded.type === Type.P2PKH ? 'P2PKH' : 'P2SH'\n  var hash = new Uint8Array(decoded.hash)\n  return cashaddr.encode(prefix, type, hash)\n}\n\n/**\n * Returns a boolean indicating whether the address is in legacy format.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @returns {boolean}\n * @throws {InvalidAddressError}\n */\nfunction isLegacyAddress (address) {\n  return detectAddressFormat(address) === Format.Legacy\n}\n\n/**\n * Returns a boolean indicating whether the address is in bitpay format.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @returns {boolean}\n * @throws {InvalidAddressError}\n */\nfunction isBitpayAddress (address) {\n  return detectAddressFormat(address) === Format.Bitpay\n}\n\n/**\n * Returns a boolean indicating whether the address is in cashaddr format.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @returns {boolean}\n * @throws {InvalidAddressError}\n */\nfunction isCashAddress (address) {\n  return detectAddressFormat(address) === Format.Cashaddr\n}\n\n/**\n * Returns a boolean indicating whether the address is a mainnet address.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @returns {boolean}\n * @throws {InvalidAddressError}\n */\nfunction isMainnetAddress (address) {\n  return detectAddressNetwork(address) === Network.Mainnet\n}\n\n/**\n * Returns a boolean indicating whether the address is a testnet address.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @returns {boolean}\n * @throws {InvalidAddressError}\n */\nfunction isTestnetAddress (address) {\n  return detectAddressNetwork(address) === Network.Testnet\n}\n\n/**\n * Returns a boolean indicating whether the address is a p2pkh address.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @returns {boolean}\n * @throws {InvalidAddressError}\n */\nfunction isP2PKHAddress (address) {\n  return detectAddressType(address) === Type.P2PKH\n}\n\n/**\n * Returns a boolean indicating whether the address is a p2sh address.\n * @static\n * @param {string} address - A valid Bitcoin Cash address in any format.\n * @returns {boolean}\n * @throws {InvalidAddressError}\n */\nfunction isP2SHAddress (address) {\n  return detectAddressType(address) === Type.P2SH\n}\n\n/**\n * Error thrown when the address given as input is not a valid Bitcoin Cash address.\n * @constructor\n * InvalidAddressError\n */\nfunction InvalidAddressError () {\n  var error = new Error()\n  this.name = error.name = 'InvalidAddressError'\n  this.message = error.message = 'Received an invalid Bitcoin Cash address as input.'\n  this.stack = error.stack\n}\n\nInvalidAddressError.prototype = Object.create(Error.prototype)\n\nmodule.exports = {\n  Format: Format,\n  Network: Network,\n  Type: Type,\n  isValidAddress: isValidAddress,\n  detectAddressFormat: detectAddressFormat,\n  detectAddressNetwork: detectAddressNetwork,\n  detectAddressType: detectAddressType,\n  toLegacyAddress: toLegacyAddress,\n  toBitpayAddress: toBitpayAddress,\n  toCashAddress: toCashAddress,\n  isLegacyAddress: isLegacyAddress,\n  isBitpayAddress: isBitpayAddress,\n  isCashAddress: isCashAddress,\n  isMainnetAddress: isMainnetAddress,\n  isTestnetAddress: isTestnetAddress,\n  isP2PKHAddress: isP2PKHAddress,\n  isP2SHAddress: isP2SHAddress,\n  InvalidAddressError: InvalidAddressError\n}\n"]},"metadata":{},"sourceType":"script"}