{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { assert, isNumber, isString } from '@polkadot/util';\nimport { sanitize } from \"./sanitize.js\";\nimport { TypeDefInfo } from \"./types.js\";\nimport { typeSplit } from \"./typeSplit.js\";\nconst MAX_NESTED = 64;\nconst KNOWN_INTERNALS = ['_alias', '_fallback'];\n\nfunction getTypeString(typeOrObj) {\n  return isString(typeOrObj) ? typeOrObj.toString() : JSON.stringify(typeOrObj);\n}\n\nfunction isRustEnum(details) {\n  const values = Object.values(details);\n\n  if (values.some(v => isNumber(v))) {\n    assert(values.every(v => isNumber(v) && v >= 0 && v <= 255), 'Invalid number-indexed enum definition');\n    return false;\n  }\n\n  return true;\n} // decode an enum of either of the following forms\n//  { _enum: ['A', 'B', 'C'] }\n//  { _enum: { A: AccountId, B: Balance, C: u32 } }\n//  { _enum: { A: 1, B: 2 } }\n\n\nfunction _decodeEnum(value, details, count) {\n  value.info = TypeDefInfo.Enum; // not as pretty, but remain compatible with oo7 for both struct and Array types\n\n  if (Array.isArray(details)) {\n    value.sub = details.map((name, index) => ({\n      index,\n      info: TypeDefInfo.Plain,\n      name,\n      type: 'Null'\n    }));\n  } else if (isRustEnum(details)) {\n    value.sub = Object.entries(details).map(([name, typeOrObj], index) => _objectSpread(_objectSpread({}, getTypeDef(getTypeString(typeOrObj || 'Null'), {\n      name\n    }, count)), {}, {\n      index\n    }));\n  } else {\n    value.sub = Object.entries(details).map(([name, index]) => ({\n      index,\n      info: TypeDefInfo.Plain,\n      name,\n      type: 'Null'\n    }));\n  }\n\n  return value;\n} // decode a set of the form\n//   { _set: { A: 0b0001, B: 0b0010, C: 0b0100 } }\n\n\nfunction _decodeSet(value, details) {\n  value.info = TypeDefInfo.Set;\n  value.length = details._bitLength;\n  value.sub = Object.entries(details).filter(([name]) => !name.startsWith('_')).map(([name, index]) => ({\n    index,\n    info: TypeDefInfo.Plain,\n    name,\n    type: 'Null'\n  }));\n  return value;\n} // decode a struct, set or enum\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeStruct(value, type, _, count) {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  const parsed = JSON.parse(type);\n  const keys = Object.keys(parsed);\n\n  if (keys.length === 1 && keys[0] === '_enum') {\n    return _decodeEnum(value, parsed[keys[0]], count);\n  } else if (keys.length === 1 && keys[0] === '_set') {\n    return _decodeSet(value, parsed[keys[0]]);\n  }\n\n  value.alias = parsed._alias ? new Map(Object.entries(parsed._alias)) : undefined;\n  value.fallbackType = parsed._fallback;\n  value.sub = keys.filter(name => !KNOWN_INTERNALS.includes(name)).map(name => getTypeDef(getTypeString(parsed[name]), {\n    name\n  }, count));\n  return value;\n} // decode a fixed vector, e.g. [u8;32]\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeFixedVec(value, type, _, count) {\n  const max = type.length - 1;\n  let index = -1;\n  let inner = 0;\n\n  for (let i = 1; i < max && index === -1; i++) {\n    if (type[i] === ';' && inner === 0) {\n      index = i;\n    } else if (['[', '(', '<'].includes(type[i])) {\n      inner++;\n    } else if ([']', ')', '>'].includes(type[i])) {\n      inner--;\n    }\n  }\n\n  assert(index !== -1, () => `${type}: Unable to extract location of ';'`);\n  const vecType = type.substr(1, index - 1);\n  const [strLength, displayName] = type.substr(index + 1, max - index - 1).split(';');\n  const length = parseInt(strLength.trim(), 10); // as a first round, only u8 via u8aFixed, we can add more support\n\n  assert(length <= 256, () => `${type}: Only support for [Type; <length>], where length <= 256`);\n  value.displayName = displayName;\n  value.length = length;\n  value.sub = getTypeDef(vecType, {}, count);\n  return value;\n}\n\nfunction _decodeRange(value, _, subType) {\n  const Type = getTypeDef(subType);\n  value.sub = [Type, Type];\n  return value;\n} // decode a tuple\n\n\nfunction _decodeTuple(value, _, subType, count) {\n  value.sub = subType.length === 0 ? [] : typeSplit(subType).map(inner => getTypeDef(inner, {}, count));\n  return value;\n} // decode a Int/UInt<bitLength[, name]>\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeAnyInt(value, type, _, clazz) {\n  const [strLength, displayName] = type.substr(clazz.length + 1, type.length - clazz.length - 1 - 1).split(',');\n  const length = parseInt(strLength.trim(), 10); // as a first round, only u8 via u8aFixed, we can add more support\n\n  assert(length <= 8192 && length % 8 === 0, () => `${type}: Only support for ${clazz}<bitLength>, where length <= 8192 and a power of 8, found ${length}`);\n  value.displayName = displayName;\n  value.length = length;\n  return value;\n}\n\nfunction _decodeInt(value, type, subType) {\n  return _decodeAnyInt(value, type, subType, 'Int');\n}\n\nfunction _decodeUInt(value, type, subType) {\n  return _decodeAnyInt(value, type, subType, 'UInt');\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeDoNotConstruct(value, type, _) {\n  const NAME_LENGTH = 'DoNotConstruct'.length;\n  value.displayName = type.substr(NAME_LENGTH + 1, type.length - NAME_LENGTH - 1 - 1);\n  return value;\n}\n\nfunction hasWrapper(type, [start, end]) {\n  return type.substr(0, start.length) === start && type.substr(-1 * end.length) === end;\n}\n\nconst nestedExtraction = [['[', ']', TypeDefInfo.VecFixed, _decodeFixedVec], ['{', '}', TypeDefInfo.Struct, _decodeStruct], ['(', ')', TypeDefInfo.Tuple, _decodeTuple], // the inner for these are the same as tuple, multiple values\n['BTreeMap<', '>', TypeDefInfo.BTreeMap, _decodeTuple], ['HashMap<', '>', TypeDefInfo.HashMap, _decodeTuple], ['Int<', '>', TypeDefInfo.Int, _decodeInt], // Not sure about these, have a specific implementation?\n['Range<', '>', TypeDefInfo.Tuple, _decodeRange], ['RangeInclusive<', '>', TypeDefInfo.Tuple, _decodeRange], ['Result<', '>', TypeDefInfo.Result, _decodeTuple], ['UInt<', '>', TypeDefInfo.UInt, _decodeUInt], ['DoNotConstruct<', '>', TypeDefInfo.DoNotConstruct, _decodeDoNotConstruct]];\nconst wrappedExtraction = [['BTreeSet<', '>', TypeDefInfo.BTreeSet], ['Compact<', '>', TypeDefInfo.Compact], ['Linkage<', '>', TypeDefInfo.Linkage], ['Option<', '>', TypeDefInfo.Option], ['Vec<', '>', TypeDefInfo.Vec]];\n\nfunction extractSubType(type, [start, end]) {\n  return type.substr(start.length, type.length - start.length - end.length);\n} // eslint-disable-next-line @typescript-eslint/ban-types\n\n\nexport function getTypeDef(_type, {\n  displayName,\n  name\n} = {}, count = 0) {\n  // create the type via Type, allowing types to be sanitized\n  const type = sanitize(_type);\n  const value = {\n    displayName,\n    info: TypeDefInfo.Plain,\n    name,\n    type\n  };\n  assert(++count !== MAX_NESTED, 'getTypeDef: Maximum nested limit reached');\n  const nested = nestedExtraction.find(nested => hasWrapper(type, nested));\n\n  if (nested) {\n    value.info = nested[2];\n    return nested[3](value, type, extractSubType(type, nested), count);\n  }\n\n  const wrapped = wrappedExtraction.find(wrapped => hasWrapper(type, wrapped));\n\n  if (wrapped) {\n    value.info = wrapped[2];\n    value.sub = getTypeDef(extractSubType(type, wrapped), {}, count);\n  }\n\n  return value;\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/types/create/getTypeDef.js"],"names":["_defineProperty","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","assert","isNumber","isString","sanitize","TypeDefInfo","typeSplit","MAX_NESTED","KNOWN_INTERNALS","getTypeString","typeOrObj","toString","JSON","stringify","isRustEnum","details","values","some","v","every","_decodeEnum","value","count","info","Enum","Array","isArray","sub","map","name","index","Plain","type","entries","getTypeDef","_decodeSet","Set","_bitLength","startsWith","_decodeStruct","_","parsed","parse","alias","_alias","Map","undefined","fallbackType","_fallback","includes","_decodeFixedVec","max","inner","vecType","substr","strLength","displayName","split","parseInt","trim","_decodeRange","subType","Type","_decodeTuple","_decodeAnyInt","clazz","_decodeInt","_decodeUInt","_decodeDoNotConstruct","NAME_LENGTH","hasWrapper","start","end","nestedExtraction","VecFixed","Struct","Tuple","BTreeMap","HashMap","Int","Result","UInt","DoNotConstruct","wrappedExtraction","BTreeSet","Compact","Linkage","Option","Vec","extractSubType","_type","nested","find","wrapped"],"mappings":"AAAA,OAAOA,eAAP,MAA4B,2CAA5B;;AAEA,SAASC,OAAT,CAAiBC,MAAjB,EAAyBC,cAAzB,EAAyC;AAAE,MAAIC,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYF,MAAZ,CAAX;;AAAgC,MAAIG,MAAM,CAACC,qBAAX,EAAkC;AAAE,QAAIC,OAAO,GAAGF,MAAM,CAACC,qBAAP,CAA6BJ,MAA7B,CAAd;;AAAoD,QAAIC,cAAJ,EAAoB;AAAEI,MAAAA,OAAO,GAAGA,OAAO,CAACC,MAAR,CAAe,UAAUC,GAAV,EAAe;AAAE,eAAOJ,MAAM,CAACK,wBAAP,CAAgCR,MAAhC,EAAwCO,GAAxC,EAA6CE,UAApD;AAAiE,OAAjG,CAAV;AAA+G;;AAACP,IAAAA,IAAI,CAACQ,IAAL,CAAUC,KAAV,CAAgBT,IAAhB,EAAsBG,OAAtB;AAAiC;;AAAC,SAAOH,IAAP;AAAc;;AAEzV,SAASU,aAAT,CAAuBC,MAAvB,EAA+B;AAAE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,SAAS,CAACC,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;AAAE,QAAIG,MAAM,GAAGF,SAAS,CAACD,CAAD,CAAT,IAAgB,IAAhB,GAAuBC,SAAS,CAACD,CAAD,CAAhC,GAAsC,EAAnD;;AAAuD,QAAIA,CAAC,GAAG,CAAR,EAAW;AAAEf,MAAAA,OAAO,CAACI,MAAM,CAACc,MAAD,CAAP,EAAiB,IAAjB,CAAP,CAA8BC,OAA9B,CAAsC,UAAUC,GAAV,EAAe;AAAErB,QAAAA,eAAe,CAACe,MAAD,EAASM,GAAT,EAAcF,MAAM,CAACE,GAAD,CAApB,CAAf;AAA4C,OAAnG;AAAuG,KAApH,MAA0H,IAAIhB,MAAM,CAACiB,yBAAX,EAAsC;AAAEjB,MAAAA,MAAM,CAACkB,gBAAP,CAAwBR,MAAxB,EAAgCV,MAAM,CAACiB,yBAAP,CAAiCH,MAAjC,CAAhC;AAA4E,KAApH,MAA0H;AAAElB,MAAAA,OAAO,CAACI,MAAM,CAACc,MAAD,CAAP,CAAP,CAAwBC,OAAxB,CAAgC,UAAUC,GAAV,EAAe;AAAEhB,QAAAA,MAAM,CAACmB,cAAP,CAAsBT,MAAtB,EAA8BM,GAA9B,EAAmChB,MAAM,CAACK,wBAAP,CAAgCS,MAAhC,EAAwCE,GAAxC,CAAnC;AAAmF,OAApI;AAAwI;AAAE;;AAAC,SAAON,MAAP;AAAgB,C,CAEthB;AACA;;;AACA,SAASU,MAAT,EAAiBC,QAAjB,EAA2BC,QAA3B,QAA2C,gBAA3C;AACA,SAASC,QAAT,QAAyB,eAAzB;AACA,SAASC,WAAT,QAA4B,YAA5B;AACA,SAASC,SAAT,QAA0B,gBAA1B;AACA,MAAMC,UAAU,GAAG,EAAnB;AACA,MAAMC,eAAe,GAAG,CAAC,QAAD,EAAW,WAAX,CAAxB;;AAEA,SAASC,aAAT,CAAuBC,SAAvB,EAAkC;AAChC,SAAOP,QAAQ,CAACO,SAAD,CAAR,GAAsBA,SAAS,CAACC,QAAV,EAAtB,GAA6CC,IAAI,CAACC,SAAL,CAAeH,SAAf,CAApD;AACD;;AAED,SAASI,UAAT,CAAoBC,OAApB,EAA6B;AAC3B,QAAMC,MAAM,GAAGnC,MAAM,CAACmC,MAAP,CAAcD,OAAd,CAAf;;AAEA,MAAIC,MAAM,CAACC,IAAP,CAAYC,CAAC,IAAIhB,QAAQ,CAACgB,CAAD,CAAzB,CAAJ,EAAmC;AACjCjB,IAAAA,MAAM,CAACe,MAAM,CAACG,KAAP,CAAaD,CAAC,IAAIhB,QAAQ,CAACgB,CAAD,CAAR,IAAeA,CAAC,IAAI,CAApB,IAAyBA,CAAC,IAAI,GAAhD,CAAD,EAAuD,wCAAvD,CAAN;AACA,WAAO,KAAP;AACD;;AAED,SAAO,IAAP;AACD,C,CAAC;AACF;AACA;AACA;;;AAGA,SAASE,WAAT,CAAqBC,KAArB,EAA4BN,OAA5B,EAAqCO,KAArC,EAA4C;AAC1CD,EAAAA,KAAK,CAACE,IAAN,GAAalB,WAAW,CAACmB,IAAzB,CAD0C,CACX;;AAE/B,MAAIC,KAAK,CAACC,OAAN,CAAcX,OAAd,CAAJ,EAA4B;AAC1BM,IAAAA,KAAK,CAACM,GAAN,GAAYZ,OAAO,CAACa,GAAR,CAAY,CAACC,IAAD,EAAOC,KAAP,MAAkB;AACxCA,MAAAA,KADwC;AAExCP,MAAAA,IAAI,EAAElB,WAAW,CAAC0B,KAFsB;AAGxCF,MAAAA,IAHwC;AAIxCG,MAAAA,IAAI,EAAE;AAJkC,KAAlB,CAAZ,CAAZ;AAMD,GAPD,MAOO,IAAIlB,UAAU,CAACC,OAAD,CAAd,EAAyB;AAC9BM,IAAAA,KAAK,CAACM,GAAN,GAAY9C,MAAM,CAACoD,OAAP,CAAelB,OAAf,EAAwBa,GAAxB,CAA4B,CAAC,CAACC,IAAD,EAAOnB,SAAP,CAAD,EAAoBoB,KAApB,KAA8BxC,aAAa,CAACA,aAAa,CAAC,EAAD,EAAK4C,UAAU,CAACzB,aAAa,CAACC,SAAS,IAAI,MAAd,CAAd,EAAqC;AACnJmB,MAAAA;AADmJ,KAArC,EAE7GP,KAF6G,CAAf,CAAd,EAEvE,EAFuE,EAEnE;AACdQ,MAAAA;AADc,KAFmE,CAAvE,CAAZ;AAKD,GANM,MAMA;AACLT,IAAAA,KAAK,CAACM,GAAN,GAAY9C,MAAM,CAACoD,OAAP,CAAelB,OAAf,EAAwBa,GAAxB,CAA4B,CAAC,CAACC,IAAD,EAAOC,KAAP,CAAD,MAAoB;AAC1DA,MAAAA,KAD0D;AAE1DP,MAAAA,IAAI,EAAElB,WAAW,CAAC0B,KAFwC;AAG1DF,MAAAA,IAH0D;AAI1DG,MAAAA,IAAI,EAAE;AAJoD,KAApB,CAA5B,CAAZ;AAMD;;AAED,SAAOX,KAAP;AACD,C,CAAC;AACF;;;AAGA,SAASc,UAAT,CAAoBd,KAApB,EAA2BN,OAA3B,EAAoC;AAClCM,EAAAA,KAAK,CAACE,IAAN,GAAalB,WAAW,CAAC+B,GAAzB;AACAf,EAAAA,KAAK,CAAC3B,MAAN,GAAeqB,OAAO,CAACsB,UAAvB;AACAhB,EAAAA,KAAK,CAACM,GAAN,GAAY9C,MAAM,CAACoD,OAAP,CAAelB,OAAf,EAAwB/B,MAAxB,CAA+B,CAAC,CAAC6C,IAAD,CAAD,KAAY,CAACA,IAAI,CAACS,UAAL,CAAgB,GAAhB,CAA5C,EAAkEV,GAAlE,CAAsE,CAAC,CAACC,IAAD,EAAOC,KAAP,CAAD,MAAoB;AACpGA,IAAAA,KADoG;AAEpGP,IAAAA,IAAI,EAAElB,WAAW,CAAC0B,KAFkF;AAGpGF,IAAAA,IAHoG;AAIpGG,IAAAA,IAAI,EAAE;AAJ8F,GAApB,CAAtE,CAAZ;AAMA,SAAOX,KAAP;AACD,C,CAAC;AACF;;;AAGA,SAASkB,aAAT,CAAuBlB,KAAvB,EAA8BW,IAA9B,EAAoCQ,CAApC,EAAuClB,KAAvC,EAA8C;AAC5C;AACA,QAAMmB,MAAM,GAAG7B,IAAI,CAAC8B,KAAL,CAAWV,IAAX,CAAf;AACA,QAAMpD,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAY6D,MAAZ,CAAb;;AAEA,MAAI7D,IAAI,CAACc,MAAL,KAAgB,CAAhB,IAAqBd,IAAI,CAAC,CAAD,CAAJ,KAAY,OAArC,EAA8C;AAC5C,WAAOwC,WAAW,CAACC,KAAD,EAAQoB,MAAM,CAAC7D,IAAI,CAAC,CAAD,CAAL,CAAd,EAAyB0C,KAAzB,CAAlB;AACD,GAFD,MAEO,IAAI1C,IAAI,CAACc,MAAL,KAAgB,CAAhB,IAAqBd,IAAI,CAAC,CAAD,CAAJ,KAAY,MAArC,EAA6C;AAClD,WAAOuD,UAAU,CAACd,KAAD,EAAQoB,MAAM,CAAC7D,IAAI,CAAC,CAAD,CAAL,CAAd,CAAjB;AACD;;AAEDyC,EAAAA,KAAK,CAACsB,KAAN,GAAcF,MAAM,CAACG,MAAP,GAAgB,IAAIC,GAAJ,CAAQhE,MAAM,CAACoD,OAAP,CAAeQ,MAAM,CAACG,MAAtB,CAAR,CAAhB,GAAyDE,SAAvE;AACAzB,EAAAA,KAAK,CAAC0B,YAAN,GAAqBN,MAAM,CAACO,SAA5B;AACA3B,EAAAA,KAAK,CAACM,GAAN,GAAY/C,IAAI,CAACI,MAAL,CAAY6C,IAAI,IAAI,CAACrB,eAAe,CAACyC,QAAhB,CAAyBpB,IAAzB,CAArB,EAAqDD,GAArD,CAAyDC,IAAI,IAAIK,UAAU,CAACzB,aAAa,CAACgC,MAAM,CAACZ,IAAD,CAAP,CAAd,EAA8B;AACnHA,IAAAA;AADmH,GAA9B,EAEpFP,KAFoF,CAA3E,CAAZ;AAGA,SAAOD,KAAP;AACD,C,CAAC;AACF;;;AAGA,SAAS6B,eAAT,CAAyB7B,KAAzB,EAAgCW,IAAhC,EAAsCQ,CAAtC,EAAyClB,KAAzC,EAAgD;AAC9C,QAAM6B,GAAG,GAAGnB,IAAI,CAACtC,MAAL,GAAc,CAA1B;AACA,MAAIoC,KAAK,GAAG,CAAC,CAAb;AACA,MAAIsB,KAAK,GAAG,CAAZ;;AAEA,OAAK,IAAI5D,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2D,GAAJ,IAAWrB,KAAK,KAAK,CAAC,CAAtC,EAAyCtC,CAAC,EAA1C,EAA8C;AAC5C,QAAIwC,IAAI,CAACxC,CAAD,CAAJ,KAAY,GAAZ,IAAmB4D,KAAK,KAAK,CAAjC,EAAoC;AAClCtB,MAAAA,KAAK,GAAGtC,CAAR;AACD,KAFD,MAEO,IAAI,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgByD,QAAhB,CAAyBjB,IAAI,CAACxC,CAAD,CAA7B,CAAJ,EAAuC;AAC5C4D,MAAAA,KAAK;AACN,KAFM,MAEA,IAAI,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgBH,QAAhB,CAAyBjB,IAAI,CAACxC,CAAD,CAA7B,CAAJ,EAAuC;AAC5C4D,MAAAA,KAAK;AACN;AACF;;AAEDnD,EAAAA,MAAM,CAAC6B,KAAK,KAAK,CAAC,CAAZ,EAAe,MAAO,GAAEE,IAAK,qCAA7B,CAAN;AACA,QAAMqB,OAAO,GAAGrB,IAAI,CAACsB,MAAL,CAAY,CAAZ,EAAexB,KAAK,GAAG,CAAvB,CAAhB;AACA,QAAM,CAACyB,SAAD,EAAYC,WAAZ,IAA2BxB,IAAI,CAACsB,MAAL,CAAYxB,KAAK,GAAG,CAApB,EAAuBqB,GAAG,GAAGrB,KAAN,GAAc,CAArC,EAAwC2B,KAAxC,CAA8C,GAA9C,CAAjC;AACA,QAAM/D,MAAM,GAAGgE,QAAQ,CAACH,SAAS,CAACI,IAAV,EAAD,EAAmB,EAAnB,CAAvB,CAlB8C,CAkBC;;AAE/C1D,EAAAA,MAAM,CAACP,MAAM,IAAI,GAAX,EAAgB,MAAO,GAAEsC,IAAK,0DAA9B,CAAN;AACAX,EAAAA,KAAK,CAACmC,WAAN,GAAoBA,WAApB;AACAnC,EAAAA,KAAK,CAAC3B,MAAN,GAAeA,MAAf;AACA2B,EAAAA,KAAK,CAACM,GAAN,GAAYO,UAAU,CAACmB,OAAD,EAAU,EAAV,EAAc/B,KAAd,CAAtB;AACA,SAAOD,KAAP;AACD;;AAED,SAASuC,YAAT,CAAsBvC,KAAtB,EAA6BmB,CAA7B,EAAgCqB,OAAhC,EAAyC;AACvC,QAAMC,IAAI,GAAG5B,UAAU,CAAC2B,OAAD,CAAvB;AACAxC,EAAAA,KAAK,CAACM,GAAN,GAAY,CAACmC,IAAD,EAAOA,IAAP,CAAZ;AACA,SAAOzC,KAAP;AACD,C,CAAC;;;AAGF,SAAS0C,YAAT,CAAsB1C,KAAtB,EAA6BmB,CAA7B,EAAgCqB,OAAhC,EAAyCvC,KAAzC,EAAgD;AAC9CD,EAAAA,KAAK,CAACM,GAAN,GAAYkC,OAAO,CAACnE,MAAR,KAAmB,CAAnB,GAAuB,EAAvB,GAA4BY,SAAS,CAACuD,OAAD,CAAT,CAAmBjC,GAAnB,CAAuBwB,KAAK,IAAIlB,UAAU,CAACkB,KAAD,EAAQ,EAAR,EAAY9B,KAAZ,CAA1C,CAAxC;AACA,SAAOD,KAAP;AACD,C,CAAC;AACF;;;AAGA,SAAS2C,aAAT,CAAuB3C,KAAvB,EAA8BW,IAA9B,EAAoCQ,CAApC,EAAuCyB,KAAvC,EAA8C;AAC5C,QAAM,CAACV,SAAD,EAAYC,WAAZ,IAA2BxB,IAAI,CAACsB,MAAL,CAAYW,KAAK,CAACvE,MAAN,GAAe,CAA3B,EAA8BsC,IAAI,CAACtC,MAAL,GAAcuE,KAAK,CAACvE,MAApB,GAA6B,CAA7B,GAAiC,CAA/D,EAAkE+D,KAAlE,CAAwE,GAAxE,CAAjC;AACA,QAAM/D,MAAM,GAAGgE,QAAQ,CAACH,SAAS,CAACI,IAAV,EAAD,EAAmB,EAAnB,CAAvB,CAF4C,CAEG;;AAE/C1D,EAAAA,MAAM,CAACP,MAAM,IAAI,IAAV,IAAkBA,MAAM,GAAG,CAAT,KAAe,CAAlC,EAAqC,MAAO,GAAEsC,IAAK,sBAAqBiC,KAAM,6DAA4DvE,MAAO,EAAjJ,CAAN;AACA2B,EAAAA,KAAK,CAACmC,WAAN,GAAoBA,WAApB;AACAnC,EAAAA,KAAK,CAAC3B,MAAN,GAAeA,MAAf;AACA,SAAO2B,KAAP;AACD;;AAED,SAAS6C,UAAT,CAAoB7C,KAApB,EAA2BW,IAA3B,EAAiC6B,OAAjC,EAA0C;AACxC,SAAOG,aAAa,CAAC3C,KAAD,EAAQW,IAAR,EAAc6B,OAAd,EAAuB,KAAvB,CAApB;AACD;;AAED,SAASM,WAAT,CAAqB9C,KAArB,EAA4BW,IAA5B,EAAkC6B,OAAlC,EAA2C;AACzC,SAAOG,aAAa,CAAC3C,KAAD,EAAQW,IAAR,EAAc6B,OAAd,EAAuB,MAAvB,CAApB;AACD,C,CAAC;;;AAGF,SAASO,qBAAT,CAA+B/C,KAA/B,EAAsCW,IAAtC,EAA4CQ,CAA5C,EAA+C;AAC7C,QAAM6B,WAAW,GAAG,iBAAiB3E,MAArC;AACA2B,EAAAA,KAAK,CAACmC,WAAN,GAAoBxB,IAAI,CAACsB,MAAL,CAAYe,WAAW,GAAG,CAA1B,EAA6BrC,IAAI,CAACtC,MAAL,GAAc2E,WAAd,GAA4B,CAA5B,GAAgC,CAA7D,CAApB;AACA,SAAOhD,KAAP;AACD;;AAED,SAASiD,UAAT,CAAoBtC,IAApB,EAA0B,CAACuC,KAAD,EAAQC,GAAR,CAA1B,EAAwC;AACtC,SAAOxC,IAAI,CAACsB,MAAL,CAAY,CAAZ,EAAeiB,KAAK,CAAC7E,MAArB,MAAiC6E,KAAjC,IAA0CvC,IAAI,CAACsB,MAAL,CAAY,CAAC,CAAD,GAAKkB,GAAG,CAAC9E,MAArB,MAAiC8E,GAAlF;AACD;;AAED,MAAMC,gBAAgB,GAAG,CAAC,CAAC,GAAD,EAAM,GAAN,EAAWpE,WAAW,CAACqE,QAAvB,EAAiCxB,eAAjC,CAAD,EAAoD,CAAC,GAAD,EAAM,GAAN,EAAW7C,WAAW,CAACsE,MAAvB,EAA+BpC,aAA/B,CAApD,EAAmG,CAAC,GAAD,EAAM,GAAN,EAAWlC,WAAW,CAACuE,KAAvB,EAA8Bb,YAA9B,CAAnG,EAAgJ;AACzK,CAAC,WAAD,EAAc,GAAd,EAAmB1D,WAAW,CAACwE,QAA/B,EAAyCd,YAAzC,CADyB,EAC+B,CAAC,UAAD,EAAa,GAAb,EAAkB1D,WAAW,CAACyE,OAA9B,EAAuCf,YAAvC,CAD/B,EACqF,CAAC,MAAD,EAAS,GAAT,EAAc1D,WAAW,CAAC0E,GAA1B,EAA+Bb,UAA/B,CADrF,EACiI;AAC1J,CAAC,QAAD,EAAW,GAAX,EAAgB7D,WAAW,CAACuE,KAA5B,EAAmChB,YAAnC,CAFyB,EAEyB,CAAC,iBAAD,EAAoB,GAApB,EAAyBvD,WAAW,CAACuE,KAArC,EAA4ChB,YAA5C,CAFzB,EAEoF,CAAC,SAAD,EAAY,GAAZ,EAAiBvD,WAAW,CAAC2E,MAA7B,EAAqCjB,YAArC,CAFpF,EAEwI,CAAC,OAAD,EAAU,GAAV,EAAe1D,WAAW,CAAC4E,IAA3B,EAAiCd,WAAjC,CAFxI,EAEuL,CAAC,iBAAD,EAAoB,GAApB,EAAyB9D,WAAW,CAAC6E,cAArC,EAAqDd,qBAArD,CAFvL,CAAzB;AAGA,MAAMe,iBAAiB,GAAG,CAAC,CAAC,WAAD,EAAc,GAAd,EAAmB9E,WAAW,CAAC+E,QAA/B,CAAD,EAA2C,CAAC,UAAD,EAAa,GAAb,EAAkB/E,WAAW,CAACgF,OAA9B,CAA3C,EAAmF,CAAC,UAAD,EAAa,GAAb,EAAkBhF,WAAW,CAACiF,OAA9B,CAAnF,EAA2H,CAAC,SAAD,EAAY,GAAZ,EAAiBjF,WAAW,CAACkF,MAA7B,CAA3H,EAAiK,CAAC,MAAD,EAAS,GAAT,EAAclF,WAAW,CAACmF,GAA1B,CAAjK,CAA1B;;AAEA,SAASC,cAAT,CAAwBzD,IAAxB,EAA8B,CAACuC,KAAD,EAAQC,GAAR,CAA9B,EAA4C;AAC1C,SAAOxC,IAAI,CAACsB,MAAL,CAAYiB,KAAK,CAAC7E,MAAlB,EAA0BsC,IAAI,CAACtC,MAAL,GAAc6E,KAAK,CAAC7E,MAApB,GAA6B8E,GAAG,CAAC9E,MAA3D,CAAP;AACD,C,CAAC;;;AAGF,OAAO,SAASwC,UAAT,CAAoBwD,KAApB,EAA2B;AAChClC,EAAAA,WADgC;AAEhC3B,EAAAA;AAFgC,IAG9B,EAHG,EAGCP,KAAK,GAAG,CAHT,EAGY;AACjB;AACA,QAAMU,IAAI,GAAG5B,QAAQ,CAACsF,KAAD,CAArB;AACA,QAAMrE,KAAK,GAAG;AACZmC,IAAAA,WADY;AAEZjC,IAAAA,IAAI,EAAElB,WAAW,CAAC0B,KAFN;AAGZF,IAAAA,IAHY;AAIZG,IAAAA;AAJY,GAAd;AAMA/B,EAAAA,MAAM,CAAC,EAAEqB,KAAF,KAAYf,UAAb,EAAyB,0CAAzB,CAAN;AACA,QAAMoF,MAAM,GAAGlB,gBAAgB,CAACmB,IAAjB,CAAsBD,MAAM,IAAIrB,UAAU,CAACtC,IAAD,EAAO2D,MAAP,CAA1C,CAAf;;AAEA,MAAIA,MAAJ,EAAY;AACVtE,IAAAA,KAAK,CAACE,IAAN,GAAaoE,MAAM,CAAC,CAAD,CAAnB;AACA,WAAOA,MAAM,CAAC,CAAD,CAAN,CAAUtE,KAAV,EAAiBW,IAAjB,EAAuByD,cAAc,CAACzD,IAAD,EAAO2D,MAAP,CAArC,EAAqDrE,KAArD,CAAP;AACD;;AAED,QAAMuE,OAAO,GAAGV,iBAAiB,CAACS,IAAlB,CAAuBC,OAAO,IAAIvB,UAAU,CAACtC,IAAD,EAAO6D,OAAP,CAA5C,CAAhB;;AAEA,MAAIA,OAAJ,EAAa;AACXxE,IAAAA,KAAK,CAACE,IAAN,GAAasE,OAAO,CAAC,CAAD,CAApB;AACAxE,IAAAA,KAAK,CAACM,GAAN,GAAYO,UAAU,CAACuD,cAAc,CAACzD,IAAD,EAAO6D,OAAP,CAAf,EAAgC,EAAhC,EAAoCvE,KAApC,CAAtB;AACD;;AAED,SAAOD,KAAP;AACD","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isNumber, isString } from '@polkadot/util';\nimport { sanitize } from \"./sanitize.js\";\nimport { TypeDefInfo } from \"./types.js\";\nimport { typeSplit } from \"./typeSplit.js\";\nconst MAX_NESTED = 64;\nconst KNOWN_INTERNALS = ['_alias', '_fallback'];\n\nfunction getTypeString(typeOrObj) {\n  return isString(typeOrObj) ? typeOrObj.toString() : JSON.stringify(typeOrObj);\n}\n\nfunction isRustEnum(details) {\n  const values = Object.values(details);\n\n  if (values.some(v => isNumber(v))) {\n    assert(values.every(v => isNumber(v) && v >= 0 && v <= 255), 'Invalid number-indexed enum definition');\n    return false;\n  }\n\n  return true;\n} // decode an enum of either of the following forms\n//  { _enum: ['A', 'B', 'C'] }\n//  { _enum: { A: AccountId, B: Balance, C: u32 } }\n//  { _enum: { A: 1, B: 2 } }\n\n\nfunction _decodeEnum(value, details, count) {\n  value.info = TypeDefInfo.Enum; // not as pretty, but remain compatible with oo7 for both struct and Array types\n\n  if (Array.isArray(details)) {\n    value.sub = details.map((name, index) => ({\n      index,\n      info: TypeDefInfo.Plain,\n      name,\n      type: 'Null'\n    }));\n  } else if (isRustEnum(details)) {\n    value.sub = Object.entries(details).map(([name, typeOrObj], index) => _objectSpread(_objectSpread({}, getTypeDef(getTypeString(typeOrObj || 'Null'), {\n      name\n    }, count)), {}, {\n      index\n    }));\n  } else {\n    value.sub = Object.entries(details).map(([name, index]) => ({\n      index,\n      info: TypeDefInfo.Plain,\n      name,\n      type: 'Null'\n    }));\n  }\n\n  return value;\n} // decode a set of the form\n//   { _set: { A: 0b0001, B: 0b0010, C: 0b0100 } }\n\n\nfunction _decodeSet(value, details) {\n  value.info = TypeDefInfo.Set;\n  value.length = details._bitLength;\n  value.sub = Object.entries(details).filter(([name]) => !name.startsWith('_')).map(([name, index]) => ({\n    index,\n    info: TypeDefInfo.Plain,\n    name,\n    type: 'Null'\n  }));\n  return value;\n} // decode a struct, set or enum\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeStruct(value, type, _, count) {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  const parsed = JSON.parse(type);\n  const keys = Object.keys(parsed);\n\n  if (keys.length === 1 && keys[0] === '_enum') {\n    return _decodeEnum(value, parsed[keys[0]], count);\n  } else if (keys.length === 1 && keys[0] === '_set') {\n    return _decodeSet(value, parsed[keys[0]]);\n  }\n\n  value.alias = parsed._alias ? new Map(Object.entries(parsed._alias)) : undefined;\n  value.fallbackType = parsed._fallback;\n  value.sub = keys.filter(name => !KNOWN_INTERNALS.includes(name)).map(name => getTypeDef(getTypeString(parsed[name]), {\n    name\n  }, count));\n  return value;\n} // decode a fixed vector, e.g. [u8;32]\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeFixedVec(value, type, _, count) {\n  const max = type.length - 1;\n  let index = -1;\n  let inner = 0;\n\n  for (let i = 1; i < max && index === -1; i++) {\n    if (type[i] === ';' && inner === 0) {\n      index = i;\n    } else if (['[', '(', '<'].includes(type[i])) {\n      inner++;\n    } else if ([']', ')', '>'].includes(type[i])) {\n      inner--;\n    }\n  }\n\n  assert(index !== -1, () => `${type}: Unable to extract location of ';'`);\n  const vecType = type.substr(1, index - 1);\n  const [strLength, displayName] = type.substr(index + 1, max - index - 1).split(';');\n  const length = parseInt(strLength.trim(), 10); // as a first round, only u8 via u8aFixed, we can add more support\n\n  assert(length <= 256, () => `${type}: Only support for [Type; <length>], where length <= 256`);\n  value.displayName = displayName;\n  value.length = length;\n  value.sub = getTypeDef(vecType, {}, count);\n  return value;\n}\n\nfunction _decodeRange(value, _, subType) {\n  const Type = getTypeDef(subType);\n  value.sub = [Type, Type];\n  return value;\n} // decode a tuple\n\n\nfunction _decodeTuple(value, _, subType, count) {\n  value.sub = subType.length === 0 ? [] : typeSplit(subType).map(inner => getTypeDef(inner, {}, count));\n  return value;\n} // decode a Int/UInt<bitLength[, name]>\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeAnyInt(value, type, _, clazz) {\n  const [strLength, displayName] = type.substr(clazz.length + 1, type.length - clazz.length - 1 - 1).split(',');\n  const length = parseInt(strLength.trim(), 10); // as a first round, only u8 via u8aFixed, we can add more support\n\n  assert(length <= 8192 && length % 8 === 0, () => `${type}: Only support for ${clazz}<bitLength>, where length <= 8192 and a power of 8, found ${length}`);\n  value.displayName = displayName;\n  value.length = length;\n  return value;\n}\n\nfunction _decodeInt(value, type, subType) {\n  return _decodeAnyInt(value, type, subType, 'Int');\n}\n\nfunction _decodeUInt(value, type, subType) {\n  return _decodeAnyInt(value, type, subType, 'UInt');\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeDoNotConstruct(value, type, _) {\n  const NAME_LENGTH = 'DoNotConstruct'.length;\n  value.displayName = type.substr(NAME_LENGTH + 1, type.length - NAME_LENGTH - 1 - 1);\n  return value;\n}\n\nfunction hasWrapper(type, [start, end]) {\n  return type.substr(0, start.length) === start && type.substr(-1 * end.length) === end;\n}\n\nconst nestedExtraction = [['[', ']', TypeDefInfo.VecFixed, _decodeFixedVec], ['{', '}', TypeDefInfo.Struct, _decodeStruct], ['(', ')', TypeDefInfo.Tuple, _decodeTuple], // the inner for these are the same as tuple, multiple values\n['BTreeMap<', '>', TypeDefInfo.BTreeMap, _decodeTuple], ['HashMap<', '>', TypeDefInfo.HashMap, _decodeTuple], ['Int<', '>', TypeDefInfo.Int, _decodeInt], // Not sure about these, have a specific implementation?\n['Range<', '>', TypeDefInfo.Tuple, _decodeRange], ['RangeInclusive<', '>', TypeDefInfo.Tuple, _decodeRange], ['Result<', '>', TypeDefInfo.Result, _decodeTuple], ['UInt<', '>', TypeDefInfo.UInt, _decodeUInt], ['DoNotConstruct<', '>', TypeDefInfo.DoNotConstruct, _decodeDoNotConstruct]];\nconst wrappedExtraction = [['BTreeSet<', '>', TypeDefInfo.BTreeSet], ['Compact<', '>', TypeDefInfo.Compact], ['Linkage<', '>', TypeDefInfo.Linkage], ['Option<', '>', TypeDefInfo.Option], ['Vec<', '>', TypeDefInfo.Vec]];\n\nfunction extractSubType(type, [start, end]) {\n  return type.substr(start.length, type.length - start.length - end.length);\n} // eslint-disable-next-line @typescript-eslint/ban-types\n\n\nexport function getTypeDef(_type, {\n  displayName,\n  name\n} = {}, count = 0) {\n  // create the type via Type, allowing types to be sanitized\n  const type = sanitize(_type);\n  const value = {\n    displayName,\n    info: TypeDefInfo.Plain,\n    name,\n    type\n  };\n  assert(++count !== MAX_NESTED, 'getTypeDef: Maximum nested limit reached');\n  const nested = nestedExtraction.find(nested => hasWrapper(type, nested));\n\n  if (nested) {\n    value.info = nested[2];\n    return nested[3](value, type, extractSubType(type, nested), count);\n  }\n\n  const wrapped = wrappedExtraction.find(wrapped => hasWrapper(type, wrapped));\n\n  if (wrapped) {\n    value.info = wrapped[2];\n    value.sub = getTypeDef(extractSubType(type, wrapped), {}, count);\n  }\n\n  return value;\n}"]},"metadata":{},"sourceType":"module"}