{"ast":null,"code":"// Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { combineLatest, map, of, switchMap } from 'rxjs';\nimport { memo } from \"../util/index.js\";\n\nfunction parseResult(api, {\n  allIds,\n  allProposals,\n  approvalIds,\n  councilProposals,\n  proposalCount\n}) {\n  const approvals = [];\n  const proposals = [];\n  const councilTreasury = councilProposals.filter(({\n    proposal\n  }) => api.tx.treasury.approveProposal.is(proposal) || api.tx.treasury.rejectProposal.is(proposal));\n  allIds.forEach((id, index) => {\n    if (allProposals[index].isSome) {\n      const council = councilTreasury.filter(({\n        proposal\n      }) => id.eq(proposal.args[0])).sort((a, b) => a.proposal.method.localeCompare(b.proposal.method));\n      const isApproval = approvalIds.some(approvalId => approvalId.eq(id));\n      const derived = {\n        council,\n        id,\n        proposal: allProposals[index].unwrap()\n      };\n\n      if (isApproval) {\n        approvals.push(derived);\n      } else {\n        proposals.push(derived);\n      }\n    }\n  });\n  return {\n    approvals,\n    proposalCount,\n    proposals\n  };\n}\n\nfunction retrieveProposals(api, proposalCount, approvalIds) {\n  const proposalIds = [];\n  const count = proposalCount.toNumber();\n\n  for (let index = 0; index < count; index++) {\n    if (!approvalIds.some(id => id.eqn(index))) {\n      proposalIds.push(api.registry.createType('ProposalIndex', index));\n    }\n  }\n\n  const allIds = [...proposalIds, ...approvalIds];\n  return combineLatest([api.query.treasury.proposals.multi(allIds), api.derive.council ? api.derive.council.proposals() : of([])]).pipe(map(([allProposals, councilProposals]) => parseResult(api, {\n    allIds,\n    allProposals,\n    approvalIds,\n    councilProposals,\n    proposalCount\n  })));\n}\n/**\n * @description Retrieve all active and approved treasury proposals, along with their info\n */\n\n\nexport function proposals(instanceId, api) {\n  return memo(instanceId, () => api.query.treasury ? combineLatest([api.query.treasury.proposalCount(), api.query.treasury.approvals()]).pipe(switchMap(([proposalCount, approvalIds]) => retrieveProposals(api, proposalCount, approvalIds))) : of({\n    approvals: [],\n    proposalCount: api.registry.createType('ProposalIndex'),\n    proposals: []\n  }));\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/api-derive/treasury/proposals.js"],"names":["combineLatest","map","of","switchMap","memo","parseResult","api","allIds","allProposals","approvalIds","councilProposals","proposalCount","approvals","proposals","councilTreasury","filter","proposal","tx","treasury","approveProposal","is","rejectProposal","forEach","id","index","isSome","council","eq","args","sort","a","b","method","localeCompare","isApproval","some","approvalId","derived","unwrap","push","retrieveProposals","proposalIds","count","toNumber","eqn","registry","createType","query","multi","derive","pipe","instanceId"],"mappings":"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","sourcesContent":["// Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { combineLatest, map, of, switchMap } from 'rxjs';\nimport { memo } from \"../util/index.js\";\n\nfunction parseResult(api, {\n  allIds,\n  allProposals,\n  approvalIds,\n  councilProposals,\n  proposalCount\n}) {\n  const approvals = [];\n  const proposals = [];\n  const councilTreasury = councilProposals.filter(({\n    proposal\n  }) => api.tx.treasury.approveProposal.is(proposal) || api.tx.treasury.rejectProposal.is(proposal));\n  allIds.forEach((id, index) => {\n    if (allProposals[index].isSome) {\n      const council = councilTreasury.filter(({\n        proposal\n      }) => id.eq(proposal.args[0])).sort((a, b) => a.proposal.method.localeCompare(b.proposal.method));\n      const isApproval = approvalIds.some(approvalId => approvalId.eq(id));\n      const derived = {\n        council,\n        id,\n        proposal: allProposals[index].unwrap()\n      };\n\n      if (isApproval) {\n        approvals.push(derived);\n      } else {\n        proposals.push(derived);\n      }\n    }\n  });\n  return {\n    approvals,\n    proposalCount,\n    proposals\n  };\n}\n\nfunction retrieveProposals(api, proposalCount, approvalIds) {\n  const proposalIds = [];\n  const count = proposalCount.toNumber();\n\n  for (let index = 0; index < count; index++) {\n    if (!approvalIds.some(id => id.eqn(index))) {\n      proposalIds.push(api.registry.createType('ProposalIndex', index));\n    }\n  }\n\n  const allIds = [...proposalIds, ...approvalIds];\n  return combineLatest([api.query.treasury.proposals.multi(allIds), api.derive.council ? api.derive.council.proposals() : of([])]).pipe(map(([allProposals, councilProposals]) => parseResult(api, {\n    allIds,\n    allProposals,\n    approvalIds,\n    councilProposals,\n    proposalCount\n  })));\n}\n/**\n * @description Retrieve all active and approved treasury proposals, along with their info\n */\n\n\nexport function proposals(instanceId, api) {\n  return memo(instanceId, () => api.query.treasury ? combineLatest([api.query.treasury.proposalCount(), api.query.treasury.approvals()]).pipe(switchMap(([proposalCount, approvalIds]) => retrieveProposals(api, proposalCount, approvalIds))) : of({\n    approvals: [],\n    proposalCount: api.registry.createType('ProposalIndex'),\n    proposals: []\n  }));\n}"]},"metadata":{},"sourceType":"module"}