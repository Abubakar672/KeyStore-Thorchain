{"ast":null,"code":"// Copyright 2017-2021 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert } from '@polkadot/util';\nimport { DeriveJunction } from \"./DeriveJunction.js\";\nconst RE_JUNCTION = /\\/(\\/?)([^/]+)/g;\n/**\n * @description Extract derivation junctions from the supplied path\n */\n\nexport function keyExtractPath(derivePath) {\n  const parts = derivePath.match(RE_JUNCTION);\n  const path = [];\n  let constructed = '';\n\n  if (parts) {\n    constructed = parts.join('');\n    parts.forEach(value => {\n      path.push(DeriveJunction.from(value.substr(1)));\n    });\n  }\n\n  assert(constructed === derivePath, () => `Re-constructed path \"${constructed}\" does not match input`);\n  return {\n    parts,\n    path\n  };\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/util-crypto/key/extractPath.js"],"names":["assert","DeriveJunction","RE_JUNCTION","keyExtractPath","derivePath","parts","match","path","constructed","join","forEach","value","push","from","substr"],"mappings":"AAAA;AACA;AACA,SAASA,MAAT,QAAuB,gBAAvB;AACA,SAASC,cAAT,QAA+B,qBAA/B;AACA,MAAMC,WAAW,GAAG,iBAApB;AAEA;AACA;AACA;;AACA,OAAO,SAASC,cAAT,CAAwBC,UAAxB,EAAoC;AACzC,QAAMC,KAAK,GAAGD,UAAU,CAACE,KAAX,CAAiBJ,WAAjB,CAAd;AACA,QAAMK,IAAI,GAAG,EAAb;AACA,MAAIC,WAAW,GAAG,EAAlB;;AAEA,MAAIH,KAAJ,EAAW;AACTG,IAAAA,WAAW,GAAGH,KAAK,CAACI,IAAN,CAAW,EAAX,CAAd;AACAJ,IAAAA,KAAK,CAACK,OAAN,CAAcC,KAAK,IAAI;AACrBJ,MAAAA,IAAI,CAACK,IAAL,CAAUX,cAAc,CAACY,IAAf,CAAoBF,KAAK,CAACG,MAAN,CAAa,CAAb,CAApB,CAAV;AACD,KAFD;AAGD;;AAEDd,EAAAA,MAAM,CAACQ,WAAW,KAAKJ,UAAjB,EAA6B,MAAO,wBAAuBI,WAAY,wBAAvE,CAAN;AACA,SAAO;AACLH,IAAAA,KADK;AAELE,IAAAA;AAFK,GAAP;AAID","sourcesContent":["// Copyright 2017-2021 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert } from '@polkadot/util';\nimport { DeriveJunction } from \"./DeriveJunction.js\";\nconst RE_JUNCTION = /\\/(\\/?)([^/]+)/g;\n\n/**\n * @description Extract derivation junctions from the supplied path\n */\nexport function keyExtractPath(derivePath) {\n  const parts = derivePath.match(RE_JUNCTION);\n  const path = [];\n  let constructed = '';\n\n  if (parts) {\n    constructed = parts.join('');\n    parts.forEach(value => {\n      path.push(DeriveJunction.from(value.substr(1)));\n    });\n  }\n\n  assert(constructed === derivePath, () => `Re-constructed path \"${constructed}\" does not match input`);\n  return {\n    parts,\n    path\n  };\n}"]},"metadata":{},"sourceType":"module"}