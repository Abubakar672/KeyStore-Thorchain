{"ast":null,"code":"var assert = require('assert');\n\nvar BigInteger = require('bigi');\n\nvar Point = require('./point');\n\nfunction Curve(p, a, b, Gx, Gy, n, h) {\n  this.p = p;\n  this.a = a;\n  this.b = b;\n  this.G = Point.fromAffine(this, Gx, Gy);\n  this.n = n;\n  this.h = h;\n  this.infinity = new Point(this, null, null, BigInteger.ZERO); // result caching\n\n  this.pOverFour = p.add(BigInteger.ONE).shiftRight(2); // determine size of p in bytes\n\n  this.pLength = Math.floor((this.p.bitLength() + 7) / 8);\n}\n\nCurve.prototype.pointFromX = function (isOdd, x) {\n  var alpha = x.pow(3).add(this.a.multiply(x)).add(this.b).mod(this.p);\n  var beta = alpha.modPow(this.pOverFour, this.p); // XXX: not compatible with all curves\n\n  var y = beta;\n\n  if (beta.isEven() ^ !isOdd) {\n    y = this.p.subtract(y); // -y % p\n  }\n\n  return Point.fromAffine(this, x, y);\n};\n\nCurve.prototype.isInfinity = function (Q) {\n  if (Q === this.infinity) return true;\n  return Q.z.signum() === 0 && Q.y.signum() !== 0;\n};\n\nCurve.prototype.isOnCurve = function (Q) {\n  if (this.isInfinity(Q)) return true;\n  var x = Q.affineX;\n  var y = Q.affineY;\n  var a = this.a;\n  var b = this.b;\n  var p = this.p; // Check that xQ and yQ are integers in the interval [0, p - 1]\n\n  if (x.signum() < 0 || x.compareTo(p) >= 0) return false;\n  if (y.signum() < 0 || y.compareTo(p) >= 0) return false; // and check that y^2 = x^3 + ax + b (mod p)\n\n  var lhs = y.square().mod(p);\n  var rhs = x.pow(3).add(a.multiply(x)).add(b).mod(p);\n  return lhs.equals(rhs);\n};\n/**\n * Validate an elliptic curve point.\n *\n * See SEC 1, section 3.2.2.1: Elliptic Curve Public Key Validation Primitive\n */\n\n\nCurve.prototype.validate = function (Q) {\n  // Check Q != O\n  assert(!this.isInfinity(Q), 'Point is at infinity');\n  assert(this.isOnCurve(Q), 'Point is not on the curve'); // Check nQ = O (where Q is a scalar multiple of G)\n\n  var nQ = Q.multiply(this.n);\n  assert(this.isInfinity(nQ), 'Point is not a scalar multiple of G');\n  return true;\n};\n\nmodule.exports = Curve;","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/ecurve/lib/curve.js"],"names":["assert","require","BigInteger","Point","Curve","p","a","b","Gx","Gy","n","h","G","fromAffine","infinity","ZERO","pOverFour","add","ONE","shiftRight","pLength","Math","floor","bitLength","prototype","pointFromX","isOdd","x","alpha","pow","multiply","mod","beta","modPow","y","isEven","subtract","isInfinity","Q","z","signum","isOnCurve","affineX","affineY","compareTo","lhs","square","rhs","equals","validate","nQ","module","exports"],"mappings":"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","sourcesContent":["var assert = require('assert')\nvar BigInteger = require('bigi')\n\nvar Point = require('./point')\n\nfunction Curve (p, a, b, Gx, Gy, n, h) {\n  this.p = p\n  this.a = a\n  this.b = b\n  this.G = Point.fromAffine(this, Gx, Gy)\n  this.n = n\n  this.h = h\n\n  this.infinity = new Point(this, null, null, BigInteger.ZERO)\n\n  // result caching\n  this.pOverFour = p.add(BigInteger.ONE).shiftRight(2)\n\n  // determine size of p in bytes\n  this.pLength = Math.floor((this.p.bitLength() + 7) / 8)\n}\n\nCurve.prototype.pointFromX = function (isOdd, x) {\n  var alpha = x.pow(3).add(this.a.multiply(x)).add(this.b).mod(this.p)\n  var beta = alpha.modPow(this.pOverFour, this.p) // XXX: not compatible with all curves\n\n  var y = beta\n  if (beta.isEven() ^ !isOdd) {\n    y = this.p.subtract(y) // -y % p\n  }\n\n  return Point.fromAffine(this, x, y)\n}\n\nCurve.prototype.isInfinity = function (Q) {\n  if (Q === this.infinity) return true\n\n  return Q.z.signum() === 0 && Q.y.signum() !== 0\n}\n\nCurve.prototype.isOnCurve = function (Q) {\n  if (this.isInfinity(Q)) return true\n\n  var x = Q.affineX\n  var y = Q.affineY\n  var a = this.a\n  var b = this.b\n  var p = this.p\n\n  // Check that xQ and yQ are integers in the interval [0, p - 1]\n  if (x.signum() < 0 || x.compareTo(p) >= 0) return false\n  if (y.signum() < 0 || y.compareTo(p) >= 0) return false\n\n  // and check that y^2 = x^3 + ax + b (mod p)\n  var lhs = y.square().mod(p)\n  var rhs = x.pow(3).add(a.multiply(x)).add(b).mod(p)\n  return lhs.equals(rhs)\n}\n\n/**\n * Validate an elliptic curve point.\n *\n * See SEC 1, section 3.2.2.1: Elliptic Curve Public Key Validation Primitive\n */\nCurve.prototype.validate = function (Q) {\n  // Check Q != O\n  assert(!this.isInfinity(Q), 'Point is at infinity')\n  assert(this.isOnCurve(Q), 'Point is not on the curve')\n\n  // Check nQ = O (where Q is a scalar multiple of G)\n  var nQ = Q.multiply(this.n)\n  assert(this.isInfinity(nQ), 'Point is not a scalar multiple of G')\n\n  return true\n}\n\nmodule.exports = Curve\n"]},"metadata":{},"sourceType":"script"}