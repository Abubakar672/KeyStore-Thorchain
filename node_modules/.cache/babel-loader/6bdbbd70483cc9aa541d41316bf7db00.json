{"ast":null,"code":"var Buffer = require('safe-buffer').Buffer;\n\nvar bcrypto = require('./crypto');\n\nvar bscript = require('./script');\n\nvar bufferutils = require('./bufferutils');\n\nvar opcodes = require('@psf/bitcoincash-ops');\n\nvar typeforce = require('typeforce');\n\nvar types = require('./types');\n\nvar varuint = require('varuint-bitcoin');\n\nfunction varSliceSize(someScript) {\n  var length = someScript.length;\n  return varuint.encodingLength(length) + length;\n}\n\nfunction vectorSize(someVector) {\n  var length = someVector.length;\n  return varuint.encodingLength(length) + someVector.reduce(function (sum, witness) {\n    return sum + varSliceSize(witness);\n  }, 0);\n}\n\nfunction Transaction() {\n  this.version = 2;\n  this.locktime = 0;\n  this.ins = [];\n  this.outs = [];\n}\n\nTransaction.DEFAULT_SEQUENCE = 0xffffffff;\nTransaction.SIGHASH_ALL = 0x01;\nTransaction.SIGHASH_NONE = 0x02;\nTransaction.SIGHASH_SINGLE = 0x03;\nTransaction.SIGHASH_ANYONECANPAY = 0x80;\nTransaction.SIGHASH_BITCOINCASHBIP143 = 0x40;\nTransaction.ADVANCED_TRANSACTION_MARKER = 0x00;\nTransaction.ADVANCED_TRANSACTION_FLAG = 0x01;\nvar EMPTY_SCRIPT = Buffer.allocUnsafe(0);\nvar EMPTY_WITNESS = [];\nvar ZERO = Buffer.from('0000000000000000000000000000000000000000000000000000000000000000', 'hex');\nvar ONE = Buffer.from('0000000000000000000000000000000000000000000000000000000000000001', 'hex');\nvar VALUE_UINT64_MAX = Buffer.from('ffffffffffffffff', 'hex');\nvar BLANK_OUTPUT = {\n  script: EMPTY_SCRIPT,\n  valueBuffer: VALUE_UINT64_MAX\n};\n\nTransaction.fromBuffer = function (buffer, __noStrict) {\n  var offset = 0;\n\n  function readSlice(n) {\n    offset += n;\n    return buffer.slice(offset - n, offset);\n  }\n\n  function readUInt32() {\n    var i = buffer.readUInt32LE(offset);\n    offset += 4;\n    return i;\n  }\n\n  function readInt32() {\n    var i = buffer.readInt32LE(offset);\n    offset += 4;\n    return i;\n  }\n\n  function readUInt64() {\n    var i = bufferutils.readUInt64LE(buffer, offset);\n    offset += 8;\n    return i;\n  }\n\n  function readVarInt() {\n    var vi = varuint.decode(buffer, offset);\n    offset += varuint.decode.bytes;\n    return vi;\n  }\n\n  function readVarSlice() {\n    return readSlice(readVarInt());\n  }\n\n  function readVector() {\n    var count = readVarInt();\n    var vector = [];\n\n    for (var i = 0; i < count; i++) vector.push(readVarSlice());\n\n    return vector;\n  }\n\n  var tx = new Transaction();\n  tx.version = readInt32();\n  var marker = buffer.readUInt8(offset);\n  var flag = buffer.readUInt8(offset + 1);\n  var hasWitnesses = false;\n\n  if (marker === Transaction.ADVANCED_TRANSACTION_MARKER && flag === Transaction.ADVANCED_TRANSACTION_FLAG) {\n    offset += 2;\n    hasWitnesses = true;\n  }\n\n  var vinLen = readVarInt();\n\n  for (var i = 0; i < vinLen; ++i) {\n    tx.ins.push({\n      hash: readSlice(32),\n      index: readUInt32(),\n      script: readVarSlice(),\n      sequence: readUInt32(),\n      witness: EMPTY_WITNESS\n    });\n  }\n\n  var voutLen = readVarInt();\n\n  for (i = 0; i < voutLen; ++i) {\n    tx.outs.push({\n      value: readUInt64(),\n      script: readVarSlice()\n    });\n  }\n\n  if (hasWitnesses) {\n    for (i = 0; i < vinLen; ++i) {\n      tx.ins[i].witness = readVector();\n    } // was this pointless?\n\n\n    if (!tx.hasWitnesses()) throw new Error('Transaction has superfluous witness data');\n  }\n\n  tx.locktime = readUInt32();\n  if (__noStrict) return tx;\n  if (offset !== buffer.length) throw new Error('Transaction has unexpected data');\n  return tx;\n};\n\nTransaction.fromHex = function (hex) {\n  return Transaction.fromBuffer(Buffer.from(hex, 'hex'));\n};\n\nTransaction.isCoinbaseHash = function (buffer) {\n  typeforce(types.Hash256bit, buffer);\n\n  for (var i = 0; i < 32; ++i) {\n    if (buffer[i] !== 0) return false;\n  }\n\n  return true;\n};\n\nTransaction.prototype.isCoinbase = function () {\n  return this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash);\n};\n\nTransaction.prototype.addInput = function (hash, index, sequence, scriptSig) {\n  typeforce(types.tuple(types.Hash256bit, types.UInt32, types.maybe(types.UInt32), types.maybe(types.Buffer)), arguments);\n\n  if (types.Null(sequence)) {\n    sequence = Transaction.DEFAULT_SEQUENCE;\n  } // Add the input and return the input's index\n\n\n  return this.ins.push({\n    hash: hash,\n    index: index,\n    script: scriptSig || EMPTY_SCRIPT,\n    sequence: sequence,\n    witness: EMPTY_WITNESS\n  }) - 1;\n};\n\nTransaction.prototype.addOutput = function (scriptPubKey, value) {\n  typeforce(types.tuple(types.Buffer, types.Satoshi), arguments); // Add the output and return the output's index\n\n  return this.outs.push({\n    script: scriptPubKey,\n    value: value\n  }) - 1;\n};\n\nTransaction.prototype.hasWitnesses = function () {\n  return this.ins.some(function (x) {\n    return x.witness.length !== 0;\n  });\n};\n\nTransaction.prototype.weight = function () {\n  var base = this.__byteLength(false);\n\n  var total = this.__byteLength(true);\n\n  return base * 3 + total;\n};\n\nTransaction.prototype.virtualSize = function () {\n  return Math.ceil(this.weight() / 4);\n};\n\nTransaction.prototype.byteLength = function () {\n  return this.__byteLength(true);\n};\n\nTransaction.prototype.__byteLength = function (__allowWitness) {\n  var hasWitnesses = __allowWitness && this.hasWitnesses();\n\n  return (hasWitnesses ? 10 : 8) + varuint.encodingLength(this.ins.length) + varuint.encodingLength(this.outs.length) + this.ins.reduce(function (sum, input) {\n    return sum + 40 + varSliceSize(input.script);\n  }, 0) + this.outs.reduce(function (sum, output) {\n    return sum + 8 + varSliceSize(output.script);\n  }, 0) + (hasWitnesses ? this.ins.reduce(function (sum, input) {\n    return sum + vectorSize(input.witness);\n  }, 0) : 0);\n};\n\nTransaction.prototype.clone = function () {\n  var newTx = new Transaction();\n  newTx.version = this.version;\n  newTx.locktime = this.locktime;\n  newTx.ins = this.ins.map(function (txIn) {\n    return {\n      hash: txIn.hash,\n      index: txIn.index,\n      script: txIn.script,\n      sequence: txIn.sequence,\n      witness: txIn.witness\n    };\n  });\n  newTx.outs = this.outs.map(function (txOut) {\n    return {\n      script: txOut.script,\n      value: txOut.value\n    };\n  });\n  return newTx;\n};\n/**\n * Hash transaction for signing a specific input.\n *\n * Bitcoin uses a different hash for each signed transaction input.\n * This method copies the transaction, makes the necessary changes based on the\n * hashType, and then hashes the result.\n * This hash can then be used to sign the provided transaction input.\n */\n\n\nTransaction.prototype.hashForSignature = function (inIndex, prevOutScript, hashType) {\n  typeforce(types.tuple(types.UInt32, types.Buffer,\n  /* types.UInt8 */\n  types.Number), arguments); // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29\n\n  if (inIndex >= this.ins.length) return ONE; // ignore OP_CODESEPARATOR\n\n  var ourScript = bscript.compile(bscript.decompile(prevOutScript).filter(function (x) {\n    return x !== opcodes.OP_CODESEPARATOR;\n  }));\n  var txTmp = this.clone(); // SIGHASH_NONE: ignore all outputs? (wildcard payee)\n\n  if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {\n    txTmp.outs = []; // ignore sequence numbers (except at inIndex)\n\n    txTmp.ins.forEach(function (input, i) {\n      if (i === inIndex) return;\n      input.sequence = 0;\n    }); // SIGHASH_SINGLE: ignore all outputs, except at the same index?\n  } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {\n    // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60\n    if (inIndex >= this.outs.length) return ONE; // truncate outputs after\n\n    txTmp.outs.length = inIndex + 1; // \"blank\" outputs before\n\n    for (var i = 0; i < inIndex; i++) {\n      txTmp.outs[i] = BLANK_OUTPUT;\n    } // ignore sequence numbers (except at inIndex)\n\n\n    txTmp.ins.forEach(function (input, y) {\n      if (y === inIndex) return;\n      input.sequence = 0;\n    });\n  } // SIGHASH_ANYONECANPAY: ignore inputs entirely?\n\n\n  if (hashType & Transaction.SIGHASH_ANYONECANPAY) {\n    txTmp.ins = [txTmp.ins[inIndex]];\n    txTmp.ins[0].script = ourScript; // SIGHASH_ALL: only ignore input scripts\n  } else {\n    // \"blank\" others input scripts\n    txTmp.ins.forEach(function (input) {\n      input.script = EMPTY_SCRIPT;\n    });\n    txTmp.ins[inIndex].script = ourScript;\n  } // serialize and hash\n\n\n  var buffer = Buffer.allocUnsafe(txTmp.__byteLength(false) + 4);\n  buffer.writeInt32LE(hashType, buffer.length - 4);\n\n  txTmp.__toBuffer(buffer, 0, false);\n\n  return bcrypto.hash256(buffer);\n};\n\nTransaction.prototype.hashForWitnessV0 = function (inIndex, prevOutScript, value, hashType) {\n  typeforce(types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32), arguments);\n  var tbuffer, toffset;\n\n  function writeSlice(slice) {\n    toffset += slice.copy(tbuffer, toffset);\n  }\n\n  function writeUInt32(i) {\n    toffset = tbuffer.writeUInt32LE(i, toffset);\n  }\n\n  function writeUInt64(i) {\n    toffset = bufferutils.writeUInt64LE(tbuffer, i, toffset);\n  }\n\n  function writeVarInt(i) {\n    varuint.encode(i, tbuffer, toffset);\n    toffset += varuint.encode.bytes;\n  }\n\n  function writeVarSlice(slice) {\n    writeVarInt(slice.length);\n    writeSlice(slice);\n  }\n\n  var hashOutputs = ZERO;\n  var hashPrevouts = ZERO;\n  var hashSequence = ZERO;\n\n  if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {\n    tbuffer = Buffer.allocUnsafe(36 * this.ins.length);\n    toffset = 0;\n    this.ins.forEach(function (txIn) {\n      writeSlice(txIn.hash);\n      writeUInt32(txIn.index);\n    });\n    hashPrevouts = bcrypto.hash256(tbuffer);\n  }\n\n  if (!(hashType & Transaction.SIGHASH_ANYONECANPAY) && (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE && (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {\n    tbuffer = Buffer.allocUnsafe(4 * this.ins.length);\n    toffset = 0;\n    this.ins.forEach(function (txIn) {\n      writeUInt32(txIn.sequence);\n    });\n    hashSequence = bcrypto.hash256(tbuffer);\n  }\n\n  if ((hashType & 0x1f) !== Transaction.SIGHASH_SINGLE && (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {\n    var txOutsSize = this.outs.reduce(function (sum, output) {\n      return sum + 8 + varSliceSize(output.script);\n    }, 0);\n    tbuffer = Buffer.allocUnsafe(txOutsSize);\n    toffset = 0;\n    this.outs.forEach(function (out) {\n      writeUInt64(out.value);\n      writeVarSlice(out.script);\n    });\n    hashOutputs = bcrypto.hash256(tbuffer);\n  } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE && inIndex < this.outs.length) {\n    var output = this.outs[inIndex];\n    tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script));\n    toffset = 0;\n    writeUInt64(output.value);\n    writeVarSlice(output.script);\n    hashOutputs = bcrypto.hash256(tbuffer);\n  }\n\n  tbuffer = Buffer.allocUnsafe(156 + varSliceSize(prevOutScript));\n  toffset = 0;\n  var input = this.ins[inIndex];\n  writeUInt32(this.version);\n  writeSlice(hashPrevouts);\n  writeSlice(hashSequence);\n  writeSlice(input.hash);\n  writeUInt32(input.index);\n  writeVarSlice(prevOutScript);\n  writeUInt64(value);\n  writeUInt32(input.sequence);\n  writeSlice(hashOutputs);\n  writeUInt32(this.locktime);\n  writeUInt32(hashType);\n  return bcrypto.hash256(tbuffer);\n};\n/**\n * Hash transaction for signing a specific input for Bitcoin Cash.\n */\n\n\nTransaction.prototype.hashForCashSignature = function (inIndex, prevOutScript, inAmount, hashType) {\n  typeforce(types.tuple(types.UInt32, types.Buffer,\n  /* types.UInt8 */\n  types.Number, types.maybe(types.UInt53)), arguments); // This function works the way it does because Bitcoin Cash\n  // uses BIP143 as their replay protection, AND their algo\n  // includes `forkId | hashType`, AND since their forkId=0,\n  // this is a NOP, and has no difference to segwit. To support\n  // other forks, another parameter is required, and a new parameter\n  // would be required in the hashForWitnessV0 function, or\n  // it could be broken into two..\n  // BIP143 sighash activated in BitcoinCash via 0x40 bit\n\n  if (hashType & Transaction.SIGHASH_BITCOINCASHBIP143) {\n    if (types.Null(inAmount)) {\n      throw new Error('Bitcoin Cash sighash requires value of input to be signed.');\n    }\n\n    return this.hashForWitnessV0(inIndex, prevOutScript, inAmount, hashType);\n  } else {\n    return this.hashForSignature(inIndex, prevOutScript, hashType);\n  }\n};\n\nTransaction.prototype.getHash = function () {\n  return bcrypto.hash256(this.__toBuffer(undefined, undefined, false));\n};\n\nTransaction.prototype.getId = function () {\n  // transaction hash's are displayed in reverse order\n  return this.getHash().reverse().toString('hex');\n};\n\nTransaction.prototype.toBuffer = function (buffer, initialOffset) {\n  return this.__toBuffer(buffer, initialOffset, true);\n};\n\nTransaction.prototype.__toBuffer = function (buffer, initialOffset, __allowWitness) {\n  if (!buffer) buffer = Buffer.allocUnsafe(this.__byteLength(__allowWitness));\n  var offset = initialOffset || 0;\n\n  function writeSlice(slice) {\n    offset += slice.copy(buffer, offset);\n  }\n\n  function writeUInt8(i) {\n    offset = buffer.writeUInt8(i, offset);\n  }\n\n  function writeUInt32(i) {\n    offset = buffer.writeUInt32LE(i, offset);\n  }\n\n  function writeInt32(i) {\n    offset = buffer.writeInt32LE(i, offset);\n  }\n\n  function writeUInt64(i) {\n    offset = bufferutils.writeUInt64LE(buffer, i, offset);\n  }\n\n  function writeVarInt(i) {\n    varuint.encode(i, buffer, offset);\n    offset += varuint.encode.bytes;\n  }\n\n  function writeVarSlice(slice) {\n    writeVarInt(slice.length);\n    writeSlice(slice);\n  }\n\n  function writeVector(vector) {\n    writeVarInt(vector.length);\n    vector.forEach(writeVarSlice);\n  }\n\n  writeInt32(this.version);\n\n  var hasWitnesses = __allowWitness && this.hasWitnesses();\n\n  if (hasWitnesses) {\n    writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);\n    writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);\n  }\n\n  writeVarInt(this.ins.length);\n  this.ins.forEach(function (txIn) {\n    writeSlice(txIn.hash);\n    writeUInt32(txIn.index);\n    writeVarSlice(txIn.script);\n    writeUInt32(txIn.sequence);\n  });\n  writeVarInt(this.outs.length);\n  this.outs.forEach(function (txOut) {\n    if (!txOut.valueBuffer) {\n      writeUInt64(txOut.value);\n    } else {\n      writeSlice(txOut.valueBuffer);\n    }\n\n    writeVarSlice(txOut.script);\n  });\n\n  if (hasWitnesses) {\n    this.ins.forEach(function (input) {\n      writeVector(input.witness);\n    });\n  }\n\n  writeUInt32(this.locktime); // avoid slicing unless necessary\n\n  if (initialOffset !== undefined) return buffer.slice(initialOffset, offset);\n  return buffer;\n};\n\nTransaction.prototype.toHex = function () {\n  return this.toBuffer().toString('hex');\n};\n\nTransaction.prototype.setInputScript = function (index, scriptSig) {\n  typeforce(types.tuple(types.Number, types.Buffer), arguments);\n  this.ins[index].script = scriptSig;\n};\n\nTransaction.prototype.setWitness = function (index, witness) {\n  typeforce(types.tuple(types.Number, [types.Buffer]), arguments);\n  this.ins[index].witness = witness;\n};\n\nmodule.exports = Transaction;","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@psf/bitcoincashjs-lib/src/transaction.js"],"names":["Buffer","require","bcrypto","bscript","bufferutils","opcodes","typeforce","types","varuint","varSliceSize","someScript","length","encodingLength","vectorSize","someVector","reduce","sum","witness","Transaction","version","locktime","ins","outs","DEFAULT_SEQUENCE","SIGHASH_ALL","SIGHASH_NONE","SIGHASH_SINGLE","SIGHASH_ANYONECANPAY","SIGHASH_BITCOINCASHBIP143","ADVANCED_TRANSACTION_MARKER","ADVANCED_TRANSACTION_FLAG","EMPTY_SCRIPT","allocUnsafe","EMPTY_WITNESS","ZERO","from","ONE","VALUE_UINT64_MAX","BLANK_OUTPUT","script","valueBuffer","fromBuffer","buffer","__noStrict","offset","readSlice","n","slice","readUInt32","i","readUInt32LE","readInt32","readInt32LE","readUInt64","readUInt64LE","readVarInt","vi","decode","bytes","readVarSlice","readVector","count","vector","push","tx","marker","readUInt8","flag","hasWitnesses","vinLen","hash","index","sequence","voutLen","value","Error","fromHex","hex","isCoinbaseHash","Hash256bit","prototype","isCoinbase","addInput","scriptSig","tuple","UInt32","maybe","arguments","Null","addOutput","scriptPubKey","Satoshi","some","x","weight","base","__byteLength","total","virtualSize","Math","ceil","byteLength","__allowWitness","input","output","clone","newTx","map","txIn","txOut","hashForSignature","inIndex","prevOutScript","hashType","Number","ourScript","compile","decompile","filter","OP_CODESEPARATOR","txTmp","forEach","y","writeInt32LE","__toBuffer","hash256","hashForWitnessV0","tbuffer","toffset","writeSlice","copy","writeUInt32","writeUInt32LE","writeUInt64","writeUInt64LE","writeVarInt","encode","writeVarSlice","hashOutputs","hashPrevouts","hashSequence","txOutsSize","out","hashForCashSignature","inAmount","UInt53","getHash","undefined","getId","reverse","toString","toBuffer","initialOffset","writeUInt8","writeInt32","writeVector","toHex","setInputScript","setWitness","module","exports"],"mappings":"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","sourcesContent":["var Buffer = require('safe-buffer').Buffer\nvar bcrypto = require('./crypto')\nvar bscript = require('./script')\nvar bufferutils = require('./bufferutils')\nvar opcodes = require('@psf/bitcoincash-ops')\nvar typeforce = require('typeforce')\nvar types = require('./types')\nvar varuint = require('varuint-bitcoin')\n\nfunction varSliceSize (someScript) {\n  var length = someScript.length\n\n  return varuint.encodingLength(length) + length\n}\n\nfunction vectorSize (someVector) {\n  var length = someVector.length\n\n  return varuint.encodingLength(length) + someVector.reduce(function (sum, witness) {\n    return sum + varSliceSize(witness)\n  }, 0)\n}\n\nfunction Transaction () {\n  this.version = 2\n  this.locktime = 0\n  this.ins = []\n  this.outs = []\n}\n\nTransaction.DEFAULT_SEQUENCE = 0xffffffff\nTransaction.SIGHASH_ALL = 0x01\nTransaction.SIGHASH_NONE = 0x02\nTransaction.SIGHASH_SINGLE = 0x03\nTransaction.SIGHASH_ANYONECANPAY = 0x80\nTransaction.SIGHASH_BITCOINCASHBIP143 = 0x40\nTransaction.ADVANCED_TRANSACTION_MARKER = 0x00\nTransaction.ADVANCED_TRANSACTION_FLAG = 0x01\n\nvar EMPTY_SCRIPT = Buffer.allocUnsafe(0)\nvar EMPTY_WITNESS = []\nvar ZERO = Buffer.from('0000000000000000000000000000000000000000000000000000000000000000', 'hex')\nvar ONE = Buffer.from('0000000000000000000000000000000000000000000000000000000000000001', 'hex')\nvar VALUE_UINT64_MAX = Buffer.from('ffffffffffffffff', 'hex')\nvar BLANK_OUTPUT = {\n  script: EMPTY_SCRIPT,\n  valueBuffer: VALUE_UINT64_MAX\n}\n\nTransaction.fromBuffer = function (buffer, __noStrict) {\n  var offset = 0\n  function readSlice (n) {\n    offset += n\n    return buffer.slice(offset - n, offset)\n  }\n\n  function readUInt32 () {\n    var i = buffer.readUInt32LE(offset)\n    offset += 4\n    return i\n  }\n\n  function readInt32 () {\n    var i = buffer.readInt32LE(offset)\n    offset += 4\n    return i\n  }\n\n  function readUInt64 () {\n    var i = bufferutils.readUInt64LE(buffer, offset)\n    offset += 8\n    return i\n  }\n\n  function readVarInt () {\n    var vi = varuint.decode(buffer, offset)\n    offset += varuint.decode.bytes\n    return vi\n  }\n\n  function readVarSlice () {\n    return readSlice(readVarInt())\n  }\n\n  function readVector () {\n    var count = readVarInt()\n    var vector = []\n    for (var i = 0; i < count; i++) vector.push(readVarSlice())\n    return vector\n  }\n\n  var tx = new Transaction()\n  tx.version = readInt32()\n\n  var marker = buffer.readUInt8(offset)\n  var flag = buffer.readUInt8(offset + 1)\n\n  var hasWitnesses = false\n  if (marker === Transaction.ADVANCED_TRANSACTION_MARKER &&\n      flag === Transaction.ADVANCED_TRANSACTION_FLAG) {\n    offset += 2\n    hasWitnesses = true\n  }\n\n  var vinLen = readVarInt()\n  for (var i = 0; i < vinLen; ++i) {\n    tx.ins.push({\n      hash: readSlice(32),\n      index: readUInt32(),\n      script: readVarSlice(),\n      sequence: readUInt32(),\n      witness: EMPTY_WITNESS\n    })\n  }\n\n  var voutLen = readVarInt()\n  for (i = 0; i < voutLen; ++i) {\n    tx.outs.push({\n      value: readUInt64(),\n      script: readVarSlice()\n    })\n  }\n\n  if (hasWitnesses) {\n    for (i = 0; i < vinLen; ++i) {\n      tx.ins[i].witness = readVector()\n    }\n\n    // was this pointless?\n    if (!tx.hasWitnesses()) throw new Error('Transaction has superfluous witness data')\n  }\n\n  tx.locktime = readUInt32()\n\n  if (__noStrict) return tx\n  if (offset !== buffer.length) throw new Error('Transaction has unexpected data')\n\n  return tx\n}\n\nTransaction.fromHex = function (hex) {\n  return Transaction.fromBuffer(Buffer.from(hex, 'hex'))\n}\n\nTransaction.isCoinbaseHash = function (buffer) {\n  typeforce(types.Hash256bit, buffer)\n  for (var i = 0; i < 32; ++i) {\n    if (buffer[i] !== 0) return false\n  }\n  return true\n}\n\nTransaction.prototype.isCoinbase = function () {\n  return this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash)\n}\n\nTransaction.prototype.addInput = function (hash, index, sequence, scriptSig) {\n  typeforce(types.tuple(\n    types.Hash256bit,\n    types.UInt32,\n    types.maybe(types.UInt32),\n    types.maybe(types.Buffer)\n  ), arguments)\n\n  if (types.Null(sequence)) {\n    sequence = Transaction.DEFAULT_SEQUENCE\n  }\n\n  // Add the input and return the input's index\n  return (this.ins.push({\n    hash: hash,\n    index: index,\n    script: scriptSig || EMPTY_SCRIPT,\n    sequence: sequence,\n    witness: EMPTY_WITNESS\n  }) - 1)\n}\n\nTransaction.prototype.addOutput = function (scriptPubKey, value) {\n  typeforce(types.tuple(types.Buffer, types.Satoshi), arguments)\n\n  // Add the output and return the output's index\n  return (this.outs.push({\n    script: scriptPubKey,\n    value: value\n  }) - 1)\n}\n\nTransaction.prototype.hasWitnesses = function () {\n  return this.ins.some(function (x) {\n    return x.witness.length !== 0\n  })\n}\n\nTransaction.prototype.weight = function () {\n  var base = this.__byteLength(false)\n  var total = this.__byteLength(true)\n  return base * 3 + total\n}\n\nTransaction.prototype.virtualSize = function () {\n  return Math.ceil(this.weight() / 4)\n}\n\nTransaction.prototype.byteLength = function () {\n  return this.__byteLength(true)\n}\n\nTransaction.prototype.__byteLength = function (__allowWitness) {\n  var hasWitnesses = __allowWitness && this.hasWitnesses()\n\n  return (\n    (hasWitnesses ? 10 : 8) +\n    varuint.encodingLength(this.ins.length) +\n    varuint.encodingLength(this.outs.length) +\n    this.ins.reduce(function (sum, input) { return sum + 40 + varSliceSize(input.script) }, 0) +\n    this.outs.reduce(function (sum, output) { return sum + 8 + varSliceSize(output.script) }, 0) +\n    (hasWitnesses ? this.ins.reduce(function (sum, input) { return sum + vectorSize(input.witness) }, 0) : 0)\n  )\n}\n\nTransaction.prototype.clone = function () {\n  var newTx = new Transaction()\n  newTx.version = this.version\n  newTx.locktime = this.locktime\n\n  newTx.ins = this.ins.map(function (txIn) {\n    return {\n      hash: txIn.hash,\n      index: txIn.index,\n      script: txIn.script,\n      sequence: txIn.sequence,\n      witness: txIn.witness\n    }\n  })\n\n  newTx.outs = this.outs.map(function (txOut) {\n    return {\n      script: txOut.script,\n      value: txOut.value\n    }\n  })\n\n  return newTx\n}\n\n/**\n * Hash transaction for signing a specific input.\n *\n * Bitcoin uses a different hash for each signed transaction input.\n * This method copies the transaction, makes the necessary changes based on the\n * hashType, and then hashes the result.\n * This hash can then be used to sign the provided transaction input.\n */\nTransaction.prototype.hashForSignature = function (inIndex, prevOutScript, hashType) {\n  typeforce(types.tuple(types.UInt32, types.Buffer, /* types.UInt8 */ types.Number), arguments)\n\n  // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29\n  if (inIndex >= this.ins.length) return ONE\n\n  // ignore OP_CODESEPARATOR\n  var ourScript = bscript.compile(bscript.decompile(prevOutScript).filter(function (x) {\n    return x !== opcodes.OP_CODESEPARATOR\n  }))\n\n  var txTmp = this.clone()\n\n  // SIGHASH_NONE: ignore all outputs? (wildcard payee)\n  if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {\n    txTmp.outs = []\n\n    // ignore sequence numbers (except at inIndex)\n    txTmp.ins.forEach(function (input, i) {\n      if (i === inIndex) return\n\n      input.sequence = 0\n    })\n\n  // SIGHASH_SINGLE: ignore all outputs, except at the same index?\n  } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {\n    // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60\n    if (inIndex >= this.outs.length) return ONE\n\n    // truncate outputs after\n    txTmp.outs.length = inIndex + 1\n\n    // \"blank\" outputs before\n    for (var i = 0; i < inIndex; i++) {\n      txTmp.outs[i] = BLANK_OUTPUT\n    }\n\n    // ignore sequence numbers (except at inIndex)\n    txTmp.ins.forEach(function (input, y) {\n      if (y === inIndex) return\n\n      input.sequence = 0\n    })\n  }\n\n  // SIGHASH_ANYONECANPAY: ignore inputs entirely?\n  if (hashType & Transaction.SIGHASH_ANYONECANPAY) {\n    txTmp.ins = [txTmp.ins[inIndex]]\n    txTmp.ins[0].script = ourScript\n\n  // SIGHASH_ALL: only ignore input scripts\n  } else {\n    // \"blank\" others input scripts\n    txTmp.ins.forEach(function (input) { input.script = EMPTY_SCRIPT })\n    txTmp.ins[inIndex].script = ourScript\n  }\n\n  // serialize and hash\n  var buffer = Buffer.allocUnsafe(txTmp.__byteLength(false) + 4)\n  buffer.writeInt32LE(hashType, buffer.length - 4)\n  txTmp.__toBuffer(buffer, 0, false)\n\n  return bcrypto.hash256(buffer)\n}\n\nTransaction.prototype.hashForWitnessV0 = function (inIndex, prevOutScript, value, hashType) {\n  typeforce(types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32), arguments)\n\n  var tbuffer, toffset\n  function writeSlice (slice) { toffset += slice.copy(tbuffer, toffset) }\n  function writeUInt32 (i) { toffset = tbuffer.writeUInt32LE(i, toffset) }\n  function writeUInt64 (i) { toffset = bufferutils.writeUInt64LE(tbuffer, i, toffset) }\n  function writeVarInt (i) {\n    varuint.encode(i, tbuffer, toffset)\n    toffset += varuint.encode.bytes\n  }\n  function writeVarSlice (slice) { writeVarInt(slice.length); writeSlice(slice) }\n\n  var hashOutputs = ZERO\n  var hashPrevouts = ZERO\n  var hashSequence = ZERO\n\n  if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {\n    tbuffer = Buffer.allocUnsafe(36 * this.ins.length)\n    toffset = 0\n\n    this.ins.forEach(function (txIn) {\n      writeSlice(txIn.hash)\n      writeUInt32(txIn.index)\n    })\n\n    hashPrevouts = bcrypto.hash256(tbuffer)\n  }\n\n  if (!(hashType & Transaction.SIGHASH_ANYONECANPAY) &&\n       (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n       (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {\n    tbuffer = Buffer.allocUnsafe(4 * this.ins.length)\n    toffset = 0\n\n    this.ins.forEach(function (txIn) {\n      writeUInt32(txIn.sequence)\n    })\n\n    hashSequence = bcrypto.hash256(tbuffer)\n  }\n\n  if ((hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {\n    var txOutsSize = this.outs.reduce(function (sum, output) {\n      return sum + 8 + varSliceSize(output.script)\n    }, 0)\n\n    tbuffer = Buffer.allocUnsafe(txOutsSize)\n    toffset = 0\n\n    this.outs.forEach(function (out) {\n      writeUInt64(out.value)\n      writeVarSlice(out.script)\n    })\n\n    hashOutputs = bcrypto.hash256(tbuffer)\n  } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE && inIndex < this.outs.length) {\n    var output = this.outs[inIndex]\n\n    tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script))\n    toffset = 0\n    writeUInt64(output.value)\n    writeVarSlice(output.script)\n\n    hashOutputs = bcrypto.hash256(tbuffer)\n  }\n\n  tbuffer = Buffer.allocUnsafe(156 + varSliceSize(prevOutScript))\n  toffset = 0\n\n  var input = this.ins[inIndex]\n  writeUInt32(this.version)\n  writeSlice(hashPrevouts)\n  writeSlice(hashSequence)\n  writeSlice(input.hash)\n  writeUInt32(input.index)\n  writeVarSlice(prevOutScript)\n  writeUInt64(value)\n  writeUInt32(input.sequence)\n  writeSlice(hashOutputs)\n  writeUInt32(this.locktime)\n  writeUInt32(hashType)\n  return bcrypto.hash256(tbuffer)\n}\n\n/**\n * Hash transaction for signing a specific input for Bitcoin Cash.\n */\nTransaction.prototype.hashForCashSignature = function (inIndex, prevOutScript, inAmount, hashType) {\n  typeforce(types.tuple(types.UInt32, types.Buffer, /* types.UInt8 */ types.Number, types.maybe(types.UInt53)), arguments)\n\n  // This function works the way it does because Bitcoin Cash\n  // uses BIP143 as their replay protection, AND their algo\n  // includes `forkId | hashType`, AND since their forkId=0,\n  // this is a NOP, and has no difference to segwit. To support\n  // other forks, another parameter is required, and a new parameter\n  // would be required in the hashForWitnessV0 function, or\n  // it could be broken into two..\n\n  // BIP143 sighash activated in BitcoinCash via 0x40 bit\n  if (hashType & Transaction.SIGHASH_BITCOINCASHBIP143) {\n    if (types.Null(inAmount)) {\n      throw new Error('Bitcoin Cash sighash requires value of input to be signed.')\n    }\n    return this.hashForWitnessV0(inIndex, prevOutScript, inAmount, hashType)\n  } else {\n    return this.hashForSignature(inIndex, prevOutScript, hashType)\n  }\n}\n\nTransaction.prototype.getHash = function () {\n  return bcrypto.hash256(this.__toBuffer(undefined, undefined, false))\n}\n\nTransaction.prototype.getId = function () {\n  // transaction hash's are displayed in reverse order\n  return this.getHash().reverse().toString('hex')\n}\n\nTransaction.prototype.toBuffer = function (buffer, initialOffset) {\n  return this.__toBuffer(buffer, initialOffset, true)\n}\n\nTransaction.prototype.__toBuffer = function (buffer, initialOffset, __allowWitness) {\n  if (!buffer) buffer = Buffer.allocUnsafe(this.__byteLength(__allowWitness))\n\n  var offset = initialOffset || 0\n  function writeSlice (slice) { offset += slice.copy(buffer, offset) }\n  function writeUInt8 (i) { offset = buffer.writeUInt8(i, offset) }\n  function writeUInt32 (i) { offset = buffer.writeUInt32LE(i, offset) }\n  function writeInt32 (i) { offset = buffer.writeInt32LE(i, offset) }\n  function writeUInt64 (i) { offset = bufferutils.writeUInt64LE(buffer, i, offset) }\n  function writeVarInt (i) {\n    varuint.encode(i, buffer, offset)\n    offset += varuint.encode.bytes\n  }\n  function writeVarSlice (slice) { writeVarInt(slice.length); writeSlice(slice) }\n  function writeVector (vector) { writeVarInt(vector.length); vector.forEach(writeVarSlice) }\n\n  writeInt32(this.version)\n\n  var hasWitnesses = __allowWitness && this.hasWitnesses()\n\n  if (hasWitnesses) {\n    writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER)\n    writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG)\n  }\n\n  writeVarInt(this.ins.length)\n\n  this.ins.forEach(function (txIn) {\n    writeSlice(txIn.hash)\n    writeUInt32(txIn.index)\n    writeVarSlice(txIn.script)\n    writeUInt32(txIn.sequence)\n  })\n\n  writeVarInt(this.outs.length)\n  this.outs.forEach(function (txOut) {\n    if (!txOut.valueBuffer) {\n      writeUInt64(txOut.value)\n    } else {\n      writeSlice(txOut.valueBuffer)\n    }\n\n    writeVarSlice(txOut.script)\n  })\n\n  if (hasWitnesses) {\n    this.ins.forEach(function (input) {\n      writeVector(input.witness)\n    })\n  }\n\n  writeUInt32(this.locktime)\n\n  // avoid slicing unless necessary\n  if (initialOffset !== undefined) return buffer.slice(initialOffset, offset)\n  return buffer\n}\n\nTransaction.prototype.toHex = function () {\n  return this.toBuffer().toString('hex')\n}\n\nTransaction.prototype.setInputScript = function (index, scriptSig) {\n  typeforce(types.tuple(types.Number, types.Buffer), arguments)\n\n  this.ins[index].script = scriptSig\n}\n\nTransaction.prototype.setWitness = function (index, witness) {\n  typeforce(types.tuple(types.Number, [types.Buffer]), arguments)\n\n  this.ins[index].witness = witness\n}\n\nmodule.exports = Transaction\n"]},"metadata":{},"sourceType":"script"}