{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/keyring authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { assert, u8aConcat, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { blake2AsU8a, convertPublicKeyToCurve25519, convertSecretKeyToCurve25519, ethereumEncode, keccakAsU8a, keyExtractPath, keyFromPath, naclKeypairFromSeed as naclFromSeed, naclOpen, naclSeal, naclSign, schnorrkelKeypairFromSeed as schnorrkelFromSeed, schnorrkelSign, schnorrkelVrfSign, schnorrkelVrfVerify, secp256k1Compress, secp256k1Expand, secp256k1KeypairFromSeed as secp256k1FromSeed, secp256k1Sign, signatureVerify } from '@polkadot/util-crypto';\nimport { decodePair } from \"./decode.js\";\nimport { encodePair } from \"./encode.js\";\nimport { pairToJson } from \"./toJson.js\";\nconst SIG_TYPE_NONE = new Uint8Array();\nconst TYPE_FROM_SEED = {\n  ecdsa: secp256k1FromSeed,\n  ed25519: naclFromSeed,\n  ethereum: secp256k1FromSeed,\n  sr25519: schnorrkelFromSeed\n};\nconst TYPE_PREFIX = {\n  ecdsa: new Uint8Array([2]),\n  ed25519: new Uint8Array([0]),\n  ethereum: new Uint8Array([2]),\n  sr25519: new Uint8Array([1])\n};\nconst TYPE_SIGNATURE = {\n  ecdsa: (m, p) => secp256k1Sign(m, p, 'blake2'),\n  ed25519: naclSign,\n  ethereum: (m, p) => secp256k1Sign(m, p, 'keccak'),\n  sr25519: schnorrkelSign\n};\nconst TYPE_ADDRESS = {\n  ecdsa: p => p.length > 32 ? blake2AsU8a(p) : p,\n  ed25519: p => p,\n  ethereum: p => p.length === 20 ? p : keccakAsU8a(secp256k1Expand(p)),\n  sr25519: p => p\n}; // Not 100% correct, since it can be a Uint8Array, but an invalid one - just say \"undefined\" is anything non-valid\n\nfunction isLocked(secretKey) {\n  return !secretKey || secretKey.length === 0 || secretKey.every(b => b === 0);\n}\n\nfunction vrfHash(proof, context, extra) {\n  return blake2AsU8a(u8aConcat(context || '', extra || '', proof));\n}\n/**\n * @name createPair\n * @summary Creates a keyring pair object\n * @description Creates a keyring pair object with provided account public key, metadata, and encoded arguments.\n * The keyring pair stores the account state including the encoded address and associated metadata.\n *\n * It has properties whose values are functions that may be called to perform account actions:\n *\n * - `address` function retrieves the address associated with the account.\n * - `decodedPkcs8` function is called with the account passphrase and account encoded public key.\n * It decodes the encoded public key using the passphrase provided to obtain the decoded account public key\n * and associated secret key that are then available in memory, and changes the account address stored in the\n * state of the pair to correspond to the address of the decoded public key.\n * - `encodePkcs8` function when provided with the correct passphrase associated with the account pair\n * and when the secret key is in memory (when the account pair is not locked) it returns an encoded\n * public key of the account.\n * - `meta` is the metadata that is stored in the state of the pair, either when it was originally\n * created or set via `setMeta`.\n * - `publicKey` returns the public key stored in memory for the pair.\n * - `sign` may be used to return a signature by signing a provided message with the secret\n * key (if it is in memory) using Nacl.\n * - `toJson` calls another `toJson` function and provides the state of the pair,\n * it generates arguments to be passed to the other `toJson` function including an encoded public key of the account\n * that it generates using the secret key from memory (if it has been made available in memory)\n * and the optionally provided passphrase argument. It passes a third boolean argument to `toJson`\n * indicating whether the public key has been encoded or not (if a passphrase argument was provided then it is encoded).\n * The `toJson` function that it calls returns a JSON object with properties including the `address`\n * and `meta` that are assigned with the values stored in the corresponding state variables of the account pair,\n * an `encoded` property that is assigned with the encoded public key in hex format, and an `encoding`\n * property that indicates whether the public key value of the `encoded` property is encoded or not.\n */\n\n\nexport function createPair({\n  toSS58,\n  type\n}, {\n  publicKey,\n  secretKey\n}, meta = {}, encoded = null, encTypes) {\n  const decodePkcs8 = (passphrase, userEncoded) => {\n    const decoded = decodePair(passphrase, userEncoded || encoded, encTypes);\n\n    if (decoded.secretKey.length === 64) {\n      publicKey = decoded.publicKey;\n      secretKey = decoded.secretKey;\n    } else {\n      const pair = TYPE_FROM_SEED[type](decoded.secretKey);\n      publicKey = pair.publicKey;\n      secretKey = pair.secretKey;\n    }\n  };\n\n  const recode = passphrase => {\n    isLocked(secretKey) && encoded && decodePkcs8(passphrase, encoded);\n    encoded = encodePair({\n      publicKey,\n      secretKey\n    }, passphrase); // re-encode, latest version\n\n    encTypes = undefined; // swap to defaults, latest version follows\n\n    return encoded;\n  };\n\n  const encodeAddress = () => {\n    const raw = TYPE_ADDRESS[type](publicKey);\n    return type === 'ethereum' ? ethereumEncode(raw) : toSS58(raw);\n  };\n\n  return {\n    get address() {\n      return encodeAddress();\n    },\n\n    get addressRaw() {\n      const raw = TYPE_ADDRESS[type](publicKey);\n      return type === 'ethereum' ? raw.slice(-20) : raw;\n    },\n\n    get isLocked() {\n      return isLocked(secretKey);\n    },\n\n    get meta() {\n      return meta;\n    },\n\n    get publicKey() {\n      return publicKey;\n    },\n\n    get type() {\n      return type;\n    },\n\n    // eslint-disable-next-line sort-keys\n    decodePkcs8,\n    decryptMessage: (encryptedMessageWithNonce, senderPublicKey) => {\n      assert(!isLocked(secretKey), 'Cannot encrypt with a locked key pair');\n      assert(!['ecdsa', 'ethereum'].includes(type), 'Secp256k1 not supported yet');\n      const messageU8a = u8aToU8a(encryptedMessageWithNonce);\n      return naclOpen(messageU8a.slice(24, messageU8a.length), messageU8a.slice(0, 24), convertPublicKeyToCurve25519(u8aToU8a(senderPublicKey)), convertSecretKeyToCurve25519(secretKey));\n    },\n    derive: (suri, meta) => {\n      assert(type !== 'ethereum', 'Unable to derive on this keypair');\n      assert(!isLocked(secretKey), 'Cannot derive on a locked keypair');\n      const {\n        path\n      } = keyExtractPath(suri);\n      const derived = keyFromPath({\n        publicKey,\n        secretKey\n      }, path, type);\n      return createPair({\n        toSS58,\n        type\n      }, derived, meta, null);\n    },\n    encodePkcs8: passphrase => {\n      return recode(passphrase);\n    },\n    encryptMessage: (message, recipientPublicKey, nonceIn) => {\n      assert(!isLocked(secretKey), 'Cannot encrypt with a locked key pair');\n      assert(!['ecdsa', 'ethereum'].includes(type), 'Secp256k1 not supported yet');\n      const {\n        nonce,\n        sealed\n      } = naclSeal(u8aToU8a(message), convertSecretKeyToCurve25519(secretKey), convertPublicKeyToCurve25519(u8aToU8a(recipientPublicKey)), nonceIn);\n      return u8aConcat(nonce, sealed);\n    },\n    lock: () => {\n      secretKey = new Uint8Array();\n    },\n    setMeta: additional => {\n      meta = _objectSpread(_objectSpread({}, meta), additional);\n    },\n    sign: (message, options = {}) => {\n      assert(!isLocked(secretKey), 'Cannot sign with a locked key pair');\n      return u8aConcat(options.withType ? TYPE_PREFIX[type] : SIG_TYPE_NONE, TYPE_SIGNATURE[type](u8aToU8a(message), {\n        publicKey,\n        secretKey\n      }));\n    },\n    toJson: passphrase => {\n      // NOTE: For ecdsa and ethereum, the publicKey cannot be extracted from the address. For these\n      // pass the hex-encoded publicKey through to the address portion of the JSON (before decoding)\n      // unless the publicKey is already an address\n      const address = ['ecdsa', 'ethereum'].includes(type) ? publicKey.length === 20 ? u8aToHex(publicKey) : u8aToHex(secp256k1Compress(publicKey)) : encodeAddress();\n      return pairToJson(type, {\n        address,\n        meta\n      }, recode(passphrase), !!passphrase);\n    },\n    unlock: passphrase => {\n      return decodePkcs8(passphrase);\n    },\n    verify: (message, signature, signerPublic) => {\n      return signatureVerify(message, signature, TYPE_ADDRESS[type](u8aToU8a(signerPublic))).isValid;\n    },\n    vrfSign: (message, context, extra) => {\n      assert(!isLocked(secretKey), 'Cannot sign with a locked key pair');\n\n      if (type === 'sr25519') {\n        return schnorrkelVrfSign(message, {\n          secretKey\n        }, context, extra);\n      }\n\n      const proof = TYPE_SIGNATURE[type](u8aToU8a(message), {\n        publicKey,\n        secretKey\n      });\n      return u8aConcat(vrfHash(proof, context, extra), proof);\n    },\n    vrfVerify: (message, vrfResult, signerPublic, context, extra) => {\n      if (type === 'sr25519') {\n        return schnorrkelVrfVerify(message, vrfResult, publicKey, context, extra);\n      }\n\n      const result = signatureVerify(message, u8aConcat(TYPE_PREFIX[type], vrfResult.subarray(32)), TYPE_ADDRESS[type](u8aToU8a(signerPublic)));\n      return result.isValid && u8aEq(vrfResult.subarray(0, 32), vrfHash(vrfResult.subarray(32), context, extra));\n    }\n  };\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/keyring/pair/index.js"],"names":["_defineProperty","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","assert","u8aConcat","u8aEq","u8aToHex","u8aToU8a","blake2AsU8a","convertPublicKeyToCurve25519","convertSecretKeyToCurve25519","ethereumEncode","keccakAsU8a","keyExtractPath","keyFromPath","naclKeypairFromSeed","naclFromSeed","naclOpen","naclSeal","naclSign","schnorrkelKeypairFromSeed","schnorrkelFromSeed","schnorrkelSign","schnorrkelVrfSign","schnorrkelVrfVerify","secp256k1Compress","secp256k1Expand","secp256k1KeypairFromSeed","secp256k1FromSeed","secp256k1Sign","signatureVerify","decodePair","encodePair","pairToJson","SIG_TYPE_NONE","Uint8Array","TYPE_FROM_SEED","ecdsa","ed25519","ethereum","sr25519","TYPE_PREFIX","TYPE_SIGNATURE","m","p","TYPE_ADDRESS","isLocked","secretKey","every","b","vrfHash","proof","context","extra","createPair","toSS58","type","publicKey","meta","encoded","encTypes","decodePkcs8","passphrase","userEncoded","decoded","pair","recode","undefined","encodeAddress","raw","address","addressRaw","slice","decryptMessage","encryptedMessageWithNonce","senderPublicKey","includes","messageU8a","derive","suri","path","derived","encodePkcs8","encryptMessage","message","recipientPublicKey","nonceIn","nonce","sealed","lock","setMeta","additional","sign","options","withType","toJson","unlock","verify","signature","signerPublic","isValid","vrfSign","vrfVerify","vrfResult","result","subarray"],"mappings":"AAAA,OAAOA,eAAP,MAA4B,2CAA5B;;AAEA,SAASC,OAAT,CAAiBC,MAAjB,EAAyBC,cAAzB,EAAyC;AAAE,MAAIC,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYF,MAAZ,CAAX;;AAAgC,MAAIG,MAAM,CAACC,qBAAX,EAAkC;AAAE,QAAIC,OAAO,GAAGF,MAAM,CAACC,qBAAP,CAA6BJ,MAA7B,CAAd;;AAAoD,QAAIC,cAAJ,EAAoB;AAAEI,MAAAA,OAAO,GAAGA,OAAO,CAACC,MAAR,CAAe,UAAUC,GAAV,EAAe;AAAE,eAAOJ,MAAM,CAACK,wBAAP,CAAgCR,MAAhC,EAAwCO,GAAxC,EAA6CE,UAApD;AAAiE,OAAjG,CAAV;AAA+G;;AAACP,IAAAA,IAAI,CAACQ,IAAL,CAAUC,KAAV,CAAgBT,IAAhB,EAAsBG,OAAtB;AAAiC;;AAAC,SAAOH,IAAP;AAAc;;AAEzV,SAASU,aAAT,CAAuBC,MAAvB,EAA+B;AAAE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,SAAS,CAACC,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;AAAE,QAAIG,MAAM,GAAGF,SAAS,CAACD,CAAD,CAAT,IAAgB,IAAhB,GAAuBC,SAAS,CAACD,CAAD,CAAhC,GAAsC,EAAnD;;AAAuD,QAAIA,CAAC,GAAG,CAAR,EAAW;AAAEf,MAAAA,OAAO,CAACI,MAAM,CAACc,MAAD,CAAP,EAAiB,IAAjB,CAAP,CAA8BC,OAA9B,CAAsC,UAAUC,GAAV,EAAe;AAAErB,QAAAA,eAAe,CAACe,MAAD,EAASM,GAAT,EAAcF,MAAM,CAACE,GAAD,CAApB,CAAf;AAA4C,OAAnG;AAAuG,KAApH,MAA0H,IAAIhB,MAAM,CAACiB,yBAAX,EAAsC;AAAEjB,MAAAA,MAAM,CAACkB,gBAAP,CAAwBR,MAAxB,EAAgCV,MAAM,CAACiB,yBAAP,CAAiCH,MAAjC,CAAhC;AAA4E,KAApH,MAA0H;AAAElB,MAAAA,OAAO,CAACI,MAAM,CAACc,MAAD,CAAP,CAAP,CAAwBC,OAAxB,CAAgC,UAAUC,GAAV,EAAe;AAAEhB,QAAAA,MAAM,CAACmB,cAAP,CAAsBT,MAAtB,EAA8BM,GAA9B,EAAmChB,MAAM,CAACK,wBAAP,CAAgCS,MAAhC,EAAwCE,GAAxC,CAAnC;AAAmF,OAApI;AAAwI;AAAE;;AAAC,SAAON,MAAP;AAAgB,C,CAEthB;AACA;;;AACA,SAASU,MAAT,EAAiBC,SAAjB,EAA4BC,KAA5B,EAAmCC,QAAnC,EAA6CC,QAA7C,QAA6D,gBAA7D;AACA,SAASC,WAAT,EAAsBC,4BAAtB,EAAoDC,4BAApD,EAAkFC,cAAlF,EAAkGC,WAAlG,EAA+GC,cAA/G,EAA+HC,WAA/H,EAA4IC,mBAAmB,IAAIC,YAAnK,EAAiLC,QAAjL,EAA2LC,QAA3L,EAAqMC,QAArM,EAA+MC,yBAAyB,IAAIC,kBAA5O,EAAgQC,cAAhQ,EAAgRC,iBAAhR,EAAmSC,mBAAnS,EAAwTC,iBAAxT,EAA2UC,eAA3U,EAA4VC,wBAAwB,IAAIC,iBAAxX,EAA2YC,aAA3Y,EAA0ZC,eAA1Z,QAAib,uBAAjb;AACA,SAASC,UAAT,QAA2B,aAA3B;AACA,SAASC,UAAT,QAA2B,aAA3B;AACA,SAASC,UAAT,QAA2B,aAA3B;AACA,MAAMC,aAAa,GAAG,IAAIC,UAAJ,EAAtB;AACA,MAAMC,cAAc,GAAG;AACrBC,EAAAA,KAAK,EAAET,iBADc;AAErBU,EAAAA,OAAO,EAAEtB,YAFY;AAGrBuB,EAAAA,QAAQ,EAAEX,iBAHW;AAIrBY,EAAAA,OAAO,EAAEnB;AAJY,CAAvB;AAMA,MAAMoB,WAAW,GAAG;AAClBJ,EAAAA,KAAK,EAAE,IAAIF,UAAJ,CAAe,CAAC,CAAD,CAAf,CADW;AAElBG,EAAAA,OAAO,EAAE,IAAIH,UAAJ,CAAe,CAAC,CAAD,CAAf,CAFS;AAGlBI,EAAAA,QAAQ,EAAE,IAAIJ,UAAJ,CAAe,CAAC,CAAD,CAAf,CAHQ;AAIlBK,EAAAA,OAAO,EAAE,IAAIL,UAAJ,CAAe,CAAC,CAAD,CAAf;AAJS,CAApB;AAMA,MAAMO,cAAc,GAAG;AACrBL,EAAAA,KAAK,EAAE,CAACM,CAAD,EAAIC,CAAJ,KAAUf,aAAa,CAACc,CAAD,EAAIC,CAAJ,EAAO,QAAP,CADT;AAErBN,EAAAA,OAAO,EAAEnB,QAFY;AAGrBoB,EAAAA,QAAQ,EAAE,CAACI,CAAD,EAAIC,CAAJ,KAAUf,aAAa,CAACc,CAAD,EAAIC,CAAJ,EAAO,QAAP,CAHZ;AAIrBJ,EAAAA,OAAO,EAAElB;AAJY,CAAvB;AAMA,MAAMuB,YAAY,GAAG;AACnBR,EAAAA,KAAK,EAAEO,CAAC,IAAIA,CAAC,CAAChD,MAAF,GAAW,EAAX,GAAgBY,WAAW,CAACoC,CAAD,CAA3B,GAAiCA,CAD1B;AAEnBN,EAAAA,OAAO,EAAEM,CAAC,IAAIA,CAFK;AAGnBL,EAAAA,QAAQ,EAAEK,CAAC,IAAIA,CAAC,CAAChD,MAAF,KAAa,EAAb,GAAkBgD,CAAlB,GAAsBhC,WAAW,CAACc,eAAe,CAACkB,CAAD,CAAhB,CAH7B;AAInBJ,EAAAA,OAAO,EAAEI,CAAC,IAAIA;AAJK,CAArB,C,CAKG;;AAEH,SAASE,QAAT,CAAkBC,SAAlB,EAA6B;AAC3B,SAAO,CAACA,SAAD,IAAcA,SAAS,CAACnD,MAAV,KAAqB,CAAnC,IAAwCmD,SAAS,CAACC,KAAV,CAAgBC,CAAC,IAAIA,CAAC,KAAK,CAA3B,CAA/C;AACD;;AAED,SAASC,OAAT,CAAiBC,KAAjB,EAAwBC,OAAxB,EAAiCC,KAAjC,EAAwC;AACtC,SAAO7C,WAAW,CAACJ,SAAS,CAACgD,OAAO,IAAI,EAAZ,EAAgBC,KAAK,IAAI,EAAzB,EAA6BF,KAA7B,CAAV,CAAlB;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,OAAO,SAASG,UAAT,CAAoB;AACzBC,EAAAA,MADyB;AAEzBC,EAAAA;AAFyB,CAApB,EAGJ;AACDC,EAAAA,SADC;AAEDV,EAAAA;AAFC,CAHI,EAMJW,IAAI,GAAG,EANH,EAMOC,OAAO,GAAG,IANjB,EAMuBC,QANvB,EAMiC;AACtC,QAAMC,WAAW,GAAG,CAACC,UAAD,EAAaC,WAAb,KAA6B;AAC/C,UAAMC,OAAO,GAAGjC,UAAU,CAAC+B,UAAD,EAAaC,WAAW,IAAIJ,OAA5B,EAAqCC,QAArC,CAA1B;;AAEA,QAAII,OAAO,CAACjB,SAAR,CAAkBnD,MAAlB,KAA6B,EAAjC,EAAqC;AACnC6D,MAAAA,SAAS,GAAGO,OAAO,CAACP,SAApB;AACAV,MAAAA,SAAS,GAAGiB,OAAO,CAACjB,SAApB;AACD,KAHD,MAGO;AACL,YAAMkB,IAAI,GAAG7B,cAAc,CAACoB,IAAD,CAAd,CAAqBQ,OAAO,CAACjB,SAA7B,CAAb;AACAU,MAAAA,SAAS,GAAGQ,IAAI,CAACR,SAAjB;AACAV,MAAAA,SAAS,GAAGkB,IAAI,CAAClB,SAAjB;AACD;AACF,GAXD;;AAaA,QAAMmB,MAAM,GAAGJ,UAAU,IAAI;AAC3BhB,IAAAA,QAAQ,CAACC,SAAD,CAAR,IAAuBY,OAAvB,IAAkCE,WAAW,CAACC,UAAD,EAAaH,OAAb,CAA7C;AACAA,IAAAA,OAAO,GAAG3B,UAAU,CAAC;AACnByB,MAAAA,SADmB;AAEnBV,MAAAA;AAFmB,KAAD,EAGjBe,UAHiB,CAApB,CAF2B,CAKX;;AAEhBF,IAAAA,QAAQ,GAAGO,SAAX,CAP2B,CAOL;;AAEtB,WAAOR,OAAP;AACD,GAVD;;AAYA,QAAMS,aAAa,GAAG,MAAM;AAC1B,UAAMC,GAAG,GAAGxB,YAAY,CAACW,IAAD,CAAZ,CAAmBC,SAAnB,CAAZ;AACA,WAAOD,IAAI,KAAK,UAAT,GAAsB7C,cAAc,CAAC0D,GAAD,CAApC,GAA4Cd,MAAM,CAACc,GAAD,CAAzD;AACD,GAHD;;AAKA,SAAO;AACL,QAAIC,OAAJ,GAAc;AACZ,aAAOF,aAAa,EAApB;AACD,KAHI;;AAKL,QAAIG,UAAJ,GAAiB;AACf,YAAMF,GAAG,GAAGxB,YAAY,CAACW,IAAD,CAAZ,CAAmBC,SAAnB,CAAZ;AACA,aAAOD,IAAI,KAAK,UAAT,GAAsBa,GAAG,CAACG,KAAJ,CAAU,CAAC,EAAX,CAAtB,GAAuCH,GAA9C;AACD,KARI;;AAUL,QAAIvB,QAAJ,GAAe;AACb,aAAOA,QAAQ,CAACC,SAAD,CAAf;AACD,KAZI;;AAcL,QAAIW,IAAJ,GAAW;AACT,aAAOA,IAAP;AACD,KAhBI;;AAkBL,QAAID,SAAJ,GAAgB;AACd,aAAOA,SAAP;AACD,KApBI;;AAsBL,QAAID,IAAJ,GAAW;AACT,aAAOA,IAAP;AACD,KAxBI;;AA0BL;AACAK,IAAAA,WA3BK;AA4BLY,IAAAA,cAAc,EAAE,CAACC,yBAAD,EAA4BC,eAA5B,KAAgD;AAC9DxE,MAAAA,MAAM,CAAC,CAAC2C,QAAQ,CAACC,SAAD,CAAV,EAAuB,uCAAvB,CAAN;AACA5C,MAAAA,MAAM,CAAC,CAAC,CAAC,OAAD,EAAU,UAAV,EAAsByE,QAAtB,CAA+BpB,IAA/B,CAAF,EAAwC,6BAAxC,CAAN;AACA,YAAMqB,UAAU,GAAGtE,QAAQ,CAACmE,yBAAD,CAA3B;AACA,aAAOzD,QAAQ,CAAC4D,UAAU,CAACL,KAAX,CAAiB,EAAjB,EAAqBK,UAAU,CAACjF,MAAhC,CAAD,EAA0CiF,UAAU,CAACL,KAAX,CAAiB,CAAjB,EAAoB,EAApB,CAA1C,EAAmE/D,4BAA4B,CAACF,QAAQ,CAACoE,eAAD,CAAT,CAA/F,EAA4HjE,4BAA4B,CAACqC,SAAD,CAAxJ,CAAf;AACD,KAjCI;AAkCL+B,IAAAA,MAAM,EAAE,CAACC,IAAD,EAAOrB,IAAP,KAAgB;AACtBvD,MAAAA,MAAM,CAACqD,IAAI,KAAK,UAAV,EAAsB,kCAAtB,CAAN;AACArD,MAAAA,MAAM,CAAC,CAAC2C,QAAQ,CAACC,SAAD,CAAV,EAAuB,mCAAvB,CAAN;AACA,YAAM;AACJiC,QAAAA;AADI,UAEFnE,cAAc,CAACkE,IAAD,CAFlB;AAGA,YAAME,OAAO,GAAGnE,WAAW,CAAC;AAC1B2C,QAAAA,SAD0B;AAE1BV,QAAAA;AAF0B,OAAD,EAGxBiC,IAHwB,EAGlBxB,IAHkB,CAA3B;AAIA,aAAOF,UAAU,CAAC;AAChBC,QAAAA,MADgB;AAEhBC,QAAAA;AAFgB,OAAD,EAGdyB,OAHc,EAGLvB,IAHK,EAGC,IAHD,CAAjB;AAID,KAhDI;AAiDLwB,IAAAA,WAAW,EAAEpB,UAAU,IAAI;AACzB,aAAOI,MAAM,CAACJ,UAAD,CAAb;AACD,KAnDI;AAoDLqB,IAAAA,cAAc,EAAE,CAACC,OAAD,EAAUC,kBAAV,EAA8BC,OAA9B,KAA0C;AACxDnF,MAAAA,MAAM,CAAC,CAAC2C,QAAQ,CAACC,SAAD,CAAV,EAAuB,uCAAvB,CAAN;AACA5C,MAAAA,MAAM,CAAC,CAAC,CAAC,OAAD,EAAU,UAAV,EAAsByE,QAAtB,CAA+BpB,IAA/B,CAAF,EAAwC,6BAAxC,CAAN;AACA,YAAM;AACJ+B,QAAAA,KADI;AAEJC,QAAAA;AAFI,UAGFtE,QAAQ,CAACX,QAAQ,CAAC6E,OAAD,CAAT,EAAoB1E,4BAA4B,CAACqC,SAAD,CAAhD,EAA6DtC,4BAA4B,CAACF,QAAQ,CAAC8E,kBAAD,CAAT,CAAzF,EAAyHC,OAAzH,CAHZ;AAIA,aAAOlF,SAAS,CAACmF,KAAD,EAAQC,MAAR,CAAhB;AACD,KA5DI;AA6DLC,IAAAA,IAAI,EAAE,MAAM;AACV1C,MAAAA,SAAS,GAAG,IAAIZ,UAAJ,EAAZ;AACD,KA/DI;AAgELuD,IAAAA,OAAO,EAAEC,UAAU,IAAI;AACrBjC,MAAAA,IAAI,GAAGlE,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKkE,IAAL,CAAd,EAA0BiC,UAA1B,CAApB;AACD,KAlEI;AAmELC,IAAAA,IAAI,EAAE,CAACR,OAAD,EAAUS,OAAO,GAAG,EAApB,KAA2B;AAC/B1F,MAAAA,MAAM,CAAC,CAAC2C,QAAQ,CAACC,SAAD,CAAV,EAAuB,oCAAvB,CAAN;AACA,aAAO3C,SAAS,CAACyF,OAAO,CAACC,QAAR,GAAmBrD,WAAW,CAACe,IAAD,CAA9B,GAAuCtB,aAAxC,EAAuDQ,cAAc,CAACc,IAAD,CAAd,CAAqBjD,QAAQ,CAAC6E,OAAD,CAA7B,EAAwC;AAC7G3B,QAAAA,SAD6G;AAE7GV,QAAAA;AAF6G,OAAxC,CAAvD,CAAhB;AAID,KAzEI;AA0ELgD,IAAAA,MAAM,EAAEjC,UAAU,IAAI;AACpB;AACA;AACA;AACA,YAAMQ,OAAO,GAAG,CAAC,OAAD,EAAU,UAAV,EAAsBM,QAAtB,CAA+BpB,IAA/B,IAAuCC,SAAS,CAAC7D,MAAV,KAAqB,EAArB,GAA0BU,QAAQ,CAACmD,SAAD,CAAlC,GAAgDnD,QAAQ,CAACmB,iBAAiB,CAACgC,SAAD,CAAlB,CAA/F,GAAgIW,aAAa,EAA7J;AACA,aAAOnC,UAAU,CAACuB,IAAD,EAAO;AACtBc,QAAAA,OADsB;AAEtBZ,QAAAA;AAFsB,OAAP,EAGdQ,MAAM,CAACJ,UAAD,CAHQ,EAGM,CAAC,CAACA,UAHR,CAAjB;AAID,KAnFI;AAoFLkC,IAAAA,MAAM,EAAElC,UAAU,IAAI;AACpB,aAAOD,WAAW,CAACC,UAAD,CAAlB;AACD,KAtFI;AAuFLmC,IAAAA,MAAM,EAAE,CAACb,OAAD,EAAUc,SAAV,EAAqBC,YAArB,KAAsC;AAC5C,aAAOrE,eAAe,CAACsD,OAAD,EAAUc,SAAV,EAAqBrD,YAAY,CAACW,IAAD,CAAZ,CAAmBjD,QAAQ,CAAC4F,YAAD,CAA3B,CAArB,CAAf,CAAgFC,OAAvF;AACD,KAzFI;AA0FLC,IAAAA,OAAO,EAAE,CAACjB,OAAD,EAAUhC,OAAV,EAAmBC,KAAnB,KAA6B;AACpClD,MAAAA,MAAM,CAAC,CAAC2C,QAAQ,CAACC,SAAD,CAAV,EAAuB,oCAAvB,CAAN;;AAEA,UAAIS,IAAI,KAAK,SAAb,EAAwB;AACtB,eAAOjC,iBAAiB,CAAC6D,OAAD,EAAU;AAChCrC,UAAAA;AADgC,SAAV,EAErBK,OAFqB,EAEZC,KAFY,CAAxB;AAGD;;AAED,YAAMF,KAAK,GAAGT,cAAc,CAACc,IAAD,CAAd,CAAqBjD,QAAQ,CAAC6E,OAAD,CAA7B,EAAwC;AACpD3B,QAAAA,SADoD;AAEpDV,QAAAA;AAFoD,OAAxC,CAAd;AAIA,aAAO3C,SAAS,CAAC8C,OAAO,CAACC,KAAD,EAAQC,OAAR,EAAiBC,KAAjB,CAAR,EAAiCF,KAAjC,CAAhB;AACD,KAxGI;AAyGLmD,IAAAA,SAAS,EAAE,CAAClB,OAAD,EAAUmB,SAAV,EAAqBJ,YAArB,EAAmC/C,OAAnC,EAA4CC,KAA5C,KAAsD;AAC/D,UAAIG,IAAI,KAAK,SAAb,EAAwB;AACtB,eAAOhC,mBAAmB,CAAC4D,OAAD,EAAUmB,SAAV,EAAqB9C,SAArB,EAAgCL,OAAhC,EAAyCC,KAAzC,CAA1B;AACD;;AAED,YAAMmD,MAAM,GAAG1E,eAAe,CAACsD,OAAD,EAAUhF,SAAS,CAACqC,WAAW,CAACe,IAAD,CAAZ,EAAoB+C,SAAS,CAACE,QAAV,CAAmB,EAAnB,CAApB,CAAnB,EAAgE5D,YAAY,CAACW,IAAD,CAAZ,CAAmBjD,QAAQ,CAAC4F,YAAD,CAA3B,CAAhE,CAA9B;AACA,aAAOK,MAAM,CAACJ,OAAP,IAAkB/F,KAAK,CAACkG,SAAS,CAACE,QAAV,CAAmB,CAAnB,EAAsB,EAAtB,CAAD,EAA4BvD,OAAO,CAACqD,SAAS,CAACE,QAAV,CAAmB,EAAnB,CAAD,EAAyBrD,OAAzB,EAAkCC,KAAlC,CAAnC,CAA9B;AACD;AAhHI,GAAP;AAkHD","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/keyring authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, u8aConcat, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { blake2AsU8a, convertPublicKeyToCurve25519, convertSecretKeyToCurve25519, ethereumEncode, keccakAsU8a, keyExtractPath, keyFromPath, naclKeypairFromSeed as naclFromSeed, naclOpen, naclSeal, naclSign, schnorrkelKeypairFromSeed as schnorrkelFromSeed, schnorrkelSign, schnorrkelVrfSign, schnorrkelVrfVerify, secp256k1Compress, secp256k1Expand, secp256k1KeypairFromSeed as secp256k1FromSeed, secp256k1Sign, signatureVerify } from '@polkadot/util-crypto';\nimport { decodePair } from \"./decode.js\";\nimport { encodePair } from \"./encode.js\";\nimport { pairToJson } from \"./toJson.js\";\nconst SIG_TYPE_NONE = new Uint8Array();\nconst TYPE_FROM_SEED = {\n  ecdsa: secp256k1FromSeed,\n  ed25519: naclFromSeed,\n  ethereum: secp256k1FromSeed,\n  sr25519: schnorrkelFromSeed\n};\nconst TYPE_PREFIX = {\n  ecdsa: new Uint8Array([2]),\n  ed25519: new Uint8Array([0]),\n  ethereum: new Uint8Array([2]),\n  sr25519: new Uint8Array([1])\n};\nconst TYPE_SIGNATURE = {\n  ecdsa: (m, p) => secp256k1Sign(m, p, 'blake2'),\n  ed25519: naclSign,\n  ethereum: (m, p) => secp256k1Sign(m, p, 'keccak'),\n  sr25519: schnorrkelSign\n};\nconst TYPE_ADDRESS = {\n  ecdsa: p => p.length > 32 ? blake2AsU8a(p) : p,\n  ed25519: p => p,\n  ethereum: p => p.length === 20 ? p : keccakAsU8a(secp256k1Expand(p)),\n  sr25519: p => p\n}; // Not 100% correct, since it can be a Uint8Array, but an invalid one - just say \"undefined\" is anything non-valid\n\nfunction isLocked(secretKey) {\n  return !secretKey || secretKey.length === 0 || secretKey.every(b => b === 0);\n}\n\nfunction vrfHash(proof, context, extra) {\n  return blake2AsU8a(u8aConcat(context || '', extra || '', proof));\n}\n/**\n * @name createPair\n * @summary Creates a keyring pair object\n * @description Creates a keyring pair object with provided account public key, metadata, and encoded arguments.\n * The keyring pair stores the account state including the encoded address and associated metadata.\n *\n * It has properties whose values are functions that may be called to perform account actions:\n *\n * - `address` function retrieves the address associated with the account.\n * - `decodedPkcs8` function is called with the account passphrase and account encoded public key.\n * It decodes the encoded public key using the passphrase provided to obtain the decoded account public key\n * and associated secret key that are then available in memory, and changes the account address stored in the\n * state of the pair to correspond to the address of the decoded public key.\n * - `encodePkcs8` function when provided with the correct passphrase associated with the account pair\n * and when the secret key is in memory (when the account pair is not locked) it returns an encoded\n * public key of the account.\n * - `meta` is the metadata that is stored in the state of the pair, either when it was originally\n * created or set via `setMeta`.\n * - `publicKey` returns the public key stored in memory for the pair.\n * - `sign` may be used to return a signature by signing a provided message with the secret\n * key (if it is in memory) using Nacl.\n * - `toJson` calls another `toJson` function and provides the state of the pair,\n * it generates arguments to be passed to the other `toJson` function including an encoded public key of the account\n * that it generates using the secret key from memory (if it has been made available in memory)\n * and the optionally provided passphrase argument. It passes a third boolean argument to `toJson`\n * indicating whether the public key has been encoded or not (if a passphrase argument was provided then it is encoded).\n * The `toJson` function that it calls returns a JSON object with properties including the `address`\n * and `meta` that are assigned with the values stored in the corresponding state variables of the account pair,\n * an `encoded` property that is assigned with the encoded public key in hex format, and an `encoding`\n * property that indicates whether the public key value of the `encoded` property is encoded or not.\n */\n\n\nexport function createPair({\n  toSS58,\n  type\n}, {\n  publicKey,\n  secretKey\n}, meta = {}, encoded = null, encTypes) {\n  const decodePkcs8 = (passphrase, userEncoded) => {\n    const decoded = decodePair(passphrase, userEncoded || encoded, encTypes);\n\n    if (decoded.secretKey.length === 64) {\n      publicKey = decoded.publicKey;\n      secretKey = decoded.secretKey;\n    } else {\n      const pair = TYPE_FROM_SEED[type](decoded.secretKey);\n      publicKey = pair.publicKey;\n      secretKey = pair.secretKey;\n    }\n  };\n\n  const recode = passphrase => {\n    isLocked(secretKey) && encoded && decodePkcs8(passphrase, encoded);\n    encoded = encodePair({\n      publicKey,\n      secretKey\n    }, passphrase); // re-encode, latest version\n\n    encTypes = undefined; // swap to defaults, latest version follows\n\n    return encoded;\n  };\n\n  const encodeAddress = () => {\n    const raw = TYPE_ADDRESS[type](publicKey);\n    return type === 'ethereum' ? ethereumEncode(raw) : toSS58(raw);\n  };\n\n  return {\n    get address() {\n      return encodeAddress();\n    },\n\n    get addressRaw() {\n      const raw = TYPE_ADDRESS[type](publicKey);\n      return type === 'ethereum' ? raw.slice(-20) : raw;\n    },\n\n    get isLocked() {\n      return isLocked(secretKey);\n    },\n\n    get meta() {\n      return meta;\n    },\n\n    get publicKey() {\n      return publicKey;\n    },\n\n    get type() {\n      return type;\n    },\n\n    // eslint-disable-next-line sort-keys\n    decodePkcs8,\n    decryptMessage: (encryptedMessageWithNonce, senderPublicKey) => {\n      assert(!isLocked(secretKey), 'Cannot encrypt with a locked key pair');\n      assert(!['ecdsa', 'ethereum'].includes(type), 'Secp256k1 not supported yet');\n      const messageU8a = u8aToU8a(encryptedMessageWithNonce);\n      return naclOpen(messageU8a.slice(24, messageU8a.length), messageU8a.slice(0, 24), convertPublicKeyToCurve25519(u8aToU8a(senderPublicKey)), convertSecretKeyToCurve25519(secretKey));\n    },\n    derive: (suri, meta) => {\n      assert(type !== 'ethereum', 'Unable to derive on this keypair');\n      assert(!isLocked(secretKey), 'Cannot derive on a locked keypair');\n      const {\n        path\n      } = keyExtractPath(suri);\n      const derived = keyFromPath({\n        publicKey,\n        secretKey\n      }, path, type);\n      return createPair({\n        toSS58,\n        type\n      }, derived, meta, null);\n    },\n    encodePkcs8: passphrase => {\n      return recode(passphrase);\n    },\n    encryptMessage: (message, recipientPublicKey, nonceIn) => {\n      assert(!isLocked(secretKey), 'Cannot encrypt with a locked key pair');\n      assert(!['ecdsa', 'ethereum'].includes(type), 'Secp256k1 not supported yet');\n      const {\n        nonce,\n        sealed\n      } = naclSeal(u8aToU8a(message), convertSecretKeyToCurve25519(secretKey), convertPublicKeyToCurve25519(u8aToU8a(recipientPublicKey)), nonceIn);\n      return u8aConcat(nonce, sealed);\n    },\n    lock: () => {\n      secretKey = new Uint8Array();\n    },\n    setMeta: additional => {\n      meta = _objectSpread(_objectSpread({}, meta), additional);\n    },\n    sign: (message, options = {}) => {\n      assert(!isLocked(secretKey), 'Cannot sign with a locked key pair');\n      return u8aConcat(options.withType ? TYPE_PREFIX[type] : SIG_TYPE_NONE, TYPE_SIGNATURE[type](u8aToU8a(message), {\n        publicKey,\n        secretKey\n      }));\n    },\n    toJson: passphrase => {\n      // NOTE: For ecdsa and ethereum, the publicKey cannot be extracted from the address. For these\n      // pass the hex-encoded publicKey through to the address portion of the JSON (before decoding)\n      // unless the publicKey is already an address\n      const address = ['ecdsa', 'ethereum'].includes(type) ? publicKey.length === 20 ? u8aToHex(publicKey) : u8aToHex(secp256k1Compress(publicKey)) : encodeAddress();\n      return pairToJson(type, {\n        address,\n        meta\n      }, recode(passphrase), !!passphrase);\n    },\n    unlock: passphrase => {\n      return decodePkcs8(passphrase);\n    },\n    verify: (message, signature, signerPublic) => {\n      return signatureVerify(message, signature, TYPE_ADDRESS[type](u8aToU8a(signerPublic))).isValid;\n    },\n    vrfSign: (message, context, extra) => {\n      assert(!isLocked(secretKey), 'Cannot sign with a locked key pair');\n\n      if (type === 'sr25519') {\n        return schnorrkelVrfSign(message, {\n          secretKey\n        }, context, extra);\n      }\n\n      const proof = TYPE_SIGNATURE[type](u8aToU8a(message), {\n        publicKey,\n        secretKey\n      });\n      return u8aConcat(vrfHash(proof, context, extra), proof);\n    },\n    vrfVerify: (message, vrfResult, signerPublic, context, extra) => {\n      if (type === 'sr25519') {\n        return schnorrkelVrfVerify(message, vrfResult, publicKey, context, extra);\n      }\n\n      const result = signatureVerify(message, u8aConcat(TYPE_PREFIX[type], vrfResult.subarray(32)), TYPE_ADDRESS[type](u8aToU8a(signerPublic)));\n      return result.isValid && u8aEq(vrfResult.subarray(0, 32), vrfHash(vrfResult.subarray(32), context, extra));\n    }\n  };\n}"]},"metadata":{},"sourceType":"module"}