{"ast":null,"code":"var baddress = require('./address');\n\nvar bcrypto = require('./crypto');\n\nvar ecdsa = require('./ecdsa');\n\nvar schnorr = require('./schnorr');\n\nvar randomBytes = require('randombytes');\n\nvar typeforce = require('typeforce');\n\nvar types = require('./types');\n\nvar wif = require('wif');\n\nvar ECSignature = require('./ecsignature');\n\nvar NETWORKS = require('./networks');\n\nvar BigInteger = require('bigi');\n\nvar ecurve = require('ecurve');\n\nvar secp256k1 = ecdsa.__curve;\n\nfunction ECPair(d, Q, options) {\n  if (options) {\n    typeforce({\n      compressed: types.maybe(types.Boolean),\n      network: types.maybe(types.Network)\n    }, options);\n  }\n\n  options = options || {};\n\n  if (d) {\n    if (d.signum() <= 0) throw new Error('Private key must be greater than 0');\n    if (d.compareTo(secp256k1.n) >= 0) throw new Error('Private key must be less than the curve order');\n    if (Q) throw new TypeError('Unexpected publicKey parameter');\n    this.d = d;\n  } else {\n    typeforce(types.ECPoint, Q);\n    this.__Q = Q;\n  }\n\n  this.compressed = options.compressed === undefined ? true : options.compressed;\n  this.network = options.network || NETWORKS.bitcoin;\n}\n\nObject.defineProperty(ECPair.prototype, 'Q', {\n  get: function () {\n    if (!this.__Q && this.d) {\n      this.__Q = secp256k1.G.multiply(this.d);\n    }\n\n    return this.__Q;\n  }\n});\n\nECPair.fromPublicKeyBuffer = function (buffer, network) {\n  var Q = ecurve.Point.decodeFrom(secp256k1, buffer);\n  return new ECPair(null, Q, {\n    compressed: Q.compressed,\n    network: network\n  });\n};\n\nECPair.fromWIF = function (string, network) {\n  var decoded = wif.decode(string);\n  var version = decoded.version; // list of networks?\n\n  if (types.Array(network)) {\n    network = network.filter(function (x) {\n      return version === x.wif;\n    }).pop();\n    if (!network) throw new Error('Unknown network version'); // otherwise, assume a network object (or default to bitcoin)\n  } else {\n    network = network || NETWORKS.bitcoin;\n    if (version !== network.wif) throw new Error('Invalid network version');\n  }\n\n  var d = BigInteger.fromBuffer(decoded.privateKey);\n  return new ECPair(d, null, {\n    compressed: decoded.compressed,\n    network: network\n  });\n};\n\nECPair.makeRandom = function (options) {\n  options = options || {};\n  var rng = options.rng || randomBytes;\n  var d;\n\n  do {\n    var buffer = rng(32);\n    typeforce(types.Buffer256bit, buffer);\n    d = BigInteger.fromBuffer(buffer);\n  } while (d.signum() <= 0 || d.compareTo(secp256k1.n) >= 0);\n\n  return new ECPair(d, null, options);\n};\n\nECPair.prototype.getAddress = function () {\n  return baddress.toBase58Check(bcrypto.hash160(this.getPublicKeyBuffer()), this.getNetwork().pubKeyHash);\n};\n\nECPair.prototype.getNetwork = function () {\n  return this.network;\n};\n\nECPair.prototype.getPublicKeyBuffer = function () {\n  return this.Q.getEncoded(this.compressed);\n};\n\nECPair.prototype.sign = function (hash, signatureAlgorithm) {\n  if (!this.d) throw new Error('Missing private key');\n  if (!signatureAlgorithm) signatureAlgorithm = ECSignature.ECDSA;\n\n  if (signatureAlgorithm === ECSignature.ECDSA) {\n    return ecdsa.sign(hash, this.d);\n  } else if (signatureAlgorithm === ECSignature.SCHNORR) {\n    return schnorr.sign(hash, this.d);\n  }\n};\n\nECPair.prototype.toWIF = function () {\n  if (!this.d) throw new Error('Missing private key');\n  return wif.encode(this.network.wif, this.d.toBuffer(32), this.compressed);\n};\n\nECPair.prototype.verify = function (hash, signature) {\n  return ecdsa.verify(hash, signature, this.Q);\n};\n\nmodule.exports = ECPair;","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@psf/bitcoincashjs-lib/src/ecpair.js"],"names":["baddress","require","bcrypto","ecdsa","schnorr","randomBytes","typeforce","types","wif","ECSignature","NETWORKS","BigInteger","ecurve","secp256k1","__curve","ECPair","d","Q","options","compressed","maybe","Boolean","network","Network","signum","Error","compareTo","n","TypeError","ECPoint","__Q","undefined","bitcoin","Object","defineProperty","prototype","get","G","multiply","fromPublicKeyBuffer","buffer","Point","decodeFrom","fromWIF","string","decoded","decode","version","Array","filter","x","pop","fromBuffer","privateKey","makeRandom","rng","Buffer256bit","getAddress","toBase58Check","hash160","getPublicKeyBuffer","getNetwork","pubKeyHash","getEncoded","sign","hash","signatureAlgorithm","ECDSA","SCHNORR","toWIF","encode","toBuffer","verify","signature","module","exports"],"mappings":"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","sourcesContent":["var baddress = require('./address')\nvar bcrypto = require('./crypto')\nvar ecdsa = require('./ecdsa')\nvar schnorr = require('./schnorr')\nvar randomBytes = require('randombytes')\nvar typeforce = require('typeforce')\nvar types = require('./types')\nvar wif = require('wif')\nvar ECSignature = require('./ecsignature')\n\nvar NETWORKS = require('./networks')\nvar BigInteger = require('bigi')\n\nvar ecurve = require('ecurve')\nvar secp256k1 = ecdsa.__curve\n\nfunction ECPair (d, Q, options) {\n  if (options) {\n    typeforce({\n      compressed: types.maybe(types.Boolean),\n      network: types.maybe(types.Network)\n    }, options)\n  }\n\n  options = options || {}\n\n  if (d) {\n    if (d.signum() <= 0) throw new Error('Private key must be greater than 0')\n    if (d.compareTo(secp256k1.n) >= 0) throw new Error('Private key must be less than the curve order')\n    if (Q) throw new TypeError('Unexpected publicKey parameter')\n\n    this.d = d\n  } else {\n    typeforce(types.ECPoint, Q)\n\n    this.__Q = Q\n  }\n\n  this.compressed = options.compressed === undefined ? true : options.compressed\n  this.network = options.network || NETWORKS.bitcoin\n}\n\nObject.defineProperty(ECPair.prototype, 'Q', {\n  get: function () {\n    if (!this.__Q && this.d) {\n      this.__Q = secp256k1.G.multiply(this.d)\n    }\n\n    return this.__Q\n  }\n})\n\nECPair.fromPublicKeyBuffer = function (buffer, network) {\n  var Q = ecurve.Point.decodeFrom(secp256k1, buffer)\n\n  return new ECPair(null, Q, {\n    compressed: Q.compressed,\n    network: network\n  })\n}\n\nECPair.fromWIF = function (string, network) {\n  var decoded = wif.decode(string)\n  var version = decoded.version\n\n  // list of networks?\n  if (types.Array(network)) {\n    network = network.filter(function (x) {\n      return version === x.wif\n    }).pop()\n\n    if (!network) throw new Error('Unknown network version')\n\n  // otherwise, assume a network object (or default to bitcoin)\n  } else {\n    network = network || NETWORKS.bitcoin\n\n    if (version !== network.wif) throw new Error('Invalid network version')\n  }\n\n  var d = BigInteger.fromBuffer(decoded.privateKey)\n\n  return new ECPair(d, null, {\n    compressed: decoded.compressed,\n    network: network\n  })\n}\n\nECPair.makeRandom = function (options) {\n  options = options || {}\n\n  var rng = options.rng || randomBytes\n\n  var d\n  do {\n    var buffer = rng(32)\n    typeforce(types.Buffer256bit, buffer)\n\n    d = BigInteger.fromBuffer(buffer)\n  } while (d.signum() <= 0 || d.compareTo(secp256k1.n) >= 0)\n\n  return new ECPair(d, null, options)\n}\n\nECPair.prototype.getAddress = function () {\n  return baddress.toBase58Check(bcrypto.hash160(this.getPublicKeyBuffer()), this.getNetwork().pubKeyHash)\n}\n\nECPair.prototype.getNetwork = function () {\n  return this.network\n}\n\nECPair.prototype.getPublicKeyBuffer = function () {\n  return this.Q.getEncoded(this.compressed)\n}\n\nECPair.prototype.sign = function (hash, signatureAlgorithm) {\n  if (!this.d) throw new Error('Missing private key')\n  if (!signatureAlgorithm) signatureAlgorithm = ECSignature.ECDSA\n\n  if(signatureAlgorithm === ECSignature.ECDSA){\n    return ecdsa.sign(hash, this.d)\n  } else if(signatureAlgorithm === ECSignature.SCHNORR){\n    return schnorr.sign(hash, this.d)\n  }\n}\n\nECPair.prototype.toWIF = function () {\n  if (!this.d) throw new Error('Missing private key')\n\n  return wif.encode(this.network.wif, this.d.toBuffer(32), this.compressed)\n}\n\nECPair.prototype.verify = function (hash, signature) {\n  return ecdsa.verify(hash, signature, this.Q)\n}\n\nmodule.exports = ECPair\n"]},"metadata":{},"sourceType":"script"}