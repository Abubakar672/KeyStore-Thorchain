{"ast":null,"code":"import _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\"; // Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\nimport { assert, BN, BN_BILLION, BN_HUNDRED, BN_MILLION, BN_QUINTILL, BN_ZERO, bnToBn, bnToHex, bnToU8a, formatBalance, formatNumber, hexToBn, isHex, isString, isU8a, stringify, u8aToBn } from '@polkadot/util';\nexport const DEFAULT_UINT_BITS = 64; // Maximum allowed integer for JS is 2^53 - 1, set limit at 52\n// In this case however, we always print any >32 as hex\n\nconst MAX_NUMBER_BITS = 52;\nconst MUL_P = new BN(10000);\nconst FORMATTERS = [['Perquintill', BN_QUINTILL], ['Perbill', BN_BILLION], ['Permill', BN_MILLION], ['Percent', BN_HUNDRED]];\n\nfunction toPercentage(value, divisor) {\n  return `${(value.mul(MUL_P).div(divisor).toNumber() / 100).toFixed(2)}%`;\n}\n/** @internal */\n\n\nfunction decodeAbstracIntU8a(value, bitLength, isNegative) {\n  if (!value.length) {\n    return '0';\n  }\n\n  try {\n    // NOTE When passing u8a in (typically from decoded data), it is always Little Endian\n    return u8aToBn(value.subarray(0, bitLength / 8), {\n      isLe: true,\n      isNegative\n    }).toString();\n  } catch (error) {\n    throw new Error(`AbstractInt: failed on ${stringify(value)}:: ${error.message}`);\n  }\n}\n/** @internal */\n\n\nfunction decodeAbstractInt(value, bitLength, isNegative) {\n  // This function returns a string, which will be passed in the BN\n  // constructor. It would be ideal to actually return a BN, but there's a\n  // bug: https://github.com/indutny/bn.js/issues/206.\n  if (isHex(value, -1, true)) {\n    return hexToBn(value, {\n      isLe: false,\n      isNegative\n    }).toString();\n  } else if (isU8a(value)) {\n    return decodeAbstracIntU8a(value, bitLength, isNegative);\n  } else if (isString(value)) {\n    return new BN(value.toString(), 10).toString();\n  }\n\n  return bnToBn(value).toString();\n}\n/**\n * @name AbstractInt\n * @ignore\n * @noInheritDoc\n */\n\n\nvar _bitLength = /*#__PURE__*/_classPrivateFieldLooseKey(\"bitLength\");\n\nvar _isSigned = /*#__PURE__*/_classPrivateFieldLooseKey(\"isSigned\");\n\nexport class AbstractInt extends BN {\n  constructor(registry, value = 0, bitLength = DEFAULT_UINT_BITS, isSigned = false) {\n    super(decodeAbstractInt(value, bitLength, isSigned));\n    this.registry = void 0;\n    this.createdAtHash = void 0;\n    Object.defineProperty(this, _bitLength, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _isSigned, {\n      writable: true,\n      value: void 0\n    });\n    this.registry = registry;\n    _classPrivateFieldLooseBase(this, _bitLength)[_bitLength] = bitLength;\n    _classPrivateFieldLooseBase(this, _isSigned)[_isSigned] = isSigned;\n    const isPositive = this.gte(BN_ZERO);\n    const maxBits = bitLength - (isSigned && isPositive ? 1 : 0);\n    assert(isSigned || isPositive, () => `${this.toRawType()}: Negative number passed to unsigned type`);\n    assert(super.bitLength() <= maxBits, () => `${this.toRawType()}: Input too large. Found input with ${super.bitLength()} bits, expected ${maxBits}`);\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return _classPrivateFieldLooseBase(this, _bitLength)[_bitLength] / 8;\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n\n\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Checks if the value is a zero value (align elsewhere)\n   */\n\n\n  get isEmpty() {\n    return this.isZero();\n  }\n  /**\n   * @description Checks if the value is an unsigned type\n   */\n\n\n  get isUnsigned() {\n    return !_classPrivateFieldLooseBase(this, _isSigned)[_isSigned];\n  }\n  /**\n   * @description Returns the number of bits in the value\n   */\n\n\n  bitLength() {\n    return _classPrivateFieldLooseBase(this, _bitLength)[_bitLength];\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  eq(other) {\n    // Here we are actually overriding the built-in .eq to take care of both\n    // number and BN inputs (no `.eqn` needed) - numbers will be converted\n    return super.eq(isHex(other) ? hexToBn(other.toString(), {\n      isLe: false,\n      isNegative: _classPrivateFieldLooseBase(this, _isSigned)[_isSigned]\n    }) : bnToBn(other));\n  }\n  /**\n   * @description True if this value is the max of the type\n   */\n\n\n  isMax() {\n    const u8a = this.toU8a().filter(b => b === 0xff);\n    return u8a.length === _classPrivateFieldLooseBase(this, _bitLength)[_bitLength] / 8;\n  }\n  /**\n   * @description Returns a BigInt representation of the number\n   */\n\n\n  toBigInt() {\n    return BigInt(this.toString());\n  }\n  /**\n   * @description Returns the BN representation of the number. (Compatibility)\n   */\n\n\n  toBn() {\n    return this;\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n\n\n  toHex(isLe = false) {\n    // For display/JSON, this is BE, for compare, use isLe\n    return bnToHex(this, {\n      bitLength: this.bitLength(),\n      isLe,\n      isNegative: !this.isUnsigned\n    });\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  toHuman(isExpanded) {\n    const rawType = this.toRawType();\n\n    if (rawType === 'Balance') {\n      return this.isMax() ? 'everything' // FIXME In the case of multiples we need some way of detecting which instance this belongs\n      // to. as it stands we will always format (incorrectly) against the first token defined\n      : formatBalance(this, {\n        decimals: this.registry.chainDecimals[0],\n        withSi: true,\n        withUnit: this.registry.chainTokens[0]\n      });\n    }\n\n    const [, divisor] = FORMATTERS.find(([type]) => type === rawType) || [];\n    return divisor ? toPercentage(this, divisor) : formatNumber(this);\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n\n\n  toJSON(onlyHex = false) {\n    // FIXME this return type should by string | number, however BN returns string\n    // Options here are\n    //   - super.bitLength() - the actual used bits\n    //   - this.#bitLength - the type bits (this should be used, however contracts RPC is problematic)\n    return onlyHex || super.bitLength() > MAX_NUMBER_BITS ? this.toHex() : this.toNumber();\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    // NOTE In the case of balances, which have a special meaning on the UI\n    // and can be interpreted differently, return a specific value for it so\n    // underlying it always matches (no matter which length it actually is)\n    return this instanceof this.registry.createClass('Balance') ? 'Balance' : `${this.isUnsigned ? 'u' : 'i'}${this.bitLength()}`;\n  }\n  /**\n   * @description Returns the string representation of the value\n   * @param base The base to use for the conversion\n   */\n\n\n  toString(base) {\n    // only included here since we do not inherit docs\n    return super.toString(base);\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  toU8a(isBare) {\n    return bnToU8a(this, {\n      bitLength: this.bitLength(),\n      isLe: true,\n      isNegative: !this.isUnsigned\n    });\n  }\n\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/types/codec/AbstractInt.js"],"names":["_classPrivateFieldLooseBase","_classPrivateFieldLooseKey","assert","BN","BN_BILLION","BN_HUNDRED","BN_MILLION","BN_QUINTILL","BN_ZERO","bnToBn","bnToHex","bnToU8a","formatBalance","formatNumber","hexToBn","isHex","isString","isU8a","stringify","u8aToBn","DEFAULT_UINT_BITS","MAX_NUMBER_BITS","MUL_P","FORMATTERS","toPercentage","value","divisor","mul","div","toNumber","toFixed","decodeAbstracIntU8a","bitLength","isNegative","length","subarray","isLe","toString","error","Error","message","decodeAbstractInt","_bitLength","_isSigned","AbstractInt","constructor","registry","isSigned","createdAtHash","Object","defineProperty","writable","isPositive","gte","maxBits","toRawType","encodedLength","hash","toU8a","isEmpty","isZero","isUnsigned","eq","other","isMax","u8a","filter","b","toBigInt","BigInt","toBn","toHex","toHuman","isExpanded","rawType","decimals","chainDecimals","withSi","withUnit","chainTokens","find","type","toJSON","onlyHex","createClass","base","isBare"],"mappings":"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","sourcesContent":["import _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, BN, BN_BILLION, BN_HUNDRED, BN_MILLION, BN_QUINTILL, BN_ZERO, bnToBn, bnToHex, bnToU8a, formatBalance, formatNumber, hexToBn, isHex, isString, isU8a, stringify, u8aToBn } from '@polkadot/util';\nexport const DEFAULT_UINT_BITS = 64; // Maximum allowed integer for JS is 2^53 - 1, set limit at 52\n// In this case however, we always print any >32 as hex\n\nconst MAX_NUMBER_BITS = 52;\nconst MUL_P = new BN(10000);\nconst FORMATTERS = [['Perquintill', BN_QUINTILL], ['Perbill', BN_BILLION], ['Permill', BN_MILLION], ['Percent', BN_HUNDRED]];\n\nfunction toPercentage(value, divisor) {\n  return `${(value.mul(MUL_P).div(divisor).toNumber() / 100).toFixed(2)}%`;\n}\n/** @internal */\n\n\nfunction decodeAbstracIntU8a(value, bitLength, isNegative) {\n  if (!value.length) {\n    return '0';\n  }\n\n  try {\n    // NOTE When passing u8a in (typically from decoded data), it is always Little Endian\n    return u8aToBn(value.subarray(0, bitLength / 8), {\n      isLe: true,\n      isNegative\n    }).toString();\n  } catch (error) {\n    throw new Error(`AbstractInt: failed on ${stringify(value)}:: ${error.message}`);\n  }\n}\n/** @internal */\n\n\nfunction decodeAbstractInt(value, bitLength, isNegative) {\n  // This function returns a string, which will be passed in the BN\n  // constructor. It would be ideal to actually return a BN, but there's a\n  // bug: https://github.com/indutny/bn.js/issues/206.\n  if (isHex(value, -1, true)) {\n    return hexToBn(value, {\n      isLe: false,\n      isNegative\n    }).toString();\n  } else if (isU8a(value)) {\n    return decodeAbstracIntU8a(value, bitLength, isNegative);\n  } else if (isString(value)) {\n    return new BN(value.toString(), 10).toString();\n  }\n\n  return bnToBn(value).toString();\n}\n/**\n * @name AbstractInt\n * @ignore\n * @noInheritDoc\n */\n\n\nvar _bitLength = /*#__PURE__*/_classPrivateFieldLooseKey(\"bitLength\");\n\nvar _isSigned = /*#__PURE__*/_classPrivateFieldLooseKey(\"isSigned\");\n\nexport class AbstractInt extends BN {\n  constructor(registry, value = 0, bitLength = DEFAULT_UINT_BITS, isSigned = false) {\n    super(decodeAbstractInt(value, bitLength, isSigned));\n    this.registry = void 0;\n    this.createdAtHash = void 0;\n    Object.defineProperty(this, _bitLength, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _isSigned, {\n      writable: true,\n      value: void 0\n    });\n    this.registry = registry;\n    _classPrivateFieldLooseBase(this, _bitLength)[_bitLength] = bitLength;\n    _classPrivateFieldLooseBase(this, _isSigned)[_isSigned] = isSigned;\n    const isPositive = this.gte(BN_ZERO);\n    const maxBits = bitLength - (isSigned && isPositive ? 1 : 0);\n    assert(isSigned || isPositive, () => `${this.toRawType()}: Negative number passed to unsigned type`);\n    assert(super.bitLength() <= maxBits, () => `${this.toRawType()}: Input too large. Found input with ${super.bitLength()} bits, expected ${maxBits}`);\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return _classPrivateFieldLooseBase(this, _bitLength)[_bitLength] / 8;\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n\n\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Checks if the value is a zero value (align elsewhere)\n   */\n\n\n  get isEmpty() {\n    return this.isZero();\n  }\n  /**\n   * @description Checks if the value is an unsigned type\n   */\n\n\n  get isUnsigned() {\n    return !_classPrivateFieldLooseBase(this, _isSigned)[_isSigned];\n  }\n  /**\n   * @description Returns the number of bits in the value\n   */\n\n\n  bitLength() {\n    return _classPrivateFieldLooseBase(this, _bitLength)[_bitLength];\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  eq(other) {\n    // Here we are actually overriding the built-in .eq to take care of both\n    // number and BN inputs (no `.eqn` needed) - numbers will be converted\n    return super.eq(isHex(other) ? hexToBn(other.toString(), {\n      isLe: false,\n      isNegative: _classPrivateFieldLooseBase(this, _isSigned)[_isSigned]\n    }) : bnToBn(other));\n  }\n  /**\n   * @description True if this value is the max of the type\n   */\n\n\n  isMax() {\n    const u8a = this.toU8a().filter(b => b === 0xff);\n    return u8a.length === _classPrivateFieldLooseBase(this, _bitLength)[_bitLength] / 8;\n  }\n  /**\n   * @description Returns a BigInt representation of the number\n   */\n\n\n  toBigInt() {\n    return BigInt(this.toString());\n  }\n  /**\n   * @description Returns the BN representation of the number. (Compatibility)\n   */\n\n\n  toBn() {\n    return this;\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n\n\n  toHex(isLe = false) {\n    // For display/JSON, this is BE, for compare, use isLe\n    return bnToHex(this, {\n      bitLength: this.bitLength(),\n      isLe,\n      isNegative: !this.isUnsigned\n    });\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  toHuman(isExpanded) {\n    const rawType = this.toRawType();\n\n    if (rawType === 'Balance') {\n      return this.isMax() ? 'everything' // FIXME In the case of multiples we need some way of detecting which instance this belongs\n      // to. as it stands we will always format (incorrectly) against the first token defined\n      : formatBalance(this, {\n        decimals: this.registry.chainDecimals[0],\n        withSi: true,\n        withUnit: this.registry.chainTokens[0]\n      });\n    }\n\n    const [, divisor] = FORMATTERS.find(([type]) => type === rawType) || [];\n    return divisor ? toPercentage(this, divisor) : formatNumber(this);\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n\n\n  toJSON(onlyHex = false) {\n    // FIXME this return type should by string | number, however BN returns string\n    // Options here are\n    //   - super.bitLength() - the actual used bits\n    //   - this.#bitLength - the type bits (this should be used, however contracts RPC is problematic)\n    return onlyHex || super.bitLength() > MAX_NUMBER_BITS ? this.toHex() : this.toNumber();\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    // NOTE In the case of balances, which have a special meaning on the UI\n    // and can be interpreted differently, return a specific value for it so\n    // underlying it always matches (no matter which length it actually is)\n    return this instanceof this.registry.createClass('Balance') ? 'Balance' : `${this.isUnsigned ? 'u' : 'i'}${this.bitLength()}`;\n  }\n  /**\n   * @description Returns the string representation of the value\n   * @param base The base to use for the conversion\n   */\n\n\n  toString(base) {\n    // only included here since we do not inherit docs\n    return super.toString(base);\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  toU8a(isBare) {\n    return bnToU8a(this, {\n      bitLength: this.bitLength(),\n      isLe: true,\n      isNegative: !this.isUnsigned\n    });\n  }\n\n}"]},"metadata":{},"sourceType":"module"}