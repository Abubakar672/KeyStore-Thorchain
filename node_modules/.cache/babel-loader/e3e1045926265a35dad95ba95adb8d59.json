{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { assert, compactAddLength, compactFromU8a, isHex, isU8a, u8aConcat, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { Base } from \"../codec/Base.js\";\nimport { BIT_SIGNED, BIT_UNSIGNED, DEFAULT_VERSION, UNMASK_VERSION } from \"./constants.js\";\nconst VERSIONS = ['ExtrinsicUnknown', // v0 is unknown\n'ExtrinsicUnknown', 'ExtrinsicUnknown', 'ExtrinsicUnknown', 'ExtrinsicV4'];\nexport { EXTRINSIC_VERSION as LATEST_EXTRINSIC_VERSION } from \"./v4/Extrinsic.js\";\n\nclass ExtrinsicBase extends Base {\n  /**\n   * @description The arguments passed to for the call, exposes args so it is compatible with [[Call]]\n   */\n  get args() {\n    return this.method.args;\n  }\n  /**\n   * @description The argument definitions, compatible with [[Call]]\n   */\n\n\n  get argsDef() {\n    return this.method.argsDef;\n  }\n  /**\n   * @description The actual `[sectionIndex, methodIndex]` as used in the Call\n   */\n\n\n  get callIndex() {\n    return this.method.callIndex;\n  }\n  /**\n   * @description The actual data for the Call\n   */\n\n\n  get data() {\n    return this.method.data;\n  }\n  /**\n   * @description The era for this extrinsic\n   */\n\n\n  get era() {\n    return this._raw.signature.era;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return this.toU8a().length;\n  }\n  /**\n   * @description `true` id the extrinsic is signed\n   */\n\n\n  get isSigned() {\n    return this._raw.signature.isSigned;\n  }\n  /**\n   * @description The length of the actual data, excluding prefix\n   */\n\n\n  get length() {\n    return this.toU8a(true).length;\n  }\n  /**\n   * @description The [[FunctionMetadataLatest]] that describes the extrinsic\n   */\n\n\n  get meta() {\n    return this.method.meta;\n  }\n  /**\n   * @description The [[Call]] this extrinsic wraps\n   */\n\n\n  get method() {\n    return this._raw.method;\n  }\n  /**\n   * @description The nonce for this extrinsic\n   */\n\n\n  get nonce() {\n    return this._raw.signature.nonce;\n  }\n  /**\n   * @description The actual [[EcdsaSignature]], [[Ed25519Signature]] or [[Sr25519Signature]]\n   */\n\n\n  get signature() {\n    return this._raw.signature.signature;\n  }\n  /**\n   * @description The [[Address]] that signed\n   */\n\n\n  get signer() {\n    return this._raw.signature.signer;\n  }\n  /**\n   * @description Forwards compat\n   */\n\n\n  get tip() {\n    return this._raw.signature.tip;\n  }\n  /**\n   * @description Returns the raw transaction version (not flagged with signing information)\n  */\n\n\n  get type() {\n    return this._raw.version;\n  }\n  /**\n   * @description Returns the encoded version flag\n  */\n\n\n  get version() {\n    return this.type | (this.isSigned ? BIT_SIGNED : BIT_UNSIGNED);\n  }\n  /**\n   * @description Checks if the source matches this in type\n   */\n\n\n  is(other) {\n    return this.method.is(other);\n  }\n\n}\n/**\n * @name GenericExtrinsic\n * @description\n * Representation of an Extrinsic in the system. It contains the actual call,\n * (optional) signature and encodes with an actual length prefix\n *\n * {@link https://github.com/paritytech/wiki/blob/master/Extrinsic.md#the-extrinsic-format-for-node}.\n *\n * Can be:\n * - signed, to create a transaction\n * - left as is, to create an inherent\n */\n\n\nexport class GenericExtrinsic extends ExtrinsicBase {\n  constructor(registry, value, {\n    version\n  } = {}) {\n    super(registry, GenericExtrinsic._decodeExtrinsic(registry, value, version));\n  }\n  /** @internal */\n\n\n  static _newFromValue(registry, value, version) {\n    if (value instanceof GenericExtrinsic) {\n      return value._raw;\n    }\n\n    const isSigned = (version & BIT_SIGNED) === BIT_SIGNED;\n    const type = VERSIONS[version & UNMASK_VERSION] || VERSIONS[0]; // we cast here since the VERSION definition is incredibly broad - we don't have a\n    // slice for \"only add extrinsic types\", and more string definitions become unwieldy\n\n    return registry.createType(type, value, {\n      isSigned,\n      version\n    });\n  }\n  /** @internal */\n\n\n  static _decodeExtrinsic(registry, value, version = DEFAULT_VERSION) {\n    if (isU8a(value) || Array.isArray(value) || isHex(value)) {\n      return GenericExtrinsic._decodeU8a(registry, u8aToU8a(value), version);\n    } else if (value instanceof registry.createClass('Call')) {\n      return GenericExtrinsic._newFromValue(registry, {\n        method: value\n      }, version);\n    }\n\n    return GenericExtrinsic._newFromValue(registry, value, version);\n  }\n  /** @internal */\n\n\n  static _decodeU8a(registry, value, version) {\n    if (!value.length) {\n      return GenericExtrinsic._newFromValue(registry, new Uint8Array(), version);\n    }\n\n    const [offset, length] = compactFromU8a(value);\n    const total = offset + length.toNumber();\n    assert(total <= value.length, () => `Extrinsic: length less than remainder, expected at least ${total}, found ${value.length}`);\n    const data = value.subarray(offset, total);\n    return GenericExtrinsic._newFromValue(registry, data.subarray(1), data[0]);\n  }\n  /**\n   * @description Injects an already-generated signature into the extrinsic\n   */\n\n\n  addSignature(signer, signature, payload) {\n    this._raw.addSignature(signer, signature, payload);\n\n    return this;\n  }\n  /**\n   * @description Sign the extrinsic with a specific keypair\n   */\n\n\n  sign(account, options) {\n    this._raw.sign(account, options);\n\n    return this;\n  }\n  /**\n   * @describe Adds a fake signature to the extrinsic\n   */\n\n\n  signFake(signer, options) {\n    this._raw.signFake(signer, options);\n\n    return this;\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n\n\n  toHex(isBare) {\n    return u8aToHex(this.toU8a(isBare));\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman(isExpanded) {\n    return _objectSpread({\n      isSigned: this.isSigned,\n      method: this.method.toHuman(isExpanded)\n    }, this.isSigned ? {\n      era: this.era.toHuman(isExpanded),\n      nonce: this.nonce.toHuman(isExpanded),\n      signature: this.signature.toHex(),\n      signer: this.signer.toHuman(isExpanded),\n      tip: this.tip.toHuman(isExpanded)\n    } : {});\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n\n\n  toJSON() {\n    return this.toHex();\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return 'Extrinsic';\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value is not length-prefixed\n   */\n\n\n  toU8a(isBare) {\n    // we do not apply bare to the internal values, rather this only determines out length addition,\n    // where we strip all lengths this creates an extrinsic that cannot be decoded\n    const encoded = u8aConcat(new Uint8Array([this.version]), this._raw.toU8a());\n    return isBare ? encoded : compactAddLength(encoded);\n  }\n\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/types/extrinsic/Extrinsic.js"],"names":["_defineProperty","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","assert","compactAddLength","compactFromU8a","isHex","isU8a","u8aConcat","u8aToHex","u8aToU8a","Base","BIT_SIGNED","BIT_UNSIGNED","DEFAULT_VERSION","UNMASK_VERSION","VERSIONS","EXTRINSIC_VERSION","LATEST_EXTRINSIC_VERSION","ExtrinsicBase","args","method","argsDef","callIndex","data","era","_raw","signature","encodedLength","toU8a","isSigned","meta","nonce","signer","tip","type","version","is","other","GenericExtrinsic","constructor","registry","value","_decodeExtrinsic","_newFromValue","createType","Array","isArray","_decodeU8a","createClass","Uint8Array","offset","total","toNumber","subarray","addSignature","payload","sign","account","options","signFake","toHex","isBare","toHuman","isExpanded","toJSON","toRawType","encoded"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, compactAddLength, compactFromU8a, isHex, isU8a, u8aConcat, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { Base } from \"../codec/Base.js\";\nimport { BIT_SIGNED, BIT_UNSIGNED, DEFAULT_VERSION, UNMASK_VERSION } from \"./constants.js\";\nconst VERSIONS = ['ExtrinsicUnknown', // v0 is unknown\n'ExtrinsicUnknown', 'ExtrinsicUnknown', 'ExtrinsicUnknown', 'ExtrinsicV4'];\nexport { EXTRINSIC_VERSION as LATEST_EXTRINSIC_VERSION } from \"./v4/Extrinsic.js\";\n\nclass ExtrinsicBase extends Base {\n  /**\n   * @description The arguments passed to for the call, exposes args so it is compatible with [[Call]]\n   */\n  get args() {\n    return this.method.args;\n  }\n  /**\n   * @description The argument definitions, compatible with [[Call]]\n   */\n\n\n  get argsDef() {\n    return this.method.argsDef;\n  }\n  /**\n   * @description The actual `[sectionIndex, methodIndex]` as used in the Call\n   */\n\n\n  get callIndex() {\n    return this.method.callIndex;\n  }\n  /**\n   * @description The actual data for the Call\n   */\n\n\n  get data() {\n    return this.method.data;\n  }\n  /**\n   * @description The era for this extrinsic\n   */\n\n\n  get era() {\n    return this._raw.signature.era;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return this.toU8a().length;\n  }\n  /**\n   * @description `true` id the extrinsic is signed\n   */\n\n\n  get isSigned() {\n    return this._raw.signature.isSigned;\n  }\n  /**\n   * @description The length of the actual data, excluding prefix\n   */\n\n\n  get length() {\n    return this.toU8a(true).length;\n  }\n  /**\n   * @description The [[FunctionMetadataLatest]] that describes the extrinsic\n   */\n\n\n  get meta() {\n    return this.method.meta;\n  }\n  /**\n   * @description The [[Call]] this extrinsic wraps\n   */\n\n\n  get method() {\n    return this._raw.method;\n  }\n  /**\n   * @description The nonce for this extrinsic\n   */\n\n\n  get nonce() {\n    return this._raw.signature.nonce;\n  }\n  /**\n   * @description The actual [[EcdsaSignature]], [[Ed25519Signature]] or [[Sr25519Signature]]\n   */\n\n\n  get signature() {\n    return this._raw.signature.signature;\n  }\n  /**\n   * @description The [[Address]] that signed\n   */\n\n\n  get signer() {\n    return this._raw.signature.signer;\n  }\n  /**\n   * @description Forwards compat\n   */\n\n\n  get tip() {\n    return this._raw.signature.tip;\n  }\n  /**\n   * @description Returns the raw transaction version (not flagged with signing information)\n  */\n\n\n  get type() {\n    return this._raw.version;\n  }\n  /**\n   * @description Returns the encoded version flag\n  */\n\n\n  get version() {\n    return this.type | (this.isSigned ? BIT_SIGNED : BIT_UNSIGNED);\n  }\n  /**\n   * @description Checks if the source matches this in type\n   */\n\n\n  is(other) {\n    return this.method.is(other);\n  }\n\n}\n/**\n * @name GenericExtrinsic\n * @description\n * Representation of an Extrinsic in the system. It contains the actual call,\n * (optional) signature and encodes with an actual length prefix\n *\n * {@link https://github.com/paritytech/wiki/blob/master/Extrinsic.md#the-extrinsic-format-for-node}.\n *\n * Can be:\n * - signed, to create a transaction\n * - left as is, to create an inherent\n */\n\n\nexport class GenericExtrinsic extends ExtrinsicBase {\n  constructor(registry, value, {\n    version\n  } = {}) {\n    super(registry, GenericExtrinsic._decodeExtrinsic(registry, value, version));\n  }\n  /** @internal */\n\n\n  static _newFromValue(registry, value, version) {\n    if (value instanceof GenericExtrinsic) {\n      return value._raw;\n    }\n\n    const isSigned = (version & BIT_SIGNED) === BIT_SIGNED;\n    const type = VERSIONS[version & UNMASK_VERSION] || VERSIONS[0]; // we cast here since the VERSION definition is incredibly broad - we don't have a\n    // slice for \"only add extrinsic types\", and more string definitions become unwieldy\n\n    return registry.createType(type, value, {\n      isSigned,\n      version\n    });\n  }\n  /** @internal */\n\n\n  static _decodeExtrinsic(registry, value, version = DEFAULT_VERSION) {\n    if (isU8a(value) || Array.isArray(value) || isHex(value)) {\n      return GenericExtrinsic._decodeU8a(registry, u8aToU8a(value), version);\n    } else if (value instanceof registry.createClass('Call')) {\n      return GenericExtrinsic._newFromValue(registry, {\n        method: value\n      }, version);\n    }\n\n    return GenericExtrinsic._newFromValue(registry, value, version);\n  }\n  /** @internal */\n\n\n  static _decodeU8a(registry, value, version) {\n    if (!value.length) {\n      return GenericExtrinsic._newFromValue(registry, new Uint8Array(), version);\n    }\n\n    const [offset, length] = compactFromU8a(value);\n    const total = offset + length.toNumber();\n    assert(total <= value.length, () => `Extrinsic: length less than remainder, expected at least ${total}, found ${value.length}`);\n    const data = value.subarray(offset, total);\n    return GenericExtrinsic._newFromValue(registry, data.subarray(1), data[0]);\n  }\n  /**\n   * @description Injects an already-generated signature into the extrinsic\n   */\n\n\n  addSignature(signer, signature, payload) {\n    this._raw.addSignature(signer, signature, payload);\n\n    return this;\n  }\n  /**\n   * @description Sign the extrinsic with a specific keypair\n   */\n\n\n  sign(account, options) {\n    this._raw.sign(account, options);\n\n    return this;\n  }\n  /**\n   * @describe Adds a fake signature to the extrinsic\n   */\n\n\n  signFake(signer, options) {\n    this._raw.signFake(signer, options);\n\n    return this;\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n\n\n  toHex(isBare) {\n    return u8aToHex(this.toU8a(isBare));\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman(isExpanded) {\n    return _objectSpread({\n      isSigned: this.isSigned,\n      method: this.method.toHuman(isExpanded)\n    }, this.isSigned ? {\n      era: this.era.toHuman(isExpanded),\n      nonce: this.nonce.toHuman(isExpanded),\n      signature: this.signature.toHex(),\n      signer: this.signer.toHuman(isExpanded),\n      tip: this.tip.toHuman(isExpanded)\n    } : {});\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n\n\n  toJSON() {\n    return this.toHex();\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return 'Extrinsic';\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value is not length-prefixed\n   */\n\n\n  toU8a(isBare) {\n    // we do not apply bare to the internal values, rather this only determines out length addition,\n    // where we strip all lengths this creates an extrinsic that cannot be decoded\n    const encoded = u8aConcat(new Uint8Array([this.version]), this._raw.toU8a());\n    return isBare ? encoded : compactAddLength(encoded);\n  }\n\n}"]},"metadata":{},"sourceType":"module"}