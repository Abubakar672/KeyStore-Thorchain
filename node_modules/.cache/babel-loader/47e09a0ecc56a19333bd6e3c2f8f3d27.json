{"ast":null,"code":"var assert = require('assert');\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar BigInteger = require('bigi');\n\nvar THREE = BigInteger.valueOf(3);\n\nfunction Point(curve, x, y, z) {\n  assert.notStrictEqual(z, undefined, 'Missing Z coordinate');\n  this.curve = curve;\n  this.x = x;\n  this.y = y;\n  this.z = z;\n  this._zInv = null;\n  this.compressed = true;\n}\n\nObject.defineProperty(Point.prototype, 'zInv', {\n  get: function () {\n    if (this._zInv === null) {\n      this._zInv = this.z.modInverse(this.curve.p);\n    }\n\n    return this._zInv;\n  }\n});\nObject.defineProperty(Point.prototype, 'affineX', {\n  get: function () {\n    return this.x.multiply(this.zInv).mod(this.curve.p);\n  }\n});\nObject.defineProperty(Point.prototype, 'affineY', {\n  get: function () {\n    return this.y.multiply(this.zInv).mod(this.curve.p);\n  }\n});\n\nPoint.fromAffine = function (curve, x, y) {\n  return new Point(curve, x, y, BigInteger.ONE);\n};\n\nPoint.prototype.equals = function (other) {\n  if (other === this) return true;\n  if (this.curve.isInfinity(this)) return this.curve.isInfinity(other);\n  if (this.curve.isInfinity(other)) return this.curve.isInfinity(this); // u = Y2 * Z1 - Y1 * Z2\n\n  var u = other.y.multiply(this.z).subtract(this.y.multiply(other.z)).mod(this.curve.p);\n  if (u.signum() !== 0) return false; // v = X2 * Z1 - X1 * Z2\n\n  var v = other.x.multiply(this.z).subtract(this.x.multiply(other.z)).mod(this.curve.p);\n  return v.signum() === 0;\n};\n\nPoint.prototype.negate = function () {\n  var y = this.curve.p.subtract(this.y);\n  return new Point(this.curve, this.x, y, this.z);\n};\n\nPoint.prototype.add = function (b) {\n  if (this.curve.isInfinity(this)) return b;\n  if (this.curve.isInfinity(b)) return this;\n  var x1 = this.x;\n  var y1 = this.y;\n  var x2 = b.x;\n  var y2 = b.y; // u = Y2 * Z1 - Y1 * Z2\n\n  var u = y2.multiply(this.z).subtract(y1.multiply(b.z)).mod(this.curve.p); // v = X2 * Z1 - X1 * Z2\n\n  var v = x2.multiply(this.z).subtract(x1.multiply(b.z)).mod(this.curve.p);\n\n  if (v.signum() === 0) {\n    if (u.signum() === 0) {\n      return this.twice(); // this == b, so double\n    }\n\n    return this.curve.infinity; // this = -b, so infinity\n  }\n\n  var v2 = v.square();\n  var v3 = v2.multiply(v);\n  var x1v2 = x1.multiply(v2);\n  var zu2 = u.square().multiply(this.z); // x3 = v * (z2 * (z1 * u^2 - 2 * x1 * v^2) - v^3)\n\n  var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.p); // y3 = z2 * (3 * x1 * u * v^2 - y1 * v^3 - z1 * u^3) + u * v^3\n\n  var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.p); // z3 = v^3 * z1 * z2\n\n  var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.p);\n  return new Point(this.curve, x3, y3, z3);\n};\n\nPoint.prototype.twice = function () {\n  if (this.curve.isInfinity(this)) return this;\n  if (this.y.signum() === 0) return this.curve.infinity;\n  var x1 = this.x;\n  var y1 = this.y;\n  var y1z1 = y1.multiply(this.z).mod(this.curve.p);\n  var y1sqz1 = y1z1.multiply(y1).mod(this.curve.p);\n  var a = this.curve.a; // w = 3 * x1^2 + a * z1^2\n\n  var w = x1.square().multiply(THREE);\n\n  if (a.signum() !== 0) {\n    w = w.add(this.z.square().multiply(a));\n  }\n\n  w = w.mod(this.curve.p); // x3 = 2 * y1 * z1 * (w^2 - 8 * x1 * y1^2 * z1)\n\n  var x3 = w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.p); // y3 = 4 * y1^2 * z1 * (3 * w * x1 - 2 * y1^2 * z1) - w^3\n\n  var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.pow(3)).mod(this.curve.p); // z3 = 8 * (y1 * z1)^3\n\n  var z3 = y1z1.pow(3).shiftLeft(3).mod(this.curve.p);\n  return new Point(this.curve, x3, y3, z3);\n}; // Simple NAF (Non-Adjacent Form) multiplication algorithm\n// TODO: modularize the multiplication algorithm\n\n\nPoint.prototype.multiply = function (k) {\n  if (this.curve.isInfinity(this)) return this;\n  if (k.signum() === 0) return this.curve.infinity;\n  var e = k;\n  var h = e.multiply(THREE);\n  var neg = this.negate();\n  var R = this;\n\n  for (var i = h.bitLength() - 2; i > 0; --i) {\n    var hBit = h.testBit(i);\n    var eBit = e.testBit(i);\n    R = R.twice();\n\n    if (hBit !== eBit) {\n      R = R.add(hBit ? this : neg);\n    }\n  }\n\n  return R;\n}; // Compute this*j + x*k (simultaneous multiplication)\n\n\nPoint.prototype.multiplyTwo = function (j, x, k) {\n  var i = Math.max(j.bitLength(), k.bitLength()) - 1;\n  var R = this.curve.infinity;\n  var both = this.add(x);\n\n  while (i >= 0) {\n    var jBit = j.testBit(i);\n    var kBit = k.testBit(i);\n    R = R.twice();\n\n    if (jBit) {\n      if (kBit) {\n        R = R.add(both);\n      } else {\n        R = R.add(this);\n      }\n    } else if (kBit) {\n      R = R.add(x);\n    }\n\n    --i;\n  }\n\n  return R;\n};\n\nPoint.prototype.getEncoded = function (compressed) {\n  if (compressed == null) compressed = this.compressed;\n  if (this.curve.isInfinity(this)) return Buffer.alloc(1, 0); // Infinity point encoded is simply '00'\n\n  var x = this.affineX;\n  var y = this.affineY;\n  var byteLength = this.curve.pLength;\n  var buffer; // 0x02/0x03 | X\n\n  if (compressed) {\n    buffer = Buffer.allocUnsafe(1 + byteLength);\n    buffer.writeUInt8(y.isEven() ? 0x02 : 0x03, 0); // 0x04 | X | Y\n  } else {\n    buffer = Buffer.allocUnsafe(1 + byteLength + byteLength);\n    buffer.writeUInt8(0x04, 0);\n    y.toBuffer(byteLength).copy(buffer, 1 + byteLength);\n  }\n\n  x.toBuffer(byteLength).copy(buffer, 1);\n  return buffer;\n};\n\nPoint.decodeFrom = function (curve, buffer) {\n  var type = buffer.readUInt8(0);\n  var compressed = type !== 4;\n  var byteLength = Math.floor((curve.p.bitLength() + 7) / 8);\n  var x = BigInteger.fromBuffer(buffer.slice(1, 1 + byteLength));\n  var Q;\n\n  if (compressed) {\n    assert.equal(buffer.length, byteLength + 1, 'Invalid sequence length');\n    assert(type === 0x02 || type === 0x03, 'Invalid sequence tag');\n    var isOdd = type === 0x03;\n    Q = curve.pointFromX(isOdd, x);\n  } else {\n    assert.equal(buffer.length, 1 + byteLength + byteLength, 'Invalid sequence length');\n    var y = BigInteger.fromBuffer(buffer.slice(1 + byteLength));\n    Q = Point.fromAffine(curve, x, y);\n  }\n\n  Q.compressed = compressed;\n  return Q;\n};\n\nPoint.prototype.toString = function () {\n  if (this.curve.isInfinity(this)) return '(INFINITY)';\n  return '(' + this.affineX.toString() + ',' + this.affineY.toString() + ')';\n};\n\nmodule.exports = Point;","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/ecurve/lib/point.js"],"names":["assert","require","Buffer","BigInteger","THREE","valueOf","Point","curve","x","y","z","notStrictEqual","undefined","_zInv","compressed","Object","defineProperty","prototype","get","modInverse","p","multiply","zInv","mod","fromAffine","ONE","equals","other","isInfinity","u","subtract","signum","v","negate","add","b","x1","y1","x2","y2","twice","infinity","v2","square","v3","x1v2","zu2","x3","shiftLeft","y3","z3","y1z1","y1sqz1","a","w","pow","k","e","h","neg","R","i","bitLength","hBit","testBit","eBit","multiplyTwo","j","Math","max","both","jBit","kBit","getEncoded","alloc","affineX","affineY","byteLength","pLength","buffer","allocUnsafe","writeUInt8","isEven","toBuffer","copy","decodeFrom","type","readUInt8","floor","fromBuffer","slice","Q","equal","length","isOdd","pointFromX","toString","module","exports"],"mappings":"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","sourcesContent":["var assert = require('assert')\nvar Buffer = require('safe-buffer').Buffer\nvar BigInteger = require('bigi')\n\nvar THREE = BigInteger.valueOf(3)\n\nfunction Point (curve, x, y, z) {\n  assert.notStrictEqual(z, undefined, 'Missing Z coordinate')\n\n  this.curve = curve\n  this.x = x\n  this.y = y\n  this.z = z\n  this._zInv = null\n\n  this.compressed = true\n}\n\nObject.defineProperty(Point.prototype, 'zInv', {\n  get: function () {\n    if (this._zInv === null) {\n      this._zInv = this.z.modInverse(this.curve.p)\n    }\n\n    return this._zInv\n  }\n})\n\nObject.defineProperty(Point.prototype, 'affineX', {\n  get: function () {\n    return this.x.multiply(this.zInv).mod(this.curve.p)\n  }\n})\n\nObject.defineProperty(Point.prototype, 'affineY', {\n  get: function () {\n    return this.y.multiply(this.zInv).mod(this.curve.p)\n  }\n})\n\nPoint.fromAffine = function (curve, x, y) {\n  return new Point(curve, x, y, BigInteger.ONE)\n}\n\nPoint.prototype.equals = function (other) {\n  if (other === this) return true\n  if (this.curve.isInfinity(this)) return this.curve.isInfinity(other)\n  if (this.curve.isInfinity(other)) return this.curve.isInfinity(this)\n\n  // u = Y2 * Z1 - Y1 * Z2\n  var u = other.y.multiply(this.z).subtract(this.y.multiply(other.z)).mod(this.curve.p)\n\n  if (u.signum() !== 0) return false\n\n  // v = X2 * Z1 - X1 * Z2\n  var v = other.x.multiply(this.z).subtract(this.x.multiply(other.z)).mod(this.curve.p)\n\n  return v.signum() === 0\n}\n\nPoint.prototype.negate = function () {\n  var y = this.curve.p.subtract(this.y)\n\n  return new Point(this.curve, this.x, y, this.z)\n}\n\nPoint.prototype.add = function (b) {\n  if (this.curve.isInfinity(this)) return b\n  if (this.curve.isInfinity(b)) return this\n\n  var x1 = this.x\n  var y1 = this.y\n  var x2 = b.x\n  var y2 = b.y\n\n  // u = Y2 * Z1 - Y1 * Z2\n  var u = y2.multiply(this.z).subtract(y1.multiply(b.z)).mod(this.curve.p)\n  // v = X2 * Z1 - X1 * Z2\n  var v = x2.multiply(this.z).subtract(x1.multiply(b.z)).mod(this.curve.p)\n\n  if (v.signum() === 0) {\n    if (u.signum() === 0) {\n      return this.twice() // this == b, so double\n    }\n\n    return this.curve.infinity // this = -b, so infinity\n  }\n\n  var v2 = v.square()\n  var v3 = v2.multiply(v)\n  var x1v2 = x1.multiply(v2)\n  var zu2 = u.square().multiply(this.z)\n\n  // x3 = v * (z2 * (z1 * u^2 - 2 * x1 * v^2) - v^3)\n  var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.p)\n  // y3 = z2 * (3 * x1 * u * v^2 - y1 * v^3 - z1 * u^3) + u * v^3\n  var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.p)\n  // z3 = v^3 * z1 * z2\n  var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.p)\n\n  return new Point(this.curve, x3, y3, z3)\n}\n\nPoint.prototype.twice = function () {\n  if (this.curve.isInfinity(this)) return this\n  if (this.y.signum() === 0) return this.curve.infinity\n\n  var x1 = this.x\n  var y1 = this.y\n\n  var y1z1 = y1.multiply(this.z).mod(this.curve.p)\n  var y1sqz1 = y1z1.multiply(y1).mod(this.curve.p)\n  var a = this.curve.a\n\n  // w = 3 * x1^2 + a * z1^2\n  var w = x1.square().multiply(THREE)\n\n  if (a.signum() !== 0) {\n    w = w.add(this.z.square().multiply(a))\n  }\n\n  w = w.mod(this.curve.p)\n  // x3 = 2 * y1 * z1 * (w^2 - 8 * x1 * y1^2 * z1)\n  var x3 = w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.p)\n  // y3 = 4 * y1^2 * z1 * (3 * w * x1 - 2 * y1^2 * z1) - w^3\n  var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.pow(3)).mod(this.curve.p)\n  // z3 = 8 * (y1 * z1)^3\n  var z3 = y1z1.pow(3).shiftLeft(3).mod(this.curve.p)\n\n  return new Point(this.curve, x3, y3, z3)\n}\n\n// Simple NAF (Non-Adjacent Form) multiplication algorithm\n// TODO: modularize the multiplication algorithm\nPoint.prototype.multiply = function (k) {\n  if (this.curve.isInfinity(this)) return this\n  if (k.signum() === 0) return this.curve.infinity\n\n  var e = k\n  var h = e.multiply(THREE)\n\n  var neg = this.negate()\n  var R = this\n\n  for (var i = h.bitLength() - 2; i > 0; --i) {\n    var hBit = h.testBit(i)\n    var eBit = e.testBit(i)\n\n    R = R.twice()\n\n    if (hBit !== eBit) {\n      R = R.add(hBit ? this : neg)\n    }\n  }\n\n  return R\n}\n\n// Compute this*j + x*k (simultaneous multiplication)\nPoint.prototype.multiplyTwo = function (j, x, k) {\n  var i = Math.max(j.bitLength(), k.bitLength()) - 1\n  var R = this.curve.infinity\n  var both = this.add(x)\n\n  while (i >= 0) {\n    var jBit = j.testBit(i)\n    var kBit = k.testBit(i)\n\n    R = R.twice()\n\n    if (jBit) {\n      if (kBit) {\n        R = R.add(both)\n      } else {\n        R = R.add(this)\n      }\n    } else if (kBit) {\n      R = R.add(x)\n    }\n    --i\n  }\n\n  return R\n}\n\nPoint.prototype.getEncoded = function (compressed) {\n  if (compressed == null) compressed = this.compressed\n  if (this.curve.isInfinity(this)) return Buffer.alloc(1, 0) // Infinity point encoded is simply '00'\n\n  var x = this.affineX\n  var y = this.affineY\n  var byteLength = this.curve.pLength\n  var buffer\n\n  // 0x02/0x03 | X\n  if (compressed) {\n    buffer = Buffer.allocUnsafe(1 + byteLength)\n    buffer.writeUInt8(y.isEven() ? 0x02 : 0x03, 0)\n\n  // 0x04 | X | Y\n  } else {\n    buffer = Buffer.allocUnsafe(1 + byteLength + byteLength)\n    buffer.writeUInt8(0x04, 0)\n\n    y.toBuffer(byteLength).copy(buffer, 1 + byteLength)\n  }\n\n  x.toBuffer(byteLength).copy(buffer, 1)\n\n  return buffer\n}\n\nPoint.decodeFrom = function (curve, buffer) {\n  var type = buffer.readUInt8(0)\n  var compressed = (type !== 4)\n\n  var byteLength = Math.floor((curve.p.bitLength() + 7) / 8)\n  var x = BigInteger.fromBuffer(buffer.slice(1, 1 + byteLength))\n\n  var Q\n  if (compressed) {\n    assert.equal(buffer.length, byteLength + 1, 'Invalid sequence length')\n    assert(type === 0x02 || type === 0x03, 'Invalid sequence tag')\n\n    var isOdd = (type === 0x03)\n    Q = curve.pointFromX(isOdd, x)\n  } else {\n    assert.equal(buffer.length, 1 + byteLength + byteLength, 'Invalid sequence length')\n\n    var y = BigInteger.fromBuffer(buffer.slice(1 + byteLength))\n    Q = Point.fromAffine(curve, x, y)\n  }\n\n  Q.compressed = compressed\n  return Q\n}\n\nPoint.prototype.toString = function () {\n  if (this.curve.isInfinity(this)) return '(INFINITY)'\n\n  return '(' + this.affineX.toString() + ',' + this.affineY.toString() + ')'\n}\n\nmodule.exports = Point\n"]},"metadata":{},"sourceType":"script"}