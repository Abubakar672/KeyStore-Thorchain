{"ast":null,"code":"// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert } from '@polkadot/util';\n\nfunction isNotNested(...counters) {\n  return !counters.some(counter => counter !== 0);\n} // safely split a string on ', ' while taking care of any nested occurences\n\n\nexport function typeSplit(type) {\n  let [cDepth, fDepth, sDepth, tDepth, start] = [0, 0, 0, 0, 0];\n  const result = [];\n\n  const extract = index => {\n    if (isNotNested(cDepth, fDepth, sDepth, tDepth)) {\n      result.push(type.substr(start, index - start).trim());\n      start = index + 1;\n    }\n  };\n\n  for (let index = 0; index < type.length; index++) {\n    switch (type[index]) {\n      // if we are not nested, add the type\n      case ',':\n        extract(index);\n        break;\n      // adjust compact/vec (and friends) depth\n\n      case '<':\n        cDepth++;\n        break;\n\n      case '>':\n        cDepth--;\n        break;\n      // adjust fixed vec depths\n\n      case '[':\n        fDepth++;\n        break;\n\n      case ']':\n        fDepth--;\n        break;\n      // adjust struct depth\n\n      case '{':\n        sDepth++;\n        break;\n\n      case '}':\n        sDepth--;\n        break;\n      // adjust tuple depth\n\n      case '(':\n        tDepth++;\n        break;\n\n      case ')':\n        tDepth--;\n        break;\n    }\n  }\n\n  assert(isNotNested(cDepth, fDepth, sDepth, tDepth), () => `Invalid definition (missing terminators) found in ${type}`); // the final leg of the journey\n\n  result.push(type.substr(start, type.length - start).trim());\n  return result;\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/types/create/typeSplit.js"],"names":["assert","isNotNested","counters","some","counter","typeSplit","type","cDepth","fDepth","sDepth","tDepth","start","result","extract","index","push","substr","trim","length"],"mappings":"AAAA;AACA;AACA,SAASA,MAAT,QAAuB,gBAAvB;;AAEA,SAASC,WAAT,CAAqB,GAAGC,QAAxB,EAAkC;AAChC,SAAO,CAACA,QAAQ,CAACC,IAAT,CAAcC,OAAO,IAAIA,OAAO,KAAK,CAArC,CAAR;AACD,C,CAAC;;;AAGF,OAAO,SAASC,SAAT,CAAmBC,IAAnB,EAAyB;AAC9B,MAAI,CAACC,MAAD,EAASC,MAAT,EAAiBC,MAAjB,EAAyBC,MAAzB,EAAiCC,KAAjC,IAA0C,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAA9C;AACA,QAAMC,MAAM,GAAG,EAAf;;AAEA,QAAMC,OAAO,GAAGC,KAAK,IAAI;AACvB,QAAIb,WAAW,CAACM,MAAD,EAASC,MAAT,EAAiBC,MAAjB,EAAyBC,MAAzB,CAAf,EAAiD;AAC/CE,MAAAA,MAAM,CAACG,IAAP,CAAYT,IAAI,CAACU,MAAL,CAAYL,KAAZ,EAAmBG,KAAK,GAAGH,KAA3B,EAAkCM,IAAlC,EAAZ;AACAN,MAAAA,KAAK,GAAGG,KAAK,GAAG,CAAhB;AACD;AACF,GALD;;AAOA,OAAK,IAAIA,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGR,IAAI,CAACY,MAAjC,EAAyCJ,KAAK,EAA9C,EAAkD;AAChD,YAAQR,IAAI,CAACQ,KAAD,CAAZ;AACE;AACA,WAAK,GAAL;AACED,QAAAA,OAAO,CAACC,KAAD,CAAP;AACA;AACF;;AAEA,WAAK,GAAL;AACEP,QAAAA,MAAM;AACN;;AAEF,WAAK,GAAL;AACEA,QAAAA,MAAM;AACN;AACF;;AAEA,WAAK,GAAL;AACEC,QAAAA,MAAM;AACN;;AAEF,WAAK,GAAL;AACEA,QAAAA,MAAM;AACN;AACF;;AAEA,WAAK,GAAL;AACEC,QAAAA,MAAM;AACN;;AAEF,WAAK,GAAL;AACEA,QAAAA,MAAM;AACN;AACF;;AAEA,WAAK,GAAL;AACEC,QAAAA,MAAM;AACN;;AAEF,WAAK,GAAL;AACEA,QAAAA,MAAM;AACN;AAxCJ;AA0CD;;AAEDV,EAAAA,MAAM,CAACC,WAAW,CAACM,MAAD,EAASC,MAAT,EAAiBC,MAAjB,EAAyBC,MAAzB,CAAZ,EAA8C,MAAO,qDAAoDJ,IAAK,EAA9G,CAAN,CAxD8B,CAwD0F;;AAExHM,EAAAA,MAAM,CAACG,IAAP,CAAYT,IAAI,CAACU,MAAL,CAAYL,KAAZ,EAAmBL,IAAI,CAACY,MAAL,GAAcP,KAAjC,EAAwCM,IAAxC,EAAZ;AACA,SAAOL,MAAP;AACD","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert } from '@polkadot/util';\n\nfunction isNotNested(...counters) {\n  return !counters.some(counter => counter !== 0);\n} // safely split a string on ', ' while taking care of any nested occurences\n\n\nexport function typeSplit(type) {\n  let [cDepth, fDepth, sDepth, tDepth, start] = [0, 0, 0, 0, 0];\n  const result = [];\n\n  const extract = index => {\n    if (isNotNested(cDepth, fDepth, sDepth, tDepth)) {\n      result.push(type.substr(start, index - start).trim());\n      start = index + 1;\n    }\n  };\n\n  for (let index = 0; index < type.length; index++) {\n    switch (type[index]) {\n      // if we are not nested, add the type\n      case ',':\n        extract(index);\n        break;\n      // adjust compact/vec (and friends) depth\n\n      case '<':\n        cDepth++;\n        break;\n\n      case '>':\n        cDepth--;\n        break;\n      // adjust fixed vec depths\n\n      case '[':\n        fDepth++;\n        break;\n\n      case ']':\n        fDepth--;\n        break;\n      // adjust struct depth\n\n      case '{':\n        sDepth++;\n        break;\n\n      case '}':\n        sDepth--;\n        break;\n      // adjust tuple depth\n\n      case '(':\n        tDepth++;\n        break;\n\n      case ')':\n        tDepth--;\n        break;\n    }\n  }\n\n  assert(isNotNested(cDepth, fDepth, sDepth, tDepth), () => `Invalid definition (missing terminators) found in ${type}`); // the final leg of the journey\n\n  result.push(type.substr(start, type.length - start).trim());\n  return result;\n}"]},"metadata":{},"sourceType":"module"}