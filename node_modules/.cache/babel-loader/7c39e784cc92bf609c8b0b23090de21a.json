{"ast":null,"code":"// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { u8aToHex } from '@polkadot/util';\nimport { Base } from \"../codec/Base.js\";\nimport { DEFAULT_VERSION } from \"./constants.js\";\nconst VERSIONS = ['ExtrinsicPayloadUnknown', // v0 is unknown\n'ExtrinsicPayloadUnknown', 'ExtrinsicPayloadUnknown', 'ExtrinsicPayloadUnknown', 'ExtrinsicPayloadV4'];\n/**\n * @name GenericExtrinsicPayload\n * @description\n * A signing payload for an [[Extrinsic]]. For the final encoding, it is variable length based\n * on the contents included\n */\n\nexport class GenericExtrinsicPayload extends Base {\n  constructor(registry, value, {\n    version\n  } = {}) {\n    super(registry, GenericExtrinsicPayload.decodeExtrinsicPayload(registry, value, version));\n  }\n  /** @internal */\n\n\n  static decodeExtrinsicPayload(registry, value, version = DEFAULT_VERSION) {\n    if (value instanceof GenericExtrinsicPayload) {\n      return value._raw;\n    }\n\n    return registry.createType(VERSIONS[version] || VERSIONS[0], value, {\n      version\n    });\n  }\n  /**\n   * @description The block [[Hash]] the signature applies to (mortal/immortal)\n   */\n\n\n  get blockHash() {\n    return this._raw.blockHash;\n  }\n  /**\n   * @description The [[ExtrinsicEra]]\n   */\n\n\n  get era() {\n    return this._raw.era;\n  }\n  /**\n   * @description The genesis block [[Hash]] the signature applies to\n   */\n\n\n  get genesisHash() {\n    // NOTE only v3+\n    return this._raw.genesisHash || this.registry.createType('Hash');\n  }\n  /**\n   * @description The [[Raw]] contained in the payload\n   */\n\n\n  get method() {\n    return this._raw.method;\n  }\n  /**\n   * @description The [[Index]]\n   */\n\n\n  get nonce() {\n    return this._raw.nonce;\n  }\n  /**\n   * @description The specVersion as a [[u32]] for this payload\n   */\n\n\n  get specVersion() {\n    // NOTE only v3+\n    return this._raw.specVersion || this.registry.createType('u32');\n  }\n  /**\n   * @description The [[Balance]]\n   */\n\n\n  get tip() {\n    // NOTE from v2+\n    return this._raw.tip || this.registry.createType('Compact<Balance>');\n  }\n  /**\n   * @description The transaction version as a [[u32]] for this payload\n   */\n\n\n  get transactionVersion() {\n    // NOTE only v4+\n    return this._raw.transactionVersion || this.registry.createType('u32');\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n\n\n  eq(other) {\n    return this._raw.eq(other);\n  }\n  /**\n   * @description Sign the payload with the keypair\n   */\n\n\n  sign(signerPair) {\n    const signature = this._raw.sign(signerPair); // This is extensible, so we could quite readily extend to send back extra\n    // information, such as for instance the payload, i.e. `payload: this.toHex()`\n    // For the case here we sign via the extrinsic, we ignore the return, so generally\n    // this is applicable for external signing\n\n\n    return {\n      signature: u8aToHex(signature)\n    };\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman(isExtended) {\n    return this._raw.toHuman(isExtended);\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n\n\n  toJSON() {\n    return this.toHex();\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n\n\n  toString() {\n    return this.toHex();\n  }\n  /**\n   * @description Returns a serialized u8a form\n   */\n\n\n  toU8a(isBare) {\n    // call our parent, with only the method stripped\n    return super.toU8a(isBare ? {\n      method: true\n    } : false);\n  }\n\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/types/extrinsic/ExtrinsicPayload.js"],"names":["u8aToHex","Base","DEFAULT_VERSION","VERSIONS","GenericExtrinsicPayload","constructor","registry","value","version","decodeExtrinsicPayload","_raw","createType","blockHash","era","genesisHash","method","nonce","specVersion","tip","transactionVersion","eq","other","sign","signerPair","signature","toHuman","isExtended","toJSON","toHex","toString","toU8a","isBare"],"mappings":"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","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { u8aToHex } from '@polkadot/util';\nimport { Base } from \"../codec/Base.js\";\nimport { DEFAULT_VERSION } from \"./constants.js\";\nconst VERSIONS = ['ExtrinsicPayloadUnknown', // v0 is unknown\n'ExtrinsicPayloadUnknown', 'ExtrinsicPayloadUnknown', 'ExtrinsicPayloadUnknown', 'ExtrinsicPayloadV4'];\n/**\n * @name GenericExtrinsicPayload\n * @description\n * A signing payload for an [[Extrinsic]]. For the final encoding, it is variable length based\n * on the contents included\n */\n\nexport class GenericExtrinsicPayload extends Base {\n  constructor(registry, value, {\n    version\n  } = {}) {\n    super(registry, GenericExtrinsicPayload.decodeExtrinsicPayload(registry, value, version));\n  }\n  /** @internal */\n\n\n  static decodeExtrinsicPayload(registry, value, version = DEFAULT_VERSION) {\n    if (value instanceof GenericExtrinsicPayload) {\n      return value._raw;\n    }\n\n    return registry.createType(VERSIONS[version] || VERSIONS[0], value, {\n      version\n    });\n  }\n  /**\n   * @description The block [[Hash]] the signature applies to (mortal/immortal)\n   */\n\n\n  get blockHash() {\n    return this._raw.blockHash;\n  }\n  /**\n   * @description The [[ExtrinsicEra]]\n   */\n\n\n  get era() {\n    return this._raw.era;\n  }\n  /**\n   * @description The genesis block [[Hash]] the signature applies to\n   */\n\n\n  get genesisHash() {\n    // NOTE only v3+\n    return this._raw.genesisHash || this.registry.createType('Hash');\n  }\n  /**\n   * @description The [[Raw]] contained in the payload\n   */\n\n\n  get method() {\n    return this._raw.method;\n  }\n  /**\n   * @description The [[Index]]\n   */\n\n\n  get nonce() {\n    return this._raw.nonce;\n  }\n  /**\n   * @description The specVersion as a [[u32]] for this payload\n   */\n\n\n  get specVersion() {\n    // NOTE only v3+\n    return this._raw.specVersion || this.registry.createType('u32');\n  }\n  /**\n   * @description The [[Balance]]\n   */\n\n\n  get tip() {\n    // NOTE from v2+\n    return this._raw.tip || this.registry.createType('Compact<Balance>');\n  }\n  /**\n   * @description The transaction version as a [[u32]] for this payload\n   */\n\n\n  get transactionVersion() {\n    // NOTE only v4+\n    return this._raw.transactionVersion || this.registry.createType('u32');\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n\n\n  eq(other) {\n    return this._raw.eq(other);\n  }\n  /**\n   * @description Sign the payload with the keypair\n   */\n\n\n  sign(signerPair) {\n    const signature = this._raw.sign(signerPair); // This is extensible, so we could quite readily extend to send back extra\n    // information, such as for instance the payload, i.e. `payload: this.toHex()`\n    // For the case here we sign via the extrinsic, we ignore the return, so generally\n    // this is applicable for external signing\n\n\n    return {\n      signature: u8aToHex(signature)\n    };\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman(isExtended) {\n    return this._raw.toHuman(isExtended);\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n\n\n  toJSON() {\n    return this.toHex();\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n\n\n  toString() {\n    return this.toHex();\n  }\n  /**\n   * @description Returns a serialized u8a form\n   */\n\n\n  toU8a(isBare) {\n    // call our parent, with only the method stripped\n    return super.toU8a(isBare ? {\n      method: true\n    } : false);\n  }\n\n}"]},"metadata":{},"sourceType":"module"}