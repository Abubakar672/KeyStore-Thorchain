{"ast":null,"code":"// Copyright 2017-2021 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, u8aToBn } from '@polkadot/util';\nimport { DEFAULT_PARAMS } from \"./defaults.js\";\nexport function scryptFromU8a(data) {\n  const salt = data.subarray(0, 32);\n  const N = u8aToBn(data.subarray(32 + 0, 32 + 4), {\n    isLe: true\n  }).toNumber();\n  const p = u8aToBn(data.subarray(32 + 4, 32 + 8), {\n    isLe: true\n  }).toNumber();\n  const r = u8aToBn(data.subarray(32 + 8, 32 + 12), {\n    isLe: true\n  }).toNumber(); // FIXME At this moment we assume these to be fixed params, this is not a great idea since we lose flexibility\n  // and updates for greater security. However we need some protection against carefully-crafted params that can\n  // eat up CPU since these are user inputs. So we need to get very clever here, but atm we only allow the defaults\n  // and if no match, bail out\n\n  assert(N === DEFAULT_PARAMS.N && p === DEFAULT_PARAMS.p && r === DEFAULT_PARAMS.r, 'Invalid injected scrypt params found');\n  return {\n    params: {\n      N,\n      p,\n      r\n    },\n    salt\n  };\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/util-crypto/scrypt/fromU8a.js"],"names":["assert","u8aToBn","DEFAULT_PARAMS","scryptFromU8a","data","salt","subarray","N","isLe","toNumber","p","r","params"],"mappings":"AAAA;AACA;AACA,SAASA,MAAT,EAAiBC,OAAjB,QAAgC,gBAAhC;AACA,SAASC,cAAT,QAA+B,eAA/B;AACA,OAAO,SAASC,aAAT,CAAuBC,IAAvB,EAA6B;AAClC,QAAMC,IAAI,GAAGD,IAAI,CAACE,QAAL,CAAc,CAAd,EAAiB,EAAjB,CAAb;AACA,QAAMC,CAAC,GAAGN,OAAO,CAACG,IAAI,CAACE,QAAL,CAAc,KAAK,CAAnB,EAAsB,KAAK,CAA3B,CAAD,EAAgC;AAC/CE,IAAAA,IAAI,EAAE;AADyC,GAAhC,CAAP,CAEPC,QAFO,EAAV;AAGA,QAAMC,CAAC,GAAGT,OAAO,CAACG,IAAI,CAACE,QAAL,CAAc,KAAK,CAAnB,EAAsB,KAAK,CAA3B,CAAD,EAAgC;AAC/CE,IAAAA,IAAI,EAAE;AADyC,GAAhC,CAAP,CAEPC,QAFO,EAAV;AAGA,QAAME,CAAC,GAAGV,OAAO,CAACG,IAAI,CAACE,QAAL,CAAc,KAAK,CAAnB,EAAsB,KAAK,EAA3B,CAAD,EAAiC;AAChDE,IAAAA,IAAI,EAAE;AAD0C,GAAjC,CAAP,CAEPC,QAFO,EAAV,CARkC,CAUnB;AACf;AACA;AACA;;AAEAT,EAAAA,MAAM,CAACO,CAAC,KAAKL,cAAc,CAACK,CAArB,IAA0BG,CAAC,KAAKR,cAAc,CAACQ,CAA/C,IAAoDC,CAAC,KAAKT,cAAc,CAACS,CAA1E,EAA6E,sCAA7E,CAAN;AACA,SAAO;AACLC,IAAAA,MAAM,EAAE;AACNL,MAAAA,CADM;AAENG,MAAAA,CAFM;AAGNC,MAAAA;AAHM,KADH;AAMLN,IAAAA;AANK,GAAP;AAQD","sourcesContent":["// Copyright 2017-2021 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, u8aToBn } from '@polkadot/util';\nimport { DEFAULT_PARAMS } from \"./defaults.js\";\nexport function scryptFromU8a(data) {\n  const salt = data.subarray(0, 32);\n  const N = u8aToBn(data.subarray(32 + 0, 32 + 4), {\n    isLe: true\n  }).toNumber();\n  const p = u8aToBn(data.subarray(32 + 4, 32 + 8), {\n    isLe: true\n  }).toNumber();\n  const r = u8aToBn(data.subarray(32 + 8, 32 + 12), {\n    isLe: true\n  }).toNumber(); // FIXME At this moment we assume these to be fixed params, this is not a great idea since we lose flexibility\n  // and updates for greater security. However we need some protection against carefully-crafted params that can\n  // eat up CPU since these are user inputs. So we need to get very clever here, but atm we only allow the defaults\n  // and if no match, bail out\n\n  assert(N === DEFAULT_PARAMS.N && p === DEFAULT_PARAMS.p && r === DEFAULT_PARAMS.r, 'Invalid injected scrypt params found');\n  return {\n    params: {\n      N,\n      p,\n      r\n    },\n    salt\n  };\n}"]},"metadata":{},"sourceType":"module"}