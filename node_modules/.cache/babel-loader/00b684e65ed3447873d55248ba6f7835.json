{"ast":null,"code":"// Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { combineLatest, map, of, switchMap } from 'rxjs';\nimport { isNumber, isUndefined } from '@polkadot/util';\nimport { FALLBACK_MAX_HASH_COUNT, FALLBACK_PERIOD, MAX_FINALITY_LAG, MORTAL_PERIOD } from \"./constants.js\";\n\nfunction latestNonce(api, address) {\n  return api.derive.balances.account(address).pipe(map(({\n    accountNonce\n  }) => accountNonce));\n}\n\nfunction nextNonce(api, address) {\n  var _api$rpc$system;\n\n  return (_api$rpc$system = api.rpc.system) !== null && _api$rpc$system !== void 0 && _api$rpc$system.accountNextIndex ? api.rpc.system.accountNextIndex(address) : latestNonce(api, address);\n}\n\nfunction signingHeader(api) {\n  return combineLatest([api.rpc.chain.getHeader(), api.rpc.chain.getFinalizedHead()]).pipe(switchMap(([bestHeader, finHash]) => // retrieve the headers - in the case of the current block, we use the parent\n  // to minimize (not completely remove) the impact that forks do have on the system\n  // (when at genesis, just return the current header as the last known)\n  bestHeader.parentHash.isEmpty ? of([bestHeader, bestHeader]) : combineLatest([api.rpc.chain.getHeader(bestHeader.parentHash), api.rpc.chain.getHeader(finHash)])), map(([current, finalized]) => // determine the hash to use, current when lag > max, else finalized\n  current.number.unwrap().sub(finalized.number.unwrap()).gt(MAX_FINALITY_LAG) ? current : finalized));\n}\n\nexport function signingInfo(_instanceId, api) {\n  // no memo, we want to do this fresh on each run\n  return (address, nonce, era) => combineLatest([// retrieve nonce if none was specified\n  isUndefined(nonce) ? latestNonce(api, address) : nonce === -1 ? nextNonce(api, address) : of(api.registry.createType('Index', nonce)), // if no era (create) or era > 0 (mortal), do block retrieval\n  isUndefined(era) || isNumber(era) && era > 0 ? signingHeader(api) : of(null)]).pipe(map(([nonce, header]) => {\n    var _api$consts$system, _api$consts$system$bl, _api$consts$babe, _api$consts$timestamp;\n\n    return {\n      header,\n      mortalLength: Math.min(((_api$consts$system = api.consts.system) === null || _api$consts$system === void 0 ? void 0 : (_api$consts$system$bl = _api$consts$system.blockHashCount) === null || _api$consts$system$bl === void 0 ? void 0 : _api$consts$system$bl.toNumber()) || FALLBACK_MAX_HASH_COUNT, MORTAL_PERIOD.div(((_api$consts$babe = api.consts.babe) === null || _api$consts$babe === void 0 ? void 0 : _api$consts$babe.expectedBlockTime) || ((_api$consts$timestamp = api.consts.timestamp) === null || _api$consts$timestamp === void 0 ? void 0 : _api$consts$timestamp.minimumPeriod.muln(2)) || FALLBACK_PERIOD).iadd(MAX_FINALITY_LAG).toNumber()),\n      nonce\n    };\n  }));\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/api-derive/tx/signingInfo.js"],"names":["combineLatest","map","of","switchMap","isNumber","isUndefined","FALLBACK_MAX_HASH_COUNT","FALLBACK_PERIOD","MAX_FINALITY_LAG","MORTAL_PERIOD","latestNonce","api","address","derive","balances","account","pipe","accountNonce","nextNonce","_api$rpc$system","rpc","system","accountNextIndex","signingHeader","chain","getHeader","getFinalizedHead","bestHeader","finHash","parentHash","isEmpty","current","finalized","number","unwrap","sub","gt","signingInfo","_instanceId","nonce","era","registry","createType","header","_api$consts$system","_api$consts$system$bl","_api$consts$babe","_api$consts$timestamp","mortalLength","Math","min","consts","blockHashCount","toNumber","div","babe","expectedBlockTime","timestamp","minimumPeriod","muln","iadd"],"mappings":"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","sourcesContent":["// Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { combineLatest, map, of, switchMap } from 'rxjs';\nimport { isNumber, isUndefined } from '@polkadot/util';\nimport { FALLBACK_MAX_HASH_COUNT, FALLBACK_PERIOD, MAX_FINALITY_LAG, MORTAL_PERIOD } from \"./constants.js\";\n\nfunction latestNonce(api, address) {\n  return api.derive.balances.account(address).pipe(map(({\n    accountNonce\n  }) => accountNonce));\n}\n\nfunction nextNonce(api, address) {\n  var _api$rpc$system;\n\n  return (_api$rpc$system = api.rpc.system) !== null && _api$rpc$system !== void 0 && _api$rpc$system.accountNextIndex ? api.rpc.system.accountNextIndex(address) : latestNonce(api, address);\n}\n\nfunction signingHeader(api) {\n  return combineLatest([api.rpc.chain.getHeader(), api.rpc.chain.getFinalizedHead()]).pipe(switchMap(([bestHeader, finHash]) => // retrieve the headers - in the case of the current block, we use the parent\n  // to minimize (not completely remove) the impact that forks do have on the system\n  // (when at genesis, just return the current header as the last known)\n  bestHeader.parentHash.isEmpty ? of([bestHeader, bestHeader]) : combineLatest([api.rpc.chain.getHeader(bestHeader.parentHash), api.rpc.chain.getHeader(finHash)])), map(([current, finalized]) => // determine the hash to use, current when lag > max, else finalized\n  current.number.unwrap().sub(finalized.number.unwrap()).gt(MAX_FINALITY_LAG) ? current : finalized));\n}\n\nexport function signingInfo(_instanceId, api) {\n  // no memo, we want to do this fresh on each run\n  return (address, nonce, era) => combineLatest([// retrieve nonce if none was specified\n  isUndefined(nonce) ? latestNonce(api, address) : nonce === -1 ? nextNonce(api, address) : of(api.registry.createType('Index', nonce)), // if no era (create) or era > 0 (mortal), do block retrieval\n  isUndefined(era) || isNumber(era) && era > 0 ? signingHeader(api) : of(null)]).pipe(map(([nonce, header]) => {\n    var _api$consts$system, _api$consts$system$bl, _api$consts$babe, _api$consts$timestamp;\n\n    return {\n      header,\n      mortalLength: Math.min(((_api$consts$system = api.consts.system) === null || _api$consts$system === void 0 ? void 0 : (_api$consts$system$bl = _api$consts$system.blockHashCount) === null || _api$consts$system$bl === void 0 ? void 0 : _api$consts$system$bl.toNumber()) || FALLBACK_MAX_HASH_COUNT, MORTAL_PERIOD.div(((_api$consts$babe = api.consts.babe) === null || _api$consts$babe === void 0 ? void 0 : _api$consts$babe.expectedBlockTime) || ((_api$consts$timestamp = api.consts.timestamp) === null || _api$consts$timestamp === void 0 ? void 0 : _api$consts$timestamp.minimumPeriod.muln(2)) || FALLBACK_PERIOD).iadd(MAX_FINALITY_LAG).toNumber()),\n      nonce\n    };\n  }));\n}"]},"metadata":{},"sourceType":"module"}