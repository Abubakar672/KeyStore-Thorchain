{"ast":null,"code":"import _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\"; // Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\nimport { assert, hexToU8a, isHex, isNumber, isObject, isString, isU8a, isUndefined, stringCamelCase, stringify, stringUpperFirst, u8aConcat, u8aToHex } from '@polkadot/util';\nimport { Null } from \"../primitive/Null.js\";\nimport { Struct } from \"./Struct.js\";\nimport { mapToTypeMap } from \"./utils/index.js\"; // export interface, this is used in Enum.with, so required as public by TS\n\nfunction isRustEnum(def) {\n  const defValues = Object.values(def);\n\n  if (defValues.some(v => isNumber(v))) {\n    assert(defValues.every(v => isNumber(v) && v >= 0 && v <= 255), 'Invalid number-indexed enum definition');\n    return false;\n  }\n\n  return true;\n}\n\nfunction extractDef(registry, _def) {\n  if (Array.isArray(_def)) {\n    return {\n      def: _def.reduce((def, key, index) => {\n        def[key] = {\n          Type: Null,\n          index\n        };\n        return def;\n      }, {}),\n      isBasic: true,\n      isIndexed: false\n    };\n  }\n\n  let isBasic;\n  let isIndexed;\n  let def;\n\n  if (isRustEnum(_def)) {\n    def = Object.entries(mapToTypeMap(registry, _def)).reduce((def, [key, Type], index) => {\n      def[key] = {\n        Type,\n        index\n      };\n      return def;\n    }, {});\n    isBasic = !Object.values(def).some(({\n      Type\n    }) => Type !== Null);\n    isIndexed = false;\n  } else {\n    def = Object.entries(_def).reduce((def, [key, index]) => {\n      def[key] = {\n        Type: Null,\n        index\n      };\n      return def;\n    }, {});\n    isBasic = true;\n    isIndexed = true;\n  }\n\n  return {\n    def,\n    isBasic,\n    isIndexed\n  };\n}\n\nfunction createFromValue(registry, def, index = 0, value) {\n  const entry = Object.values(def).find(e => e.index === index);\n  assert(!isUndefined(entry), () => `Unable to create Enum via index ${index}, in ${Object.keys(def).join(', ')}`);\n  return {\n    index,\n    value: value instanceof entry.Type ? value : new entry.Type(registry, value)\n  };\n}\n\nfunction decodeFromJSON(registry, def, key, value) {\n  // JSON comes in the form of { \"<type (camelCase)>\": \"<value for type>\" }, here we\n  // additionally force to lower to ensure forward compat\n  const keys = Object.keys(def).map(k => k.toLowerCase());\n  const keyLower = key.toLowerCase();\n  const index = keys.indexOf(keyLower);\n  assert(index !== -1, () => `Cannot map Enum JSON, unable to find '${key}' in ${keys.join(', ')}`);\n\n  try {\n    return createFromValue(registry, def, Object.values(def)[index].index, value);\n  } catch (error) {\n    throw new Error(`Enum(${key}):: ${error.message}`);\n  }\n}\n\nfunction decodeFromString(registry, def, value) {\n  return isHex(value) // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  ? decodeFromValue(registry, def, hexToU8a(value)) : decodeFromJSON(registry, def, value);\n}\n\nfunction decodeFromValue(registry, def, value) {\n  if (isU8a(value)) {\n    // nested, we don't want to match isObject below\n    if (value.length) {\n      return createFromValue(registry, def, value[0], value.subarray(1));\n    }\n  } else if (isNumber(value)) {\n    return createFromValue(registry, def, value);\n  } else if (isString(value)) {\n    return decodeFromString(registry, def, value.toString());\n  } else if (isObject(value)) {\n    const key = Object.keys(value)[0];\n    return decodeFromJSON(registry, def, key, value[key]);\n  } // Worst-case scenario, return the first with default\n\n\n  return createFromValue(registry, def, Object.values(def)[0].index);\n}\n\nfunction decodeEnum(registry, def, value, index) {\n  // NOTE We check the index path first, before looking at values - this allows treating\n  // the optional indexes before anything else, more-specific > less-specific\n  if (isNumber(index)) {\n    return createFromValue(registry, def, index, value); // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  } else if (value instanceof Enum) {\n    return createFromValue(registry, def, value.index, value.value);\n  }\n\n  return decodeFromValue(registry, def, value);\n}\n/**\n * @name Enum\n * @description\n * This implements an enum, that based on the value wraps a different type. It is effectively\n * an extension to enum where the value type is determined by the actual index.\n */\n\n\nvar _def2 = /*#__PURE__*/_classPrivateFieldLooseKey(\"def\");\n\nvar _entryIndex = /*#__PURE__*/_classPrivateFieldLooseKey(\"entryIndex\");\n\nvar _indexes = /*#__PURE__*/_classPrivateFieldLooseKey(\"indexes\");\n\nvar _isBasic = /*#__PURE__*/_classPrivateFieldLooseKey(\"isBasic\");\n\nvar _isIndexed = /*#__PURE__*/_classPrivateFieldLooseKey(\"isIndexed\");\n\nvar _raw = /*#__PURE__*/_classPrivateFieldLooseKey(\"raw\");\n\nexport class Enum {\n  constructor(registry, def, value, index) {\n    this.registry = void 0;\n    this.createdAtHash = void 0;\n    Object.defineProperty(this, _def2, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _entryIndex, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _indexes, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _isBasic, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _isIndexed, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _raw, {\n      writable: true,\n      value: void 0\n    });\n    const defInfo = extractDef(registry, def);\n    const decoded = decodeEnum(registry, defInfo.def, value, index);\n    this.registry = registry;\n    _classPrivateFieldLooseBase(this, _def2)[_def2] = defInfo.def;\n    _classPrivateFieldLooseBase(this, _isBasic)[_isBasic] = defInfo.isBasic;\n    _classPrivateFieldLooseBase(this, _isIndexed)[_isIndexed] = defInfo.isIndexed;\n    _classPrivateFieldLooseBase(this, _indexes)[_indexes] = Object.values(defInfo.def).map(({\n      index\n    }) => index);\n    _classPrivateFieldLooseBase(this, _entryIndex)[_entryIndex] = _classPrivateFieldLooseBase(this, _indexes)[_indexes].indexOf(decoded.index) || 0;\n    _classPrivateFieldLooseBase(this, _raw)[_raw] = decoded.value;\n  }\n\n  static with(Types) {\n    return class extends Enum {\n      constructor(registry, value, index) {\n        super(registry, Types, value, index);\n        Object.keys(_classPrivateFieldLooseBase(this, _def2)[_def2]).forEach(_key => {\n          const name = stringUpperFirst(stringCamelCase(_key.replace(' ', '_')));\n          const askey = `as${name}`;\n          const iskey = `is${name}`;\n          isUndefined(this[iskey]) && Object.defineProperty(this, iskey, {\n            enumerable: true,\n            get: () => this.type === _key\n          });\n          isUndefined(this[askey]) && Object.defineProperty(this, askey, {\n            enumerable: true,\n            get: () => {\n              assert(this[iskey], () => `Cannot convert '${this.type}' via ${askey}`);\n              return this.value;\n            }\n          });\n        });\n      }\n\n    };\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return 1 + _classPrivateFieldLooseBase(this, _raw)[_raw].encodedLength;\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n\n\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description The index of the enum value\n   */\n\n\n  get index() {\n    return _classPrivateFieldLooseBase(this, _indexes)[_indexes][_classPrivateFieldLooseBase(this, _entryIndex)[_entryIndex]];\n  }\n  /**\n   * @description true if this is a basic enum (no values)\n   */\n\n\n  get isBasic() {\n    return _classPrivateFieldLooseBase(this, _isBasic)[_isBasic];\n  }\n  /**\n   * @description Checks if the value is an empty value\n   */\n\n\n  get isEmpty() {\n    return _classPrivateFieldLooseBase(this, _raw)[_raw].isEmpty;\n  }\n  /**\n   * @description Checks if the Enum points to a [[Null]] type\n   */\n\n\n  get isNone() {\n    return _classPrivateFieldLooseBase(this, _raw)[_raw] instanceof Null;\n  }\n  /**\n   * @description Checks if the Enum points to a [[Null]] type\n   * @deprecated use isNone\n   */\n\n\n  get isNull() {\n    return this.isNone;\n  }\n  /**\n   * @description The available keys for this enum\n   */\n\n\n  get defIndexes() {\n    return _classPrivateFieldLooseBase(this, _indexes)[_indexes];\n  }\n  /**\n   * @description The available keys for this enum\n   */\n\n\n  get defKeys() {\n    return Object.keys(_classPrivateFieldLooseBase(this, _def2)[_def2]);\n  }\n  /**\n   * @description The name of the type this enum value represents\n   */\n\n\n  get type() {\n    return this.defKeys[_classPrivateFieldLooseBase(this, _entryIndex)[_entryIndex]];\n  }\n  /**\n   * @description The value of the enum\n   */\n\n\n  get value() {\n    return _classPrivateFieldLooseBase(this, _raw)[_raw];\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n\n\n  eq(other) {\n    // cater for the case where we only pass the enum index\n    if (isNumber(other)) {\n      return this.toNumber() === other;\n    } else if (_classPrivateFieldLooseBase(this, _isBasic)[_isBasic] && isString(other)) {\n      return this.type === other;\n    } else if (isU8a(other)) {\n      return !this.toU8a().some((entry, index) => entry !== other[index]);\n    } else if (isHex(other)) {\n      return this.toHex() === other;\n    } else if (other instanceof Enum) {\n      return this.index === other.index && this.value.eq(other.value);\n    } else if (isObject(other)) {\n      return this.value.eq(other[this.type]);\n    } // compare the actual wrapper value\n\n\n    return this.value.eq(other);\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n\n\n  toHex() {\n    return u8aToHex(this.toU8a());\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman(isExtended) {\n    return _classPrivateFieldLooseBase(this, _isBasic)[_isBasic] || this.isNone ? this.type : {\n      [this.type]: _classPrivateFieldLooseBase(this, _raw)[_raw].toHuman(isExtended)\n    };\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n\n\n  toJSON() {\n    return _classPrivateFieldLooseBase(this, _isBasic)[_isBasic] ? this.type : {\n      [stringCamelCase(this.type)]: _classPrivateFieldLooseBase(this, _raw)[_raw].toJSON()\n    };\n  }\n  /**\n   * @description Returns the number representation for the value\n   */\n\n\n  toNumber() {\n    return this.index;\n  }\n  /**\n   * @description Returns a raw struct representation of the enum types\n   */\n\n\n  _toRawStruct() {\n    if (_classPrivateFieldLooseBase(this, _isBasic)[_isBasic]) {\n      return _classPrivateFieldLooseBase(this, _isIndexed)[_isIndexed] ? this.defKeys.reduce((out, key, index) => {\n        out[key] = _classPrivateFieldLooseBase(this, _indexes)[_indexes][index];\n        return out;\n      }, {}) : this.defKeys;\n    }\n\n    const typeMap = Object.entries(_classPrivateFieldLooseBase(this, _def2)[_def2]).reduce((out, [key, {\n      Type\n    }]) => {\n      out[key] = Type;\n      return out;\n    }, {});\n    return Struct.typesToMap(this.registry, typeMap);\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return stringify({\n      _enum: this._toRawStruct()\n    });\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n\n\n  toString() {\n    return this.isNull ? this.type : stringify(this.toJSON());\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    return u8aConcat(new Uint8Array(isBare ? [] : [this.index]), _classPrivateFieldLooseBase(this, _raw)[_raw].toU8a(isBare));\n  }\n\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/types/codec/Enum.js"],"names":["_classPrivateFieldLooseBase","_classPrivateFieldLooseKey","assert","hexToU8a","isHex","isNumber","isObject","isString","isU8a","isUndefined","stringCamelCase","stringify","stringUpperFirst","u8aConcat","u8aToHex","Null","Struct","mapToTypeMap","isRustEnum","def","defValues","Object","values","some","v","every","extractDef","registry","_def","Array","isArray","reduce","key","index","Type","isBasic","isIndexed","entries","createFromValue","value","entry","find","e","keys","join","decodeFromJSON","map","k","toLowerCase","keyLower","indexOf","error","Error","message","decodeFromString","decodeFromValue","length","subarray","toString","decodeEnum","Enum","_def2","_entryIndex","_indexes","_isBasic","_isIndexed","_raw","constructor","createdAtHash","defineProperty","writable","defInfo","decoded","with","Types","forEach","_key","name","replace","askey","iskey","enumerable","get","type","encodedLength","hash","toU8a","isEmpty","isNone","isNull","defIndexes","defKeys","eq","other","toNumber","toHex","toHuman","isExtended","toJSON","_toRawStruct","out","typeMap","typesToMap","toRawType","_enum","isBare","Uint8Array"],"mappings":"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","sourcesContent":["import _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, hexToU8a, isHex, isNumber, isObject, isString, isU8a, isUndefined, stringCamelCase, stringify, stringUpperFirst, u8aConcat, u8aToHex } from '@polkadot/util';\nimport { Null } from \"../primitive/Null.js\";\nimport { Struct } from \"./Struct.js\";\nimport { mapToTypeMap } from \"./utils/index.js\"; // export interface, this is used in Enum.with, so required as public by TS\n\nfunction isRustEnum(def) {\n  const defValues = Object.values(def);\n\n  if (defValues.some(v => isNumber(v))) {\n    assert(defValues.every(v => isNumber(v) && v >= 0 && v <= 255), 'Invalid number-indexed enum definition');\n    return false;\n  }\n\n  return true;\n}\n\nfunction extractDef(registry, _def) {\n  if (Array.isArray(_def)) {\n    return {\n      def: _def.reduce((def, key, index) => {\n        def[key] = {\n          Type: Null,\n          index\n        };\n        return def;\n      }, {}),\n      isBasic: true,\n      isIndexed: false\n    };\n  }\n\n  let isBasic;\n  let isIndexed;\n  let def;\n\n  if (isRustEnum(_def)) {\n    def = Object.entries(mapToTypeMap(registry, _def)).reduce((def, [key, Type], index) => {\n      def[key] = {\n        Type,\n        index\n      };\n      return def;\n    }, {});\n    isBasic = !Object.values(def).some(({\n      Type\n    }) => Type !== Null);\n    isIndexed = false;\n  } else {\n    def = Object.entries(_def).reduce((def, [key, index]) => {\n      def[key] = {\n        Type: Null,\n        index\n      };\n      return def;\n    }, {});\n    isBasic = true;\n    isIndexed = true;\n  }\n\n  return {\n    def,\n    isBasic,\n    isIndexed\n  };\n}\n\nfunction createFromValue(registry, def, index = 0, value) {\n  const entry = Object.values(def).find(e => e.index === index);\n  assert(!isUndefined(entry), () => `Unable to create Enum via index ${index}, in ${Object.keys(def).join(', ')}`);\n  return {\n    index,\n    value: value instanceof entry.Type ? value : new entry.Type(registry, value)\n  };\n}\n\nfunction decodeFromJSON(registry, def, key, value) {\n  // JSON comes in the form of { \"<type (camelCase)>\": \"<value for type>\" }, here we\n  // additionally force to lower to ensure forward compat\n  const keys = Object.keys(def).map(k => k.toLowerCase());\n  const keyLower = key.toLowerCase();\n  const index = keys.indexOf(keyLower);\n  assert(index !== -1, () => `Cannot map Enum JSON, unable to find '${key}' in ${keys.join(', ')}`);\n\n  try {\n    return createFromValue(registry, def, Object.values(def)[index].index, value);\n  } catch (error) {\n    throw new Error(`Enum(${key}):: ${error.message}`);\n  }\n}\n\nfunction decodeFromString(registry, def, value) {\n  return isHex(value) // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  ? decodeFromValue(registry, def, hexToU8a(value)) : decodeFromJSON(registry, def, value);\n}\n\nfunction decodeFromValue(registry, def, value) {\n  if (isU8a(value)) {\n    // nested, we don't want to match isObject below\n    if (value.length) {\n      return createFromValue(registry, def, value[0], value.subarray(1));\n    }\n  } else if (isNumber(value)) {\n    return createFromValue(registry, def, value);\n  } else if (isString(value)) {\n    return decodeFromString(registry, def, value.toString());\n  } else if (isObject(value)) {\n    const key = Object.keys(value)[0];\n    return decodeFromJSON(registry, def, key, value[key]);\n  } // Worst-case scenario, return the first with default\n\n\n  return createFromValue(registry, def, Object.values(def)[0].index);\n}\n\nfunction decodeEnum(registry, def, value, index) {\n  // NOTE We check the index path first, before looking at values - this allows treating\n  // the optional indexes before anything else, more-specific > less-specific\n  if (isNumber(index)) {\n    return createFromValue(registry, def, index, value); // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  } else if (value instanceof Enum) {\n    return createFromValue(registry, def, value.index, value.value);\n  }\n\n  return decodeFromValue(registry, def, value);\n}\n/**\n * @name Enum\n * @description\n * This implements an enum, that based on the value wraps a different type. It is effectively\n * an extension to enum where the value type is determined by the actual index.\n */\n\n\nvar _def2 = /*#__PURE__*/_classPrivateFieldLooseKey(\"def\");\n\nvar _entryIndex = /*#__PURE__*/_classPrivateFieldLooseKey(\"entryIndex\");\n\nvar _indexes = /*#__PURE__*/_classPrivateFieldLooseKey(\"indexes\");\n\nvar _isBasic = /*#__PURE__*/_classPrivateFieldLooseKey(\"isBasic\");\n\nvar _isIndexed = /*#__PURE__*/_classPrivateFieldLooseKey(\"isIndexed\");\n\nvar _raw = /*#__PURE__*/_classPrivateFieldLooseKey(\"raw\");\n\nexport class Enum {\n  constructor(registry, def, value, index) {\n    this.registry = void 0;\n    this.createdAtHash = void 0;\n    Object.defineProperty(this, _def2, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _entryIndex, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _indexes, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _isBasic, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _isIndexed, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _raw, {\n      writable: true,\n      value: void 0\n    });\n    const defInfo = extractDef(registry, def);\n    const decoded = decodeEnum(registry, defInfo.def, value, index);\n    this.registry = registry;\n    _classPrivateFieldLooseBase(this, _def2)[_def2] = defInfo.def;\n    _classPrivateFieldLooseBase(this, _isBasic)[_isBasic] = defInfo.isBasic;\n    _classPrivateFieldLooseBase(this, _isIndexed)[_isIndexed] = defInfo.isIndexed;\n    _classPrivateFieldLooseBase(this, _indexes)[_indexes] = Object.values(defInfo.def).map(({\n      index\n    }) => index);\n    _classPrivateFieldLooseBase(this, _entryIndex)[_entryIndex] = _classPrivateFieldLooseBase(this, _indexes)[_indexes].indexOf(decoded.index) || 0;\n    _classPrivateFieldLooseBase(this, _raw)[_raw] = decoded.value;\n  }\n\n  static with(Types) {\n    return class extends Enum {\n      constructor(registry, value, index) {\n        super(registry, Types, value, index);\n        Object.keys(_classPrivateFieldLooseBase(this, _def2)[_def2]).forEach(_key => {\n          const name = stringUpperFirst(stringCamelCase(_key.replace(' ', '_')));\n          const askey = `as${name}`;\n          const iskey = `is${name}`;\n          isUndefined(this[iskey]) && Object.defineProperty(this, iskey, {\n            enumerable: true,\n            get: () => this.type === _key\n          });\n          isUndefined(this[askey]) && Object.defineProperty(this, askey, {\n            enumerable: true,\n            get: () => {\n              assert(this[iskey], () => `Cannot convert '${this.type}' via ${askey}`);\n              return this.value;\n            }\n          });\n        });\n      }\n\n    };\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return 1 + _classPrivateFieldLooseBase(this, _raw)[_raw].encodedLength;\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n\n\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description The index of the enum value\n   */\n\n\n  get index() {\n    return _classPrivateFieldLooseBase(this, _indexes)[_indexes][_classPrivateFieldLooseBase(this, _entryIndex)[_entryIndex]];\n  }\n  /**\n   * @description true if this is a basic enum (no values)\n   */\n\n\n  get isBasic() {\n    return _classPrivateFieldLooseBase(this, _isBasic)[_isBasic];\n  }\n  /**\n   * @description Checks if the value is an empty value\n   */\n\n\n  get isEmpty() {\n    return _classPrivateFieldLooseBase(this, _raw)[_raw].isEmpty;\n  }\n  /**\n   * @description Checks if the Enum points to a [[Null]] type\n   */\n\n\n  get isNone() {\n    return _classPrivateFieldLooseBase(this, _raw)[_raw] instanceof Null;\n  }\n  /**\n   * @description Checks if the Enum points to a [[Null]] type\n   * @deprecated use isNone\n   */\n\n\n  get isNull() {\n    return this.isNone;\n  }\n  /**\n   * @description The available keys for this enum\n   */\n\n\n  get defIndexes() {\n    return _classPrivateFieldLooseBase(this, _indexes)[_indexes];\n  }\n  /**\n   * @description The available keys for this enum\n   */\n\n\n  get defKeys() {\n    return Object.keys(_classPrivateFieldLooseBase(this, _def2)[_def2]);\n  }\n  /**\n   * @description The name of the type this enum value represents\n   */\n\n\n  get type() {\n    return this.defKeys[_classPrivateFieldLooseBase(this, _entryIndex)[_entryIndex]];\n  }\n  /**\n   * @description The value of the enum\n   */\n\n\n  get value() {\n    return _classPrivateFieldLooseBase(this, _raw)[_raw];\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n\n\n  eq(other) {\n    // cater for the case where we only pass the enum index\n    if (isNumber(other)) {\n      return this.toNumber() === other;\n    } else if (_classPrivateFieldLooseBase(this, _isBasic)[_isBasic] && isString(other)) {\n      return this.type === other;\n    } else if (isU8a(other)) {\n      return !this.toU8a().some((entry, index) => entry !== other[index]);\n    } else if (isHex(other)) {\n      return this.toHex() === other;\n    } else if (other instanceof Enum) {\n      return this.index === other.index && this.value.eq(other.value);\n    } else if (isObject(other)) {\n      return this.value.eq(other[this.type]);\n    } // compare the actual wrapper value\n\n\n    return this.value.eq(other);\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n\n\n  toHex() {\n    return u8aToHex(this.toU8a());\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman(isExtended) {\n    return _classPrivateFieldLooseBase(this, _isBasic)[_isBasic] || this.isNone ? this.type : {\n      [this.type]: _classPrivateFieldLooseBase(this, _raw)[_raw].toHuman(isExtended)\n    };\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n\n\n  toJSON() {\n    return _classPrivateFieldLooseBase(this, _isBasic)[_isBasic] ? this.type : {\n      [stringCamelCase(this.type)]: _classPrivateFieldLooseBase(this, _raw)[_raw].toJSON()\n    };\n  }\n  /**\n   * @description Returns the number representation for the value\n   */\n\n\n  toNumber() {\n    return this.index;\n  }\n  /**\n   * @description Returns a raw struct representation of the enum types\n   */\n\n\n  _toRawStruct() {\n    if (_classPrivateFieldLooseBase(this, _isBasic)[_isBasic]) {\n      return _classPrivateFieldLooseBase(this, _isIndexed)[_isIndexed] ? this.defKeys.reduce((out, key, index) => {\n        out[key] = _classPrivateFieldLooseBase(this, _indexes)[_indexes][index];\n        return out;\n      }, {}) : this.defKeys;\n    }\n\n    const typeMap = Object.entries(_classPrivateFieldLooseBase(this, _def2)[_def2]).reduce((out, [key, {\n      Type\n    }]) => {\n      out[key] = Type;\n      return out;\n    }, {});\n    return Struct.typesToMap(this.registry, typeMap);\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return stringify({\n      _enum: this._toRawStruct()\n    });\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n\n\n  toString() {\n    return this.isNull ? this.type : stringify(this.toJSON());\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    return u8aConcat(new Uint8Array(isBare ? [] : [this.index]), _classPrivateFieldLooseBase(this, _raw)[_raw].toU8a(isBare));\n  }\n\n}"]},"metadata":{},"sourceType":"module"}