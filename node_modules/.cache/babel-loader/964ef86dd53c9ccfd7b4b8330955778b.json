{"ast":null,"code":"// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isHex, isU8a, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { Option } from \"../codec/Option.js\";\nimport { createClass } from \"./createClass.js\"; // With isPedantic, actually check that the encoding matches that supplied. This\n// is much slower, but verifies that we have the correct types defined\n\nfunction checkInstance(created, matcher) {\n  const u8a = created.toU8a();\n  const rawType = created.toRawType();\n  const isOk = // full match, all ok\n  u8aEq(u8a, matcher) || // on a length-prefixed type, just check the actual length\n  ['Bytes', 'Text', 'Type'].includes(rawType) && matcher.length === created.length || // when the created is empty and matcher is also empty, let it slide...\n  created.isEmpty && matcher.every(v => !v);\n  assert(isOk, () => `${rawType}:: Decoded input doesn't match input, received ${u8aToHex(matcher, 512)} (${matcher.length} bytes), created ${u8aToHex(u8a, 512)} (${u8a.length} bytes)`);\n}\n\nfunction checkPedantic(created, [value], isPedantic = false) {\n  if (isPedantic) {\n    if (isU8a(value)) {\n      checkInstance(created, value);\n    } else if (isHex(value)) {\n      checkInstance(created, u8aToU8a(value));\n    }\n  }\n} // Initializes a type with a value. This also checks for fallbacks and in the cases\n// where isPedantic is specified (storage decoding), also check the format/structure\n\n\nfunction initType(registry, Type, params = [], {\n  blockHash,\n  isOptional,\n  isPedantic\n} = {}) {\n  const created = new (isOptional ? Option.with(Type) : Type)(registry, ...params);\n  checkPedantic(created, params, isPedantic);\n\n  if (blockHash) {\n    created.createdAtHash = createType(registry, 'Hash', blockHash);\n  } // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n\n\n  return created;\n} // An unsafe version of the `createType` below. It's unsafe because the `type`\n// argument here can be any string, which, when it cannot parse, will yield a\n// runtime error.\n\n\nexport function createTypeUnsafe(registry, type, params = [], options = {}) {\n  let Clazz = null;\n  let firstError = null;\n\n  try {\n    Clazz = createClass(registry, type);\n    return initType(registry, Clazz, params, options);\n  } catch (error) {\n    firstError = new Error(`createType(${type}):: ${error.message}`);\n  }\n\n  if (Clazz && Clazz.__fallbackType) {\n    try {\n      Clazz = createClass(registry, Clazz.__fallbackType);\n      return initType(registry, Clazz, params, options);\n    } catch {// swallow, we will throw the first error again\n    }\n  }\n\n  throw firstError;\n}\n/**\n * Create an instance of a `type` with a given `params`.\n * @param type - A recognizable string representing the type to create an\n * instance from\n * @param params - The value to instantiate the type with\n */\n\nexport function createType(registry, type, ...params) {\n  return createTypeUnsafe(registry, type, params);\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/types/create/createType.js"],"names":["assert","isHex","isU8a","u8aEq","u8aToHex","u8aToU8a","Option","createClass","checkInstance","created","matcher","u8a","toU8a","rawType","toRawType","isOk","includes","length","isEmpty","every","v","checkPedantic","value","isPedantic","initType","registry","Type","params","blockHash","isOptional","with","createdAtHash","createType","createTypeUnsafe","type","options","Clazz","firstError","error","Error","message","__fallbackType"],"mappings":"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","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isHex, isU8a, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { Option } from \"../codec/Option.js\";\nimport { createClass } from \"./createClass.js\"; // With isPedantic, actually check that the encoding matches that supplied. This\n// is much slower, but verifies that we have the correct types defined\n\nfunction checkInstance(created, matcher) {\n  const u8a = created.toU8a();\n  const rawType = created.toRawType();\n  const isOk = // full match, all ok\n  u8aEq(u8a, matcher) || // on a length-prefixed type, just check the actual length\n  ['Bytes', 'Text', 'Type'].includes(rawType) && matcher.length === created.length || // when the created is empty and matcher is also empty, let it slide...\n  created.isEmpty && matcher.every(v => !v);\n  assert(isOk, () => `${rawType}:: Decoded input doesn't match input, received ${u8aToHex(matcher, 512)} (${matcher.length} bytes), created ${u8aToHex(u8a, 512)} (${u8a.length} bytes)`);\n}\n\nfunction checkPedantic(created, [value], isPedantic = false) {\n  if (isPedantic) {\n    if (isU8a(value)) {\n      checkInstance(created, value);\n    } else if (isHex(value)) {\n      checkInstance(created, u8aToU8a(value));\n    }\n  }\n} // Initializes a type with a value. This also checks for fallbacks and in the cases\n// where isPedantic is specified (storage decoding), also check the format/structure\n\n\nfunction initType(registry, Type, params = [], {\n  blockHash,\n  isOptional,\n  isPedantic\n} = {}) {\n  const created = new (isOptional ? Option.with(Type) : Type)(registry, ...params);\n  checkPedantic(created, params, isPedantic);\n\n  if (blockHash) {\n    created.createdAtHash = createType(registry, 'Hash', blockHash);\n  } // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n\n\n  return created;\n} // An unsafe version of the `createType` below. It's unsafe because the `type`\n// argument here can be any string, which, when it cannot parse, will yield a\n// runtime error.\n\n\nexport function createTypeUnsafe(registry, type, params = [], options = {}) {\n  let Clazz = null;\n  let firstError = null;\n\n  try {\n    Clazz = createClass(registry, type);\n    return initType(registry, Clazz, params, options);\n  } catch (error) {\n    firstError = new Error(`createType(${type}):: ${error.message}`);\n  }\n\n  if (Clazz && Clazz.__fallbackType) {\n    try {\n      Clazz = createClass(registry, Clazz.__fallbackType);\n      return initType(registry, Clazz, params, options);\n    } catch {// swallow, we will throw the first error again\n    }\n  }\n\n  throw firstError;\n}\n/**\n * Create an instance of a `type` with a given `params`.\n * @param type - A recognizable string representing the type to create an\n * instance from\n * @param params - The value to instantiate the type with\n */\n\nexport function createType(registry, type, ...params) {\n  return createTypeUnsafe(registry, type, params);\n}"]},"metadata":{},"sourceType":"module"}