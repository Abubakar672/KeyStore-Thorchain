{"ast":null,"code":"import _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\"; // Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\nimport { assert, isNull, isU8a, isUndefined, u8aToHex } from '@polkadot/util';\nimport { Null } from \"../primitive/Null.js\";\nimport { typeToConstructor } from \"./utils/index.js\";\n/** @internal */\n\nfunction decodeOptionU8a(registry, Type, value) {\n  return !value.length || value[0] === 0 ? new Null(registry) : new Type(registry, value.subarray(1));\n}\n/** @internal */\n\n\nfunction decodeOption(registry, typeName, value) {\n  if (isNull(value) || isUndefined(value) || value instanceof Null) {\n    return new Null(registry);\n  }\n\n  const Type = typeToConstructor(registry, typeName); // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n  if (value instanceof Option) {\n    return decodeOption(registry, Type, value.value);\n  } else if (value instanceof Type) {\n    // don't re-create, use as it (which also caters for derived types)\n    return value;\n  } else if (isU8a(value)) {\n    // the isU8a check happens last in the if-tree - since the wrapped value\n    // may be an instance of it, so Type and Option checks go in first\n    return decodeOptionU8a(registry, Type, value);\n  }\n\n  return new Type(registry, value);\n}\n/**\n * @name Option\n * @description\n * An Option is an optional field. Basically the first byte indicates that there is\n * is value to follow. If the byte is `1` there is an actual value. So the Option\n * implements that - decodes, checks for optionality and wraps the required structure\n * with a value if/as required/found.\n */\n\n\nvar _Type = /*#__PURE__*/_classPrivateFieldLooseKey(\"Type\");\n\nvar _raw = /*#__PURE__*/_classPrivateFieldLooseKey(\"raw\");\n\nexport class Option {\n  constructor(registry, typeName, value) {\n    this.registry = void 0;\n    this.createdAtHash = void 0;\n    Object.defineProperty(this, _Type, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _raw, {\n      writable: true,\n      value: void 0\n    });\n    this.registry = registry;\n    _classPrivateFieldLooseBase(this, _Type)[_Type] = typeToConstructor(registry, typeName);\n    _classPrivateFieldLooseBase(this, _raw)[_raw] = decodeOption(registry, typeName, value);\n  }\n\n  static with(Type) {\n    return class extends Option {\n      constructor(registry, value) {\n        super(registry, Type, value);\n      }\n\n    };\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    // boolean byte (has value, doesn't have) along with wrapped length\n    return 1 + _classPrivateFieldLooseBase(this, _raw)[_raw].encodedLength;\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n\n\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Checks if the Option has no value\n   */\n\n\n  get isEmpty() {\n    return this.isNone;\n  }\n  /**\n   * @description Checks if the Option has no value\n   */\n\n\n  get isNone() {\n    return _classPrivateFieldLooseBase(this, _raw)[_raw] instanceof Null;\n  }\n  /**\n   * @description Checks if the Option has a value\n   */\n\n\n  get isSome() {\n    return !this.isNone;\n  }\n  /**\n   * @description The actual value for the Option\n   */\n\n\n  get value() {\n    return _classPrivateFieldLooseBase(this, _raw)[_raw];\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n\n\n  eq(other) {\n    if (other instanceof Option) {\n      return this.isSome === other.isSome && this.value.eq(other.value);\n    }\n\n    return this.value.eq(other);\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n\n\n  toHex() {\n    // This attempts to align with the JSON encoding - actually in this case\n    // the isSome value is correct, however the `isNone` may be problematic\n    return this.isNone ? '0x' : u8aToHex(this.toU8a().subarray(1));\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman(isExtended) {\n    return _classPrivateFieldLooseBase(this, _raw)[_raw].toHuman(isExtended);\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n\n\n  toJSON() {\n    return _classPrivateFieldLooseBase(this, _raw)[_raw].toJSON();\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType(isBare) {\n    const wrapped = this.registry.getClassName(_classPrivateFieldLooseBase(this, _Type)[_Type]) || new (_classPrivateFieldLooseBase(this, _Type)[_Type])(this.registry).toRawType();\n    return isBare ? wrapped : `Option<${wrapped}>`;\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n\n\n  toString() {\n    return _classPrivateFieldLooseBase(this, _raw)[_raw].toString();\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    if (isBare) {\n      return _classPrivateFieldLooseBase(this, _raw)[_raw].toU8a(true);\n    }\n\n    const u8a = new Uint8Array(this.encodedLength);\n\n    if (this.isSome) {\n      u8a.set([1]);\n      u8a.set(_classPrivateFieldLooseBase(this, _raw)[_raw].toU8a(), 1);\n    }\n\n    return u8a;\n  }\n  /**\n   * @description Returns the value that the Option represents (if available), throws if null\n   */\n\n\n  unwrap() {\n    assert(this.isSome, 'Option: unwrapping a None value');\n    return _classPrivateFieldLooseBase(this, _raw)[_raw];\n  }\n  /**\n   * @description Returns the value that the Option represents (if available) or defaultValue if none\n   * @param defaultValue The value to return if the option isNone\n   */\n\n\n  unwrapOr(defaultValue) {\n    return this.isSome ? this.unwrap() : defaultValue;\n  }\n  /**\n   * @description Returns the value that the Option represents (if available) or defaultValue if none\n   * @param defaultValue The value to return if the option isNone\n   */\n\n\n  unwrapOrDefault() {\n    return this.isSome ? this.unwrap() : new (_classPrivateFieldLooseBase(this, _Type)[_Type])(this.registry);\n  }\n\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/types/codec/Option.js"],"names":["_classPrivateFieldLooseBase","_classPrivateFieldLooseKey","assert","isNull","isU8a","isUndefined","u8aToHex","Null","typeToConstructor","decodeOptionU8a","registry","Type","value","length","subarray","decodeOption","typeName","Option","_Type","_raw","constructor","createdAtHash","Object","defineProperty","writable","with","encodedLength","hash","toU8a","isEmpty","isNone","isSome","eq","other","toHex","toHuman","isExtended","toJSON","toRawType","isBare","wrapped","getClassName","toString","u8a","Uint8Array","set","unwrap","unwrapOr","defaultValue","unwrapOrDefault"],"mappings":"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","sourcesContent":["import _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isNull, isU8a, isUndefined, u8aToHex } from '@polkadot/util';\nimport { Null } from \"../primitive/Null.js\";\nimport { typeToConstructor } from \"./utils/index.js\";\n/** @internal */\n\nfunction decodeOptionU8a(registry, Type, value) {\n  return !value.length || value[0] === 0 ? new Null(registry) : new Type(registry, value.subarray(1));\n}\n/** @internal */\n\n\nfunction decodeOption(registry, typeName, value) {\n  if (isNull(value) || isUndefined(value) || value instanceof Null) {\n    return new Null(registry);\n  }\n\n  const Type = typeToConstructor(registry, typeName); // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n  if (value instanceof Option) {\n    return decodeOption(registry, Type, value.value);\n  } else if (value instanceof Type) {\n    // don't re-create, use as it (which also caters for derived types)\n    return value;\n  } else if (isU8a(value)) {\n    // the isU8a check happens last in the if-tree - since the wrapped value\n    // may be an instance of it, so Type and Option checks go in first\n    return decodeOptionU8a(registry, Type, value);\n  }\n\n  return new Type(registry, value);\n}\n/**\n * @name Option\n * @description\n * An Option is an optional field. Basically the first byte indicates that there is\n * is value to follow. If the byte is `1` there is an actual value. So the Option\n * implements that - decodes, checks for optionality and wraps the required structure\n * with a value if/as required/found.\n */\n\n\nvar _Type = /*#__PURE__*/_classPrivateFieldLooseKey(\"Type\");\n\nvar _raw = /*#__PURE__*/_classPrivateFieldLooseKey(\"raw\");\n\nexport class Option {\n  constructor(registry, typeName, value) {\n    this.registry = void 0;\n    this.createdAtHash = void 0;\n    Object.defineProperty(this, _Type, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _raw, {\n      writable: true,\n      value: void 0\n    });\n    this.registry = registry;\n    _classPrivateFieldLooseBase(this, _Type)[_Type] = typeToConstructor(registry, typeName);\n    _classPrivateFieldLooseBase(this, _raw)[_raw] = decodeOption(registry, typeName, value);\n  }\n\n  static with(Type) {\n    return class extends Option {\n      constructor(registry, value) {\n        super(registry, Type, value);\n      }\n\n    };\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    // boolean byte (has value, doesn't have) along with wrapped length\n    return 1 + _classPrivateFieldLooseBase(this, _raw)[_raw].encodedLength;\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n\n\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Checks if the Option has no value\n   */\n\n\n  get isEmpty() {\n    return this.isNone;\n  }\n  /**\n   * @description Checks if the Option has no value\n   */\n\n\n  get isNone() {\n    return _classPrivateFieldLooseBase(this, _raw)[_raw] instanceof Null;\n  }\n  /**\n   * @description Checks if the Option has a value\n   */\n\n\n  get isSome() {\n    return !this.isNone;\n  }\n  /**\n   * @description The actual value for the Option\n   */\n\n\n  get value() {\n    return _classPrivateFieldLooseBase(this, _raw)[_raw];\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n\n\n  eq(other) {\n    if (other instanceof Option) {\n      return this.isSome === other.isSome && this.value.eq(other.value);\n    }\n\n    return this.value.eq(other);\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n\n\n  toHex() {\n    // This attempts to align with the JSON encoding - actually in this case\n    // the isSome value is correct, however the `isNone` may be problematic\n    return this.isNone ? '0x' : u8aToHex(this.toU8a().subarray(1));\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman(isExtended) {\n    return _classPrivateFieldLooseBase(this, _raw)[_raw].toHuman(isExtended);\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n\n\n  toJSON() {\n    return _classPrivateFieldLooseBase(this, _raw)[_raw].toJSON();\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType(isBare) {\n    const wrapped = this.registry.getClassName(_classPrivateFieldLooseBase(this, _Type)[_Type]) || new (_classPrivateFieldLooseBase(this, _Type)[_Type])(this.registry).toRawType();\n    return isBare ? wrapped : `Option<${wrapped}>`;\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n\n\n  toString() {\n    return _classPrivateFieldLooseBase(this, _raw)[_raw].toString();\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    if (isBare) {\n      return _classPrivateFieldLooseBase(this, _raw)[_raw].toU8a(true);\n    }\n\n    const u8a = new Uint8Array(this.encodedLength);\n\n    if (this.isSome) {\n      u8a.set([1]);\n      u8a.set(_classPrivateFieldLooseBase(this, _raw)[_raw].toU8a(), 1);\n    }\n\n    return u8a;\n  }\n  /**\n   * @description Returns the value that the Option represents (if available), throws if null\n   */\n\n\n  unwrap() {\n    assert(this.isSome, 'Option: unwrapping a None value');\n    return _classPrivateFieldLooseBase(this, _raw)[_raw];\n  }\n  /**\n   * @description Returns the value that the Option represents (if available) or defaultValue if none\n   * @param defaultValue The value to return if the option isNone\n   */\n\n\n  unwrapOr(defaultValue) {\n    return this.isSome ? this.unwrap() : defaultValue;\n  }\n  /**\n   * @description Returns the value that the Option represents (if available) or defaultValue if none\n   * @param defaultValue The value to return if the option isNone\n   */\n\n\n  unwrapOrDefault() {\n    return this.isSome ? this.unwrap() : new (_classPrivateFieldLooseBase(this, _Type)[_Type])(this.registry);\n  }\n\n}"]},"metadata":{},"sourceType":"module"}