{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Bridge = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _crypto = require(\"../../crypto\");\n\nvar _types = require(\"../../types\");\n/**\n * Bridge\n */\n\n\nvar Bridge = /*#__PURE__*/function () {\n  /**\n   * @param {BncClient} bncClient\n   */\n  function Bridge(bncClient) {\n    (0, _classCallCheck2[\"default\"])(this, Bridge);\n    (0, _defineProperty2[\"default\"])(this, \"_bncClient\", void 0);\n    this._bncClient = bncClient;\n  }\n  /**\n   * transfer smart chain token to binance chain receiver\n   */\n\n\n  (0, _createClass2[\"default\"])(Bridge, [{\n    key: \"transferIn\",\n    value: function () {\n      var _transferIn = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee(_ref) {\n        var sequence, contract_address, refund_addresses, receiver_addresses, amounts, relay_fee, expire_time, symbol, fromAddress, receiverAddresses, refundAddresses, claimHex;\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                sequence = _ref.sequence, contract_address = _ref.contract_address, refund_addresses = _ref.refund_addresses, receiver_addresses = _ref.receiver_addresses, amounts = _ref.amounts, relay_fee = _ref.relay_fee, expire_time = _ref.expire_time, symbol = _ref.symbol, fromAddress = _ref.fromAddress;\n\n                if (!(sequence < 0)) {\n                  _context.next = 3;\n                  break;\n                }\n\n                throw new Error(\"sequence should not be less than 0\");\n\n              case 3:\n                if (contract_address) {\n                  _context.next = 5;\n                  break;\n                }\n\n                throw new Error(\"contract address should not be empty\");\n\n              case 5:\n                if (relay_fee) {\n                  _context.next = 7;\n                  break;\n                }\n\n                throw new Error(\"relay fee should not be empty\");\n\n              case 7:\n                if (symbol) {\n                  _context.next = 9;\n                  break;\n                }\n\n                throw new Error(\"symbol should not be null\");\n\n              case 9:\n                if ((0, _crypto.checkAddress)(fromAddress, this._bncClient.addressPrefix)) {\n                  _context.next = 11;\n                  break;\n                }\n\n                throw new Error(\"fromAddress is not a valid Binance Chain address\");\n\n              case 11:\n                if (!(refund_addresses.length != receiver_addresses.length || refund_addresses.length != amounts.length)) {\n                  _context.next = 13;\n                  break;\n                }\n\n                throw new Error(\"the length of refund address array, recipient address array and transfer amount array must be the same\");\n\n              case 13:\n                receiverAddresses = receiver_addresses.map(function (address) {\n                  var addressHrp = address.startsWith(\"tbnb\") ? \"tbnb\" : \"bnb\";\n\n                  if (!(0, _crypto.checkAddress)(address, addressHrp)) {\n                    throw new Error(\"\".concat(address, \" in receiver_addresses is not a valid Binance Chain address\"));\n                  }\n\n                  return (0, _crypto.decodeAddress)(address);\n                });\n                refundAddresses = refund_addresses.map(function (address) {\n                  if (!address.startsWith(\"0x\")) {\n                    throw new Error(\"\".concat(address, \" is invalid\"));\n                  }\n\n                  return Buffer.from(address.slice(2), \"hex\");\n                });\n                claimHex = Buffer.from(JSON.stringify({\n                  contract_address: contract_address,\n                  refund_addresses: refundAddresses,\n                  receiver_addresses: receiverAddresses,\n                  amounts: amounts,\n                  symbol: symbol,\n                  relay_fee: relay_fee,\n                  expire_time: expire_time\n                })).toString(\"hex\");\n                return _context.abrupt(\"return\", this.buildClaimAndBroadcast({\n                  claimHex: claimHex,\n                  claim_type: _types.ClaimTypes.ClaimTypeTransferIn,\n                  fromAddress: fromAddress,\n                  sequence: sequence\n                }));\n\n              case 17:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function transferIn(_x) {\n        return _transferIn.apply(this, arguments);\n      }\n\n      return transferIn;\n    }()\n    /**\n     * refund tokens to sender if transfer to smart chain failed\n     */\n\n  }, {\n    key: \"transferOutRefund\",\n    value: function () {\n      var _transferOutRefund = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2(_ref2) {\n        var transfer_out_sequence, refund_address, refund_reason, amount, fromAddress, claimHex;\n        return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                transfer_out_sequence = _ref2.transfer_out_sequence, refund_address = _ref2.refund_address, refund_reason = _ref2.refund_reason, amount = _ref2.amount, fromAddress = _ref2.fromAddress;\n\n                if (!(transfer_out_sequence < 0)) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                throw new Error(\"sequence should not be less than 0\");\n\n              case 3:\n                if (amount) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                throw new Error(\"amount should not be empty\");\n\n              case 5:\n                if (refund_reason) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                throw new Error(\"empty refund reason\");\n\n              case 7:\n                if ((0, _crypto.checkAddress)(fromAddress, this._bncClient.addressPrefix)) {\n                  _context2.next = 9;\n                  break;\n                }\n\n                throw new Error(\"fromAddress is not a valid Binance Chain address\");\n\n              case 9:\n                claimHex = Buffer.from(JSON.stringify({\n                  transfer_out_sequence: transfer_out_sequence,\n                  refund_address: refund_address,\n                  amount: amount,\n                  refund_reason: refund_reason\n                })).toString(\"hex\");\n                return _context2.abrupt(\"return\", this.buildClaimAndBroadcast({\n                  claimHex: claimHex,\n                  claim_type: _types.ClaimTypes.ClaimTypeTransferOutRefund,\n                  sequence: transfer_out_sequence,\n                  fromAddress: fromAddress\n                }));\n\n              case 11:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function transferOutRefund(_x2) {\n        return _transferOutRefund.apply(this, arguments);\n      }\n\n      return transferOutRefund;\n    }()\n    /**\n     * bind smart chain token to bep2 token\n     */\n\n  }, {\n    key: \"bind\",\n    value: function () {\n      var _bind = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee3(_ref3) {\n        var contractAddress, contractDecimal, amount, symbol, expireTime, fromAddress, bindMsg;\n        return _regenerator[\"default\"].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                contractAddress = _ref3.contractAddress, contractDecimal = _ref3.contractDecimal, amount = _ref3.amount, symbol = _ref3.symbol, expireTime = _ref3.expireTime, fromAddress = _ref3.fromAddress;\n\n                if ((0, _crypto.checkAddress)(fromAddress, this._bncClient.addressPrefix)) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                throw new Error(\"fromAddress is not a valid Binance Chain address\");\n\n              case 3:\n                if (contractAddress.startsWith(\"0x\")) {\n                  _context3.next = 5;\n                  break;\n                }\n\n                throw new Error(\"contractAddress \\\"\".concat(contractAddress, \"\\\" is invalid\"));\n\n              case 5:\n                bindMsg = new _types.BindMsg({\n                  from: fromAddress,\n                  amount: amount,\n                  contract_address: contractAddress,\n                  contract_decimals: contractDecimal,\n                  expire_time: expireTime,\n                  symbol: symbol\n                });\n                _context3.next = 8;\n                return this.broadcast(bindMsg, fromAddress);\n\n              case 8:\n                return _context3.abrupt(\"return\", _context3.sent);\n\n              case 9:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function bind(_x3) {\n        return _bind.apply(this, arguments);\n      }\n\n      return bind;\n    }()\n    /**\n     * transfer token from Binance Chain to Binance Smart Chain\n     */\n\n  }, {\n    key: \"transferFromBcToBsc\",\n    value: function () {\n      var _transferFromBcToBsc = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee4(_ref4) {\n        var toAddress, amount, symbol, expireTime, fromAddress, transferOut;\n        return _regenerator[\"default\"].wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                toAddress = _ref4.toAddress, amount = _ref4.amount, symbol = _ref4.symbol, expireTime = _ref4.expireTime, fromAddress = _ref4.fromAddress;\n\n                if ((0, _crypto.checkAddress)(fromAddress, this._bncClient.addressPrefix)) {\n                  _context4.next = 3;\n                  break;\n                }\n\n                throw new Error(\"fromAddress is not a valid Binance Chain address\");\n\n              case 3:\n                if (toAddress.startsWith(\"0x\")) {\n                  _context4.next = 5;\n                  break;\n                }\n\n                throw new Error(\"toAddress \\\"\".concat(toAddress, \"\\\" is invalid\"));\n\n              case 5:\n                transferOut = new _types.TransferOutMsg({\n                  from: fromAddress,\n                  to: toAddress,\n                  amount: {\n                    denom: symbol,\n                    amount: amount\n                  },\n                  expire_time: expireTime\n                });\n                return _context4.abrupt(\"return\", this.broadcast(transferOut, fromAddress));\n\n              case 7:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function transferFromBcToBsc(_x4) {\n        return _transferFromBcToBsc.apply(this, arguments);\n      }\n\n      return transferFromBcToBsc;\n    }()\n    /**\n     * update bind request when events from smart chain received\n     */\n\n  }, {\n    key: \"upateBind\",\n    value: function () {\n      var _upateBind = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee5(_ref5) {\n        var sequence, contract_address, symbol, status, fromAddress, claimHex;\n        return _regenerator[\"default\"].wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                sequence = _ref5.sequence, contract_address = _ref5.contract_address, symbol = _ref5.symbol, status = _ref5.status, fromAddress = _ref5.fromAddress;\n\n                if ((0, _crypto.checkAddress)(fromAddress, this._bncClient.addressPrefix)) {\n                  _context5.next = 3;\n                  break;\n                }\n\n                throw new Error(\"fromAddress is not a valid Binance Chain address\");\n\n              case 3:\n                if (contract_address.startsWith(\"0x\")) {\n                  _context5.next = 5;\n                  break;\n                }\n\n                throw new Error(\"toAddress \\\"\".concat(contract_address, \"\\\" is invalid\"));\n\n              case 5:\n                claimHex = Buffer.from(JSON.stringify({\n                  status: status,\n                  symbol: symbol,\n                  contract_address: contract_address\n                })).toString(\"hex\");\n                return _context5.abrupt(\"return\", this.buildClaimAndBroadcast({\n                  claimHex: claimHex,\n                  sequence: sequence,\n                  fromAddress: fromAddress,\n                  claim_type: _types.ClaimTypes.ClaimTypeUpdateBind\n                }));\n\n              case 7:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function upateBind(_x5) {\n        return _upateBind.apply(this, arguments);\n      }\n\n      return upateBind;\n    }()\n  }, {\n    key: \"skipSequence\",\n    value: function () {\n      var _skipSequence = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee6(_ref6) {\n        var sequence, sequenceToSkip, fromAddress, claimHex;\n        return _regenerator[\"default\"].wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                sequence = _ref6.sequence, sequenceToSkip = _ref6.sequenceToSkip, fromAddress = _ref6.fromAddress;\n\n                if (!(sequence < 0)) {\n                  _context6.next = 3;\n                  break;\n                }\n\n                throw new Error(\"sequence should not be less than 0\");\n\n              case 3:\n                if ((0, _crypto.checkAddress)(fromAddress, this._bncClient.addressPrefix)) {\n                  _context6.next = 5;\n                  break;\n                }\n\n                throw new Error(\"fromAddress is not a valid Binance Chain address\");\n\n              case 5:\n                claimHex = Buffer.from(JSON.stringify({\n                  claim_type: _types.ClaimTypes.ClaimTypeUpdateBind,\n                  sequence: sequenceToSkip\n                })).toString(\"hex\");\n                return _context6.abrupt(\"return\", this.buildClaimAndBroadcast({\n                  claimHex: claimHex,\n                  sequence: sequence,\n                  fromAddress: fromAddress,\n                  claim_type: _types.ClaimTypes.ClaimTypeSkipSequence\n                }));\n\n              case 7:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function skipSequence(_x6) {\n        return _skipSequence.apply(this, arguments);\n      }\n\n      return skipSequence;\n    }()\n  }, {\n    key: \"buildClaimAndBroadcast\",\n    value: function () {\n      var _buildClaimAndBroadcast = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee7(_ref7) {\n        var claimHex, claim_type, sequence, fromAddress, claimMsg;\n        return _regenerator[\"default\"].wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                claimHex = _ref7.claimHex, claim_type = _ref7.claim_type, sequence = _ref7.sequence, fromAddress = _ref7.fromAddress;\n                claimMsg = new _types.ClaimMsg({\n                  claim_type: claim_type,\n                  sequence: sequence,\n                  claim: claimHex,\n                  validator_address: fromAddress\n                });\n                _context7.next = 4;\n                return this.broadcast(claimMsg, fromAddress, sequence);\n\n              case 4:\n                return _context7.abrupt(\"return\", _context7.sent);\n\n              case 5:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function buildClaimAndBroadcast(_x7) {\n        return _buildClaimAndBroadcast.apply(this, arguments);\n      }\n\n      return buildClaimAndBroadcast;\n    }()\n  }, {\n    key: \"broadcast\",\n    value: function () {\n      var _broadcast = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee8(msg, fromAddress, sequence) {\n        var signedTx;\n        return _regenerator[\"default\"].wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return this._bncClient._prepareTransaction(msg.getMsg(), msg.getSignMsg(), fromAddress, sequence);\n\n              case 2:\n                signedTx = _context8.sent;\n                return _context8.abrupt(\"return\", this._bncClient._broadcastDelegate(signedTx));\n\n              case 4:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function broadcast(_x8, _x9, _x10) {\n        return _broadcast.apply(this, arguments);\n      }\n\n      return broadcast;\n    }()\n  }]);\n  return Bridge;\n}();\n\nexports.Bridge = Bridge;","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@binance-chain/javascript-sdk/lib/client/bridge/index.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","Bridge","_regenerator","_asyncToGenerator2","_classCallCheck2","_createClass2","_defineProperty2","_crypto","_types","bncClient","_bncClient","key","_transferIn","mark","_callee","_ref","sequence","contract_address","refund_addresses","receiver_addresses","amounts","relay_fee","expire_time","symbol","fromAddress","receiverAddresses","refundAddresses","claimHex","wrap","_callee$","_context","prev","next","Error","checkAddress","addressPrefix","length","map","address","addressHrp","startsWith","concat","decodeAddress","Buffer","from","slice","JSON","stringify","toString","abrupt","buildClaimAndBroadcast","claim_type","ClaimTypes","ClaimTypeTransferIn","stop","transferIn","_x","apply","arguments","_transferOutRefund","_callee2","_ref2","transfer_out_sequence","refund_address","refund_reason","amount","_callee2$","_context2","ClaimTypeTransferOutRefund","transferOutRefund","_x2","_bind","_callee3","_ref3","contractAddress","contractDecimal","expireTime","bindMsg","_callee3$","_context3","BindMsg","contract_decimals","broadcast","sent","bind","_x3","_transferFromBcToBsc","_callee4","_ref4","toAddress","transferOut","_callee4$","_context4","TransferOutMsg","to","denom","transferFromBcToBsc","_x4","_upateBind","_callee5","_ref5","status","_callee5$","_context5","ClaimTypeUpdateBind","upateBind","_x5","_skipSequence","_callee6","_ref6","sequenceToSkip","_callee6$","_context6","ClaimTypeSkipSequence","skipSequence","_x6","_buildClaimAndBroadcast","_callee7","_ref7","claimMsg","_callee7$","_context7","ClaimMsg","claim","validator_address","_x7","_broadcast","_callee8","msg","signedTx","_callee8$","_context8","_prepareTransaction","getMsg","getSignMsg","_broadcastDelegate","_x8","_x9","_x10"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Bridge = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _crypto = require(\"../../crypto\");\n\nvar _types = require(\"../../types\");\n\n/**\n * Bridge\n */\nvar Bridge = /*#__PURE__*/function () {\n  /**\n   * @param {BncClient} bncClient\n   */\n  function Bridge(bncClient) {\n    (0, _classCallCheck2[\"default\"])(this, Bridge);\n    (0, _defineProperty2[\"default\"])(this, \"_bncClient\", void 0);\n    this._bncClient = bncClient;\n  }\n  /**\n   * transfer smart chain token to binance chain receiver\n   */\n\n\n  (0, _createClass2[\"default\"])(Bridge, [{\n    key: \"transferIn\",\n    value: function () {\n      var _transferIn = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee(_ref) {\n        var sequence, contract_address, refund_addresses, receiver_addresses, amounts, relay_fee, expire_time, symbol, fromAddress, receiverAddresses, refundAddresses, claimHex;\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                sequence = _ref.sequence, contract_address = _ref.contract_address, refund_addresses = _ref.refund_addresses, receiver_addresses = _ref.receiver_addresses, amounts = _ref.amounts, relay_fee = _ref.relay_fee, expire_time = _ref.expire_time, symbol = _ref.symbol, fromAddress = _ref.fromAddress;\n\n                if (!(sequence < 0)) {\n                  _context.next = 3;\n                  break;\n                }\n\n                throw new Error(\"sequence should not be less than 0\");\n\n              case 3:\n                if (contract_address) {\n                  _context.next = 5;\n                  break;\n                }\n\n                throw new Error(\"contract address should not be empty\");\n\n              case 5:\n                if (relay_fee) {\n                  _context.next = 7;\n                  break;\n                }\n\n                throw new Error(\"relay fee should not be empty\");\n\n              case 7:\n                if (symbol) {\n                  _context.next = 9;\n                  break;\n                }\n\n                throw new Error(\"symbol should not be null\");\n\n              case 9:\n                if ((0, _crypto.checkAddress)(fromAddress, this._bncClient.addressPrefix)) {\n                  _context.next = 11;\n                  break;\n                }\n\n                throw new Error(\"fromAddress is not a valid Binance Chain address\");\n\n              case 11:\n                if (!(refund_addresses.length != receiver_addresses.length || refund_addresses.length != amounts.length)) {\n                  _context.next = 13;\n                  break;\n                }\n\n                throw new Error(\"the length of refund address array, recipient address array and transfer amount array must be the same\");\n\n              case 13:\n                receiverAddresses = receiver_addresses.map(function (address) {\n                  var addressHrp = address.startsWith(\"tbnb\") ? \"tbnb\" : \"bnb\";\n\n                  if (!(0, _crypto.checkAddress)(address, addressHrp)) {\n                    throw new Error(\"\".concat(address, \" in receiver_addresses is not a valid Binance Chain address\"));\n                  }\n\n                  return (0, _crypto.decodeAddress)(address);\n                });\n                refundAddresses = refund_addresses.map(function (address) {\n                  if (!address.startsWith(\"0x\")) {\n                    throw new Error(\"\".concat(address, \" is invalid\"));\n                  }\n\n                  return Buffer.from(address.slice(2), \"hex\");\n                });\n                claimHex = Buffer.from(JSON.stringify({\n                  contract_address: contract_address,\n                  refund_addresses: refundAddresses,\n                  receiver_addresses: receiverAddresses,\n                  amounts: amounts,\n                  symbol: symbol,\n                  relay_fee: relay_fee,\n                  expire_time: expire_time\n                })).toString(\"hex\");\n                return _context.abrupt(\"return\", this.buildClaimAndBroadcast({\n                  claimHex: claimHex,\n                  claim_type: _types.ClaimTypes.ClaimTypeTransferIn,\n                  fromAddress: fromAddress,\n                  sequence: sequence\n                }));\n\n              case 17:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function transferIn(_x) {\n        return _transferIn.apply(this, arguments);\n      }\n\n      return transferIn;\n    }()\n    /**\n     * refund tokens to sender if transfer to smart chain failed\n     */\n\n  }, {\n    key: \"transferOutRefund\",\n    value: function () {\n      var _transferOutRefund = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2(_ref2) {\n        var transfer_out_sequence, refund_address, refund_reason, amount, fromAddress, claimHex;\n        return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                transfer_out_sequence = _ref2.transfer_out_sequence, refund_address = _ref2.refund_address, refund_reason = _ref2.refund_reason, amount = _ref2.amount, fromAddress = _ref2.fromAddress;\n\n                if (!(transfer_out_sequence < 0)) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                throw new Error(\"sequence should not be less than 0\");\n\n              case 3:\n                if (amount) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                throw new Error(\"amount should not be empty\");\n\n              case 5:\n                if (refund_reason) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                throw new Error(\"empty refund reason\");\n\n              case 7:\n                if ((0, _crypto.checkAddress)(fromAddress, this._bncClient.addressPrefix)) {\n                  _context2.next = 9;\n                  break;\n                }\n\n                throw new Error(\"fromAddress is not a valid Binance Chain address\");\n\n              case 9:\n                claimHex = Buffer.from(JSON.stringify({\n                  transfer_out_sequence: transfer_out_sequence,\n                  refund_address: refund_address,\n                  amount: amount,\n                  refund_reason: refund_reason\n                })).toString(\"hex\");\n                return _context2.abrupt(\"return\", this.buildClaimAndBroadcast({\n                  claimHex: claimHex,\n                  claim_type: _types.ClaimTypes.ClaimTypeTransferOutRefund,\n                  sequence: transfer_out_sequence,\n                  fromAddress: fromAddress\n                }));\n\n              case 11:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function transferOutRefund(_x2) {\n        return _transferOutRefund.apply(this, arguments);\n      }\n\n      return transferOutRefund;\n    }()\n    /**\n     * bind smart chain token to bep2 token\n     */\n\n  }, {\n    key: \"bind\",\n    value: function () {\n      var _bind = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee3(_ref3) {\n        var contractAddress, contractDecimal, amount, symbol, expireTime, fromAddress, bindMsg;\n        return _regenerator[\"default\"].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                contractAddress = _ref3.contractAddress, contractDecimal = _ref3.contractDecimal, amount = _ref3.amount, symbol = _ref3.symbol, expireTime = _ref3.expireTime, fromAddress = _ref3.fromAddress;\n\n                if ((0, _crypto.checkAddress)(fromAddress, this._bncClient.addressPrefix)) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                throw new Error(\"fromAddress is not a valid Binance Chain address\");\n\n              case 3:\n                if (contractAddress.startsWith(\"0x\")) {\n                  _context3.next = 5;\n                  break;\n                }\n\n                throw new Error(\"contractAddress \\\"\".concat(contractAddress, \"\\\" is invalid\"));\n\n              case 5:\n                bindMsg = new _types.BindMsg({\n                  from: fromAddress,\n                  amount: amount,\n                  contract_address: contractAddress,\n                  contract_decimals: contractDecimal,\n                  expire_time: expireTime,\n                  symbol: symbol\n                });\n                _context3.next = 8;\n                return this.broadcast(bindMsg, fromAddress);\n\n              case 8:\n                return _context3.abrupt(\"return\", _context3.sent);\n\n              case 9:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function bind(_x3) {\n        return _bind.apply(this, arguments);\n      }\n\n      return bind;\n    }()\n    /**\n     * transfer token from Binance Chain to Binance Smart Chain\n     */\n\n  }, {\n    key: \"transferFromBcToBsc\",\n    value: function () {\n      var _transferFromBcToBsc = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee4(_ref4) {\n        var toAddress, amount, symbol, expireTime, fromAddress, transferOut;\n        return _regenerator[\"default\"].wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                toAddress = _ref4.toAddress, amount = _ref4.amount, symbol = _ref4.symbol, expireTime = _ref4.expireTime, fromAddress = _ref4.fromAddress;\n\n                if ((0, _crypto.checkAddress)(fromAddress, this._bncClient.addressPrefix)) {\n                  _context4.next = 3;\n                  break;\n                }\n\n                throw new Error(\"fromAddress is not a valid Binance Chain address\");\n\n              case 3:\n                if (toAddress.startsWith(\"0x\")) {\n                  _context4.next = 5;\n                  break;\n                }\n\n                throw new Error(\"toAddress \\\"\".concat(toAddress, \"\\\" is invalid\"));\n\n              case 5:\n                transferOut = new _types.TransferOutMsg({\n                  from: fromAddress,\n                  to: toAddress,\n                  amount: {\n                    denom: symbol,\n                    amount: amount\n                  },\n                  expire_time: expireTime\n                });\n                return _context4.abrupt(\"return\", this.broadcast(transferOut, fromAddress));\n\n              case 7:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function transferFromBcToBsc(_x4) {\n        return _transferFromBcToBsc.apply(this, arguments);\n      }\n\n      return transferFromBcToBsc;\n    }()\n    /**\n     * update bind request when events from smart chain received\n     */\n\n  }, {\n    key: \"upateBind\",\n    value: function () {\n      var _upateBind = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee5(_ref5) {\n        var sequence, contract_address, symbol, status, fromAddress, claimHex;\n        return _regenerator[\"default\"].wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                sequence = _ref5.sequence, contract_address = _ref5.contract_address, symbol = _ref5.symbol, status = _ref5.status, fromAddress = _ref5.fromAddress;\n\n                if ((0, _crypto.checkAddress)(fromAddress, this._bncClient.addressPrefix)) {\n                  _context5.next = 3;\n                  break;\n                }\n\n                throw new Error(\"fromAddress is not a valid Binance Chain address\");\n\n              case 3:\n                if (contract_address.startsWith(\"0x\")) {\n                  _context5.next = 5;\n                  break;\n                }\n\n                throw new Error(\"toAddress \\\"\".concat(contract_address, \"\\\" is invalid\"));\n\n              case 5:\n                claimHex = Buffer.from(JSON.stringify({\n                  status: status,\n                  symbol: symbol,\n                  contract_address: contract_address\n                })).toString(\"hex\");\n                return _context5.abrupt(\"return\", this.buildClaimAndBroadcast({\n                  claimHex: claimHex,\n                  sequence: sequence,\n                  fromAddress: fromAddress,\n                  claim_type: _types.ClaimTypes.ClaimTypeUpdateBind\n                }));\n\n              case 7:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function upateBind(_x5) {\n        return _upateBind.apply(this, arguments);\n      }\n\n      return upateBind;\n    }()\n  }, {\n    key: \"skipSequence\",\n    value: function () {\n      var _skipSequence = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee6(_ref6) {\n        var sequence, sequenceToSkip, fromAddress, claimHex;\n        return _regenerator[\"default\"].wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                sequence = _ref6.sequence, sequenceToSkip = _ref6.sequenceToSkip, fromAddress = _ref6.fromAddress;\n\n                if (!(sequence < 0)) {\n                  _context6.next = 3;\n                  break;\n                }\n\n                throw new Error(\"sequence should not be less than 0\");\n\n              case 3:\n                if ((0, _crypto.checkAddress)(fromAddress, this._bncClient.addressPrefix)) {\n                  _context6.next = 5;\n                  break;\n                }\n\n                throw new Error(\"fromAddress is not a valid Binance Chain address\");\n\n              case 5:\n                claimHex = Buffer.from(JSON.stringify({\n                  claim_type: _types.ClaimTypes.ClaimTypeUpdateBind,\n                  sequence: sequenceToSkip\n                })).toString(\"hex\");\n                return _context6.abrupt(\"return\", this.buildClaimAndBroadcast({\n                  claimHex: claimHex,\n                  sequence: sequence,\n                  fromAddress: fromAddress,\n                  claim_type: _types.ClaimTypes.ClaimTypeSkipSequence\n                }));\n\n              case 7:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function skipSequence(_x6) {\n        return _skipSequence.apply(this, arguments);\n      }\n\n      return skipSequence;\n    }()\n  }, {\n    key: \"buildClaimAndBroadcast\",\n    value: function () {\n      var _buildClaimAndBroadcast = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee7(_ref7) {\n        var claimHex, claim_type, sequence, fromAddress, claimMsg;\n        return _regenerator[\"default\"].wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                claimHex = _ref7.claimHex, claim_type = _ref7.claim_type, sequence = _ref7.sequence, fromAddress = _ref7.fromAddress;\n                claimMsg = new _types.ClaimMsg({\n                  claim_type: claim_type,\n                  sequence: sequence,\n                  claim: claimHex,\n                  validator_address: fromAddress\n                });\n                _context7.next = 4;\n                return this.broadcast(claimMsg, fromAddress, sequence);\n\n              case 4:\n                return _context7.abrupt(\"return\", _context7.sent);\n\n              case 5:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function buildClaimAndBroadcast(_x7) {\n        return _buildClaimAndBroadcast.apply(this, arguments);\n      }\n\n      return buildClaimAndBroadcast;\n    }()\n  }, {\n    key: \"broadcast\",\n    value: function () {\n      var _broadcast = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee8(msg, fromAddress, sequence) {\n        var signedTx;\n        return _regenerator[\"default\"].wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return this._bncClient._prepareTransaction(msg.getMsg(), msg.getSignMsg(), fromAddress, sequence);\n\n              case 2:\n                signedTx = _context8.sent;\n                return _context8.abrupt(\"return\", this._bncClient._broadcastDelegate(signedTx));\n\n              case 4:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function broadcast(_x8, _x9, _x10) {\n        return _broadcast.apply(this, arguments);\n      }\n\n      return broadcast;\n    }()\n  }]);\n  return Bridge;\n}();\n\nexports.Bridge = Bridge;"]},"metadata":{},"sourceType":"script"}