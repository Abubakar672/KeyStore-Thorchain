{"ast":null,"code":"// Copyright 2017-2021 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n// Adapted from the bitcoinjs/bip39 source\n// https://github.com/bitcoinjs/bip39/blob/1d063b6a6aee4145b34d701037cd3e67f5446ff9/ts_src/index.ts\n// Copyright (c) 2014, Wei Lu <luwei.here@gmail.com> and Daniel Cousens <email@dcousens.com>\n// ISC Licence\n//\n// Change made in this version -\n//   - Adjust formatting (just eslint differences)\n//   - Only English wordlist (this aligns with the wasm-crypto implementation)\n//   - Use util-crypto randomAsU8a (instead of randombytes)\n//   - Remove setting of wordlist passing of wordlist in functions\n//   - Remove mnemonicToSeed (we only use the sync variant)\nimport hash from 'hash.js';\nimport { assert, stringToU8a, u8aToU8a } from '@polkadot/util';\nimport { pbkdf2Encode } from \"../pbkdf2/index.js\";\nimport { randomAsU8a } from \"../random/asU8a.js\";\nimport DEFAULT_WORDLIST from \"./bip39-en.js\";\nconst INVALID_MNEMONIC = 'Invalid mnemonic';\nconst INVALID_ENTROPY = 'Invalid entropy';\nconst INVALID_CHECKSUM = 'Invalid mnemonic checksum';\n\nfunction normalize(str) {\n  return (str || '').normalize('NFKD');\n}\n\nfunction binaryToByte(bin) {\n  return parseInt(bin, 2);\n}\n\nfunction bytesToBinary(bytes) {\n  return bytes.map(x => x.toString(2).padStart(8, '0')).join('');\n}\n\nfunction deriveChecksumBits(entropyBuffer) {\n  const ENT = entropyBuffer.length * 8;\n  const CS = ENT / 32;\n  const result = hash.sha256().update(entropyBuffer).digest();\n  return bytesToBinary(Array.from(result)).slice(0, CS);\n}\n\nexport function mnemonicToSeedSync(mnemonic, password) {\n  const mnemonicBuffer = stringToU8a(normalize(mnemonic));\n  const saltBuffer = stringToU8a(`mnemonic${normalize(password)}`);\n  return pbkdf2Encode(mnemonicBuffer, saltBuffer).password;\n}\nexport function mnemonicToEntropy(mnemonic) {\n  var _entropyBits$match;\n\n  const words = normalize(mnemonic).split(' ');\n  assert(words.length % 3 === 0, INVALID_MNEMONIC); // convert word indices to 11 bit binary strings\n\n  const bits = words.map(word => {\n    const index = DEFAULT_WORDLIST.indexOf(word);\n    assert(index !== -1, INVALID_MNEMONIC);\n    return index.toString(2).padStart(11, '0');\n  }).join(''); // split the binary string into ENT/CS\n\n  const dividerIndex = Math.floor(bits.length / 33) * 32;\n  const entropyBits = bits.slice(0, dividerIndex);\n  const checksumBits = bits.slice(dividerIndex); // calculate the checksum and compare\n\n  const entropyBytes = (_entropyBits$match = entropyBits.match(/(.{1,8})/g)) === null || _entropyBits$match === void 0 ? void 0 : _entropyBits$match.map(binaryToByte);\n  assert(entropyBytes && entropyBytes.length % 4 === 0 && entropyBytes.length >= 16 && entropyBytes.length <= 32, INVALID_ENTROPY);\n  const entropy = u8aToU8a(entropyBytes);\n  const newChecksum = deriveChecksumBits(entropy);\n  assert(newChecksum === checksumBits, INVALID_CHECKSUM);\n  return entropy;\n}\nexport function entropyToMnemonic(entropy) {\n  // 128 <= ENT <= 256\n  assert(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, INVALID_ENTROPY);\n  const entropyBits = bytesToBinary(Array.from(entropy));\n  const checksumBits = deriveChecksumBits(entropy); // we just set it prior, so this is a safe check\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n  return (entropyBits + checksumBits).match(/(.{1,11})/g).map(binary => DEFAULT_WORDLIST[binaryToByte(binary)]).join(' ');\n}\nexport function generateMnemonic(strength) {\n  strength = strength || 128;\n  assert(strength % 32 === 0, INVALID_ENTROPY);\n  return entropyToMnemonic(randomAsU8a(strength / 8));\n}\nexport function validateMnemonic(mnemonic) {\n  try {\n    mnemonicToEntropy(mnemonic);\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/util-crypto/mnemonic/bip39.js"],"names":["hash","assert","stringToU8a","u8aToU8a","pbkdf2Encode","randomAsU8a","DEFAULT_WORDLIST","INVALID_MNEMONIC","INVALID_ENTROPY","INVALID_CHECKSUM","normalize","str","binaryToByte","bin","parseInt","bytesToBinary","bytes","map","x","toString","padStart","join","deriveChecksumBits","entropyBuffer","ENT","length","CS","result","sha256","update","digest","Array","from","slice","mnemonicToSeedSync","mnemonic","password","mnemonicBuffer","saltBuffer","mnemonicToEntropy","_entropyBits$match","words","split","bits","word","index","indexOf","dividerIndex","Math","floor","entropyBits","checksumBits","entropyBytes","match","entropy","newChecksum","entropyToMnemonic","binary","generateMnemonic","strength","validateMnemonic","e"],"mappings":"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","sourcesContent":["// Copyright 2017-2021 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n// Adapted from the bitcoinjs/bip39 source\n// https://github.com/bitcoinjs/bip39/blob/1d063b6a6aee4145b34d701037cd3e67f5446ff9/ts_src/index.ts\n// Copyright (c) 2014, Wei Lu <luwei.here@gmail.com> and Daniel Cousens <email@dcousens.com>\n// ISC Licence\n//\n// Change made in this version -\n//   - Adjust formatting (just eslint differences)\n//   - Only English wordlist (this aligns with the wasm-crypto implementation)\n//   - Use util-crypto randomAsU8a (instead of randombytes)\n//   - Remove setting of wordlist passing of wordlist in functions\n//   - Remove mnemonicToSeed (we only use the sync variant)\nimport hash from 'hash.js';\nimport { assert, stringToU8a, u8aToU8a } from '@polkadot/util';\nimport { pbkdf2Encode } from \"../pbkdf2/index.js\";\nimport { randomAsU8a } from \"../random/asU8a.js\";\nimport DEFAULT_WORDLIST from \"./bip39-en.js\";\nconst INVALID_MNEMONIC = 'Invalid mnemonic';\nconst INVALID_ENTROPY = 'Invalid entropy';\nconst INVALID_CHECKSUM = 'Invalid mnemonic checksum';\n\nfunction normalize(str) {\n  return (str || '').normalize('NFKD');\n}\n\nfunction binaryToByte(bin) {\n  return parseInt(bin, 2);\n}\n\nfunction bytesToBinary(bytes) {\n  return bytes.map(x => x.toString(2).padStart(8, '0')).join('');\n}\n\nfunction deriveChecksumBits(entropyBuffer) {\n  const ENT = entropyBuffer.length * 8;\n  const CS = ENT / 32;\n  const result = hash.sha256().update(entropyBuffer).digest();\n  return bytesToBinary(Array.from(result)).slice(0, CS);\n}\n\nexport function mnemonicToSeedSync(mnemonic, password) {\n  const mnemonicBuffer = stringToU8a(normalize(mnemonic));\n  const saltBuffer = stringToU8a(`mnemonic${normalize(password)}`);\n  return pbkdf2Encode(mnemonicBuffer, saltBuffer).password;\n}\nexport function mnemonicToEntropy(mnemonic) {\n  var _entropyBits$match;\n\n  const words = normalize(mnemonic).split(' ');\n  assert(words.length % 3 === 0, INVALID_MNEMONIC); // convert word indices to 11 bit binary strings\n\n  const bits = words.map(word => {\n    const index = DEFAULT_WORDLIST.indexOf(word);\n    assert(index !== -1, INVALID_MNEMONIC);\n    return index.toString(2).padStart(11, '0');\n  }).join(''); // split the binary string into ENT/CS\n\n  const dividerIndex = Math.floor(bits.length / 33) * 32;\n  const entropyBits = bits.slice(0, dividerIndex);\n  const checksumBits = bits.slice(dividerIndex); // calculate the checksum and compare\n\n  const entropyBytes = (_entropyBits$match = entropyBits.match(/(.{1,8})/g)) === null || _entropyBits$match === void 0 ? void 0 : _entropyBits$match.map(binaryToByte);\n  assert(entropyBytes && entropyBytes.length % 4 === 0 && entropyBytes.length >= 16 && entropyBytes.length <= 32, INVALID_ENTROPY);\n  const entropy = u8aToU8a(entropyBytes);\n  const newChecksum = deriveChecksumBits(entropy);\n  assert(newChecksum === checksumBits, INVALID_CHECKSUM);\n  return entropy;\n}\nexport function entropyToMnemonic(entropy) {\n  // 128 <= ENT <= 256\n  assert(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, INVALID_ENTROPY);\n  const entropyBits = bytesToBinary(Array.from(entropy));\n  const checksumBits = deriveChecksumBits(entropy); // we just set it prior, so this is a safe check\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n  return (entropyBits + checksumBits).match(/(.{1,11})/g).map(binary => DEFAULT_WORDLIST[binaryToByte(binary)]).join(' ');\n}\nexport function generateMnemonic(strength) {\n  strength = strength || 128;\n  assert(strength % 32 === 0, INVALID_ENTROPY);\n  return entropyToMnemonic(randomAsU8a(strength / 8));\n}\nexport function validateMnemonic(mnemonic) {\n  try {\n    mnemonicToEntropy(mnemonic);\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n}"]},"metadata":{},"sourceType":"module"}