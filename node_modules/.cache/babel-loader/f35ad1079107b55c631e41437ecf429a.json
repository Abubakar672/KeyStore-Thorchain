{"ast":null,"code":"// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, compactAddLength, compactFromU8a, compactToU8a, isString, isU8a, u8aToU8a } from '@polkadot/util';\nimport { Raw } from \"../codec/Raw.js\"; // Bytes are used for things like on-chain code, so it has a healthy limit\n\nconst MAX_LENGTH = 10 * 1024 * 1024;\n/** @internal */\n\nfunction decodeBytesU8a(value) {\n  if (!value.length) {\n    return new Uint8Array();\n  } // handle all other Uint8Array inputs, these do have a length prefix\n\n\n  const [offset, length] = compactFromU8a(value);\n  const total = offset + length.toNumber();\n  assert(length.lten(MAX_LENGTH), () => `Bytes length ${length.toString()} exceeds ${MAX_LENGTH}`);\n  assert(total <= value.length, () => `Bytes: required length less than remainder, expected at least ${total}, found ${value.length}`);\n  return value.subarray(offset, total);\n}\n/** @internal */\n\n\nfunction decodeBytes(value) {\n  if (Array.isArray(value) || isString(value)) {\n    return u8aToU8a(value);\n  } else if (!(value instanceof Raw) && isU8a(value)) {\n    // We are ensuring we are not a Raw instance. In the case of a Raw we already have gotten\n    // rid of the length, i.e. new Bytes(new Bytes(...)) will work as expected\n    return decodeBytesU8a(value);\n  }\n\n  return value;\n}\n/**\n * @name Bytes\n * @description\n * A Bytes wrapper for Vec<u8>. The significant difference between this and a normal Uint8Array\n * is that this version allows for length-encoding. (i.e. it is a variable-item codec, the same\n * as what is found in [[Text]] and [[Vec]])\n */\n\n\nexport class Bytes extends Raw {\n  constructor(registry, value) {\n    super(registry, decodeBytes(value));\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return this.length + compactToU8a(this.length).length;\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return 'Bytes';\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    return isBare ? super.toU8a(isBare) : compactAddLength(this);\n  }\n\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/types/primitive/Bytes.js"],"names":["assert","compactAddLength","compactFromU8a","compactToU8a","isString","isU8a","u8aToU8a","Raw","MAX_LENGTH","decodeBytesU8a","value","length","Uint8Array","offset","total","toNumber","lten","toString","subarray","decodeBytes","Array","isArray","Bytes","constructor","registry","encodedLength","toRawType","toU8a","isBare"],"mappings":"AAAA;AACA;AACA,SAASA,MAAT,EAAiBC,gBAAjB,EAAmCC,cAAnC,EAAmDC,YAAnD,EAAiEC,QAAjE,EAA2EC,KAA3E,EAAkFC,QAAlF,QAAkG,gBAAlG;AACA,SAASC,GAAT,QAAoB,iBAApB,C,CAAuC;;AAEvC,MAAMC,UAAU,GAAG,KAAK,IAAL,GAAY,IAA/B;AACA;;AAEA,SAASC,cAAT,CAAwBC,KAAxB,EAA+B;AAC7B,MAAI,CAACA,KAAK,CAACC,MAAX,EAAmB;AACjB,WAAO,IAAIC,UAAJ,EAAP;AACD,GAH4B,CAG3B;;;AAGF,QAAM,CAACC,MAAD,EAASF,MAAT,IAAmBT,cAAc,CAACQ,KAAD,CAAvC;AACA,QAAMI,KAAK,GAAGD,MAAM,GAAGF,MAAM,CAACI,QAAP,EAAvB;AACAf,EAAAA,MAAM,CAACW,MAAM,CAACK,IAAP,CAAYR,UAAZ,CAAD,EAA0B,MAAO,gBAAeG,MAAM,CAACM,QAAP,EAAkB,YAAWT,UAAW,EAAxF,CAAN;AACAR,EAAAA,MAAM,CAACc,KAAK,IAAIJ,KAAK,CAACC,MAAhB,EAAwB,MAAO,iEAAgEG,KAAM,WAAUJ,KAAK,CAACC,MAAO,EAA5H,CAAN;AACA,SAAOD,KAAK,CAACQ,QAAN,CAAeL,MAAf,EAAuBC,KAAvB,CAAP;AACD;AACD;;;AAGA,SAASK,WAAT,CAAqBT,KAArB,EAA4B;AAC1B,MAAIU,KAAK,CAACC,OAAN,CAAcX,KAAd,KAAwBN,QAAQ,CAACM,KAAD,CAApC,EAA6C;AAC3C,WAAOJ,QAAQ,CAACI,KAAD,CAAf;AACD,GAFD,MAEO,IAAI,EAAEA,KAAK,YAAYH,GAAnB,KAA2BF,KAAK,CAACK,KAAD,CAApC,EAA6C;AAClD;AACA;AACA,WAAOD,cAAc,CAACC,KAAD,CAArB;AACD;;AAED,SAAOA,KAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,OAAO,MAAMY,KAAN,SAAoBf,GAApB,CAAwB;AAC7BgB,EAAAA,WAAW,CAACC,QAAD,EAAWd,KAAX,EAAkB;AAC3B,UAAMc,QAAN,EAAgBL,WAAW,CAACT,KAAD,CAA3B;AACD;AACD;AACF;AACA;;;AAGmB,MAAbe,aAAa,GAAG;AAClB,WAAO,KAAKd,MAAL,GAAcR,YAAY,CAAC,KAAKQ,MAAN,CAAZ,CAA0BA,MAA/C;AACD;AACD;AACF;AACA;;;AAGEe,EAAAA,SAAS,GAAG;AACV,WAAO,OAAP;AACD;AACD;AACF;AACA;AACA;;;AAGEC,EAAAA,KAAK,CAACC,MAAD,EAAS;AACZ,WAAOA,MAAM,GAAG,MAAMD,KAAN,CAAYC,MAAZ,CAAH,GAAyB3B,gBAAgB,CAAC,IAAD,CAAtD;AACD;;AA5B4B","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, compactAddLength, compactFromU8a, compactToU8a, isString, isU8a, u8aToU8a } from '@polkadot/util';\nimport { Raw } from \"../codec/Raw.js\"; // Bytes are used for things like on-chain code, so it has a healthy limit\n\nconst MAX_LENGTH = 10 * 1024 * 1024;\n/** @internal */\n\nfunction decodeBytesU8a(value) {\n  if (!value.length) {\n    return new Uint8Array();\n  } // handle all other Uint8Array inputs, these do have a length prefix\n\n\n  const [offset, length] = compactFromU8a(value);\n  const total = offset + length.toNumber();\n  assert(length.lten(MAX_LENGTH), () => `Bytes length ${length.toString()} exceeds ${MAX_LENGTH}`);\n  assert(total <= value.length, () => `Bytes: required length less than remainder, expected at least ${total}, found ${value.length}`);\n  return value.subarray(offset, total);\n}\n/** @internal */\n\n\nfunction decodeBytes(value) {\n  if (Array.isArray(value) || isString(value)) {\n    return u8aToU8a(value);\n  } else if (!(value instanceof Raw) && isU8a(value)) {\n    // We are ensuring we are not a Raw instance. In the case of a Raw we already have gotten\n    // rid of the length, i.e. new Bytes(new Bytes(...)) will work as expected\n    return decodeBytesU8a(value);\n  }\n\n  return value;\n}\n/**\n * @name Bytes\n * @description\n * A Bytes wrapper for Vec<u8>. The significant difference between this and a normal Uint8Array\n * is that this version allows for length-encoding. (i.e. it is a variable-item codec, the same\n * as what is found in [[Text]] and [[Vec]])\n */\n\n\nexport class Bytes extends Raw {\n  constructor(registry, value) {\n    super(registry, decodeBytes(value));\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return this.length + compactToU8a(this.length).length;\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return 'Bytes';\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    return isBare ? super.toU8a(isBare) : compactAddLength(this);\n  }\n\n}"]},"metadata":{},"sourceType":"module"}