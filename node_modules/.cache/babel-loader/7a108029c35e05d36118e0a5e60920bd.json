{"ast":null,"code":"// Copyright 2017-2021 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, stringToU8a, u8aFixLength } from '@polkadot/util';\nimport { naclDecrypt } from \"../nacl/index.js\";\nimport { scryptEncode, scryptFromU8a } from \"../scrypt/index.js\";\nimport { ENCODING, NONCE_LENGTH, SCRYPT_LENGTH } from \"./constants.js\";\nexport function jsonDecryptData(encrypted, passphrase, encType = ENCODING) {\n  assert(encrypted, 'No encrypted data available to decode');\n  assert(passphrase || !encType.includes('xsalsa20-poly1305'), 'Password required to decode encrypted data');\n  let encoded = encrypted;\n\n  if (passphrase) {\n    let password;\n\n    if (encType.includes('scrypt')) {\n      const {\n        params,\n        salt\n      } = scryptFromU8a(encrypted);\n      password = scryptEncode(passphrase, salt, params).password;\n      encrypted = encrypted.subarray(SCRYPT_LENGTH);\n    } else {\n      password = stringToU8a(passphrase);\n    }\n\n    encoded = naclDecrypt(encrypted.subarray(NONCE_LENGTH), encrypted.subarray(0, NONCE_LENGTH), u8aFixLength(password, 256, true));\n  }\n\n  assert(encoded, 'Unable to decode using the supplied passphrase');\n  return encoded;\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/util-crypto/json/decryptData.js"],"names":["assert","stringToU8a","u8aFixLength","naclDecrypt","scryptEncode","scryptFromU8a","ENCODING","NONCE_LENGTH","SCRYPT_LENGTH","jsonDecryptData","encrypted","passphrase","encType","includes","encoded","password","params","salt","subarray"],"mappings":"AAAA;AACA;AACA,SAASA,MAAT,EAAiBC,WAAjB,EAA8BC,YAA9B,QAAkD,gBAAlD;AACA,SAASC,WAAT,QAA4B,kBAA5B;AACA,SAASC,YAAT,EAAuBC,aAAvB,QAA4C,oBAA5C;AACA,SAASC,QAAT,EAAmBC,YAAnB,EAAiCC,aAAjC,QAAsD,gBAAtD;AACA,OAAO,SAASC,eAAT,CAAyBC,SAAzB,EAAoCC,UAApC,EAAgDC,OAAO,GAAGN,QAA1D,EAAoE;AACzEN,EAAAA,MAAM,CAACU,SAAD,EAAY,uCAAZ,CAAN;AACAV,EAAAA,MAAM,CAACW,UAAU,IAAI,CAACC,OAAO,CAACC,QAAR,CAAiB,mBAAjB,CAAhB,EAAuD,4CAAvD,CAAN;AACA,MAAIC,OAAO,GAAGJ,SAAd;;AAEA,MAAIC,UAAJ,EAAgB;AACd,QAAII,QAAJ;;AAEA,QAAIH,OAAO,CAACC,QAAR,CAAiB,QAAjB,CAAJ,EAAgC;AAC9B,YAAM;AACJG,QAAAA,MADI;AAEJC,QAAAA;AAFI,UAGFZ,aAAa,CAACK,SAAD,CAHjB;AAIAK,MAAAA,QAAQ,GAAGX,YAAY,CAACO,UAAD,EAAaM,IAAb,EAAmBD,MAAnB,CAAZ,CAAuCD,QAAlD;AACAL,MAAAA,SAAS,GAAGA,SAAS,CAACQ,QAAV,CAAmBV,aAAnB,CAAZ;AACD,KAPD,MAOO;AACLO,MAAAA,QAAQ,GAAGd,WAAW,CAACU,UAAD,CAAtB;AACD;;AAEDG,IAAAA,OAAO,GAAGX,WAAW,CAACO,SAAS,CAACQ,QAAV,CAAmBX,YAAnB,CAAD,EAAmCG,SAAS,CAACQ,QAAV,CAAmB,CAAnB,EAAsBX,YAAtB,CAAnC,EAAwEL,YAAY,CAACa,QAAD,EAAW,GAAX,EAAgB,IAAhB,CAApF,CAArB;AACD;;AAEDf,EAAAA,MAAM,CAACc,OAAD,EAAU,gDAAV,CAAN;AACA,SAAOA,OAAP;AACD","sourcesContent":["// Copyright 2017-2021 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, stringToU8a, u8aFixLength } from '@polkadot/util';\nimport { naclDecrypt } from \"../nacl/index.js\";\nimport { scryptEncode, scryptFromU8a } from \"../scrypt/index.js\";\nimport { ENCODING, NONCE_LENGTH, SCRYPT_LENGTH } from \"./constants.js\";\nexport function jsonDecryptData(encrypted, passphrase, encType = ENCODING) {\n  assert(encrypted, 'No encrypted data available to decode');\n  assert(passphrase || !encType.includes('xsalsa20-poly1305'), 'Password required to decode encrypted data');\n  let encoded = encrypted;\n\n  if (passphrase) {\n    let password;\n\n    if (encType.includes('scrypt')) {\n      const {\n        params,\n        salt\n      } = scryptFromU8a(encrypted);\n      password = scryptEncode(passphrase, salt, params).password;\n      encrypted = encrypted.subarray(SCRYPT_LENGTH);\n    } else {\n      password = stringToU8a(passphrase);\n    }\n\n    encoded = naclDecrypt(encrypted.subarray(NONCE_LENGTH), encrypted.subarray(0, NONCE_LENGTH), u8aFixLength(password, 256, true));\n  }\n\n  assert(encoded, 'Unable to decode using the supplied passphrase');\n  return encoded;\n}"]},"metadata":{},"sourceType":"module"}