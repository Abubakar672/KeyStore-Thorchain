{"ast":null,"code":"/**\n * @license\n * https://github.com/ealmansi/cashaddrjs\n * Copyright (c) 2017-2020 Emilio Almansi\n * Distributed under the MIT software license, see the accompanying\n * file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n */\n'use strict';\n\nvar base32 = require('./base32');\n\nvar bigInt = require('big-integer');\n\nvar convertBits = require('./convertBits');\n\nvar validation = require('./validation');\n\nvar validate = validation.validate;\n/**\n * Encoding and decoding of the new Cash Address format for Bitcoin Cash. <br />\n * Compliant with the original cashaddr specification:\n * {@link https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/cashaddr.md}\n * @module cashaddr\n */\n\n/**\n * Encodes a hash from a given type into a Bitcoin Cash address with the given prefix.\n * \n * @static\n * @param {string} prefix Network prefix. E.g.: 'bitcoincash'.\n * @param {string} type Type of address to generate. Either 'P2PKH' or 'P2SH'.\n * @param {Uint8Array} hash Hash to encode represented as an array of 8-bit integers.\n * @returns {string}\n * @throws {ValidationError}\n */\n\nfunction encode(prefix, type, hash) {\n  validate(typeof prefix === 'string' && isValidPrefix(prefix), 'Invalid prefix: ' + prefix + '.');\n  validate(typeof type === 'string', 'Invalid type: ' + type + '.');\n  validate(hash instanceof Uint8Array, 'Invalid hash: ' + hash + '.');\n  var prefixData = concat(prefixToUint5Array(prefix), new Uint8Array(1));\n  var versionByte = getTypeBits(type) + getHashSizeBits(hash);\n  var payloadData = toUint5Array(concat(new Uint8Array([versionByte]), hash));\n  var checksumData = concat(concat(prefixData, payloadData), new Uint8Array(8));\n  var payload = concat(payloadData, checksumToUint5Array(polymod(checksumData)));\n  return prefix + ':' + base32.encode(payload);\n}\n/**\n * Decodes the given address into its constituting prefix, type and hash. See [#encode()]{@link encode}.\n * \n * @static\n * @param {string} address Address to decode. E.g.: 'bitcoincash:qpm2qsznhks23z7629mms6s4cwef74vcwvy22gdx6a'.\n * @returns {object}\n * @throws {ValidationError}\n */\n\n\nfunction decode(address) {\n  validate(typeof address === 'string' && hasSingleCase(address), 'Invalid address: ' + address + '.');\n  var pieces = address.toLowerCase().split(':');\n  validate(pieces.length === 2, 'Missing prefix: ' + address + '.');\n  var prefix = pieces[0];\n  var payload = base32.decode(pieces[1]);\n  validate(validChecksum(prefix, payload), 'Invalid checksum: ' + address + '.');\n  var payloadData = fromUint5Array(payload.subarray(0, -8));\n  var versionByte = payloadData[0];\n  var hash = payloadData.subarray(1);\n  validate(getHashSize(versionByte) === hash.length * 8, 'Invalid hash size: ' + address + '.');\n  var type = getType(versionByte);\n  return {\n    prefix: prefix,\n    type: type,\n    hash: hash\n  };\n}\n/**\n * Error thrown when encoding or decoding fail due to invalid input.\n *\n * @constructor ValidationError\n * @param {string} message Error description.\n */\n\n\nvar ValidationError = validation.ValidationError;\n/**\n * Valid address prefixes.\n *\n * @private\n */\n\nvar VALID_PREFIXES = ['bitcoincash', 'bchtest', 'bchreg'];\n/**\n * Checks whether a string is a valid prefix; ie., it has a single letter case\n * and is one of 'bitcoincash', 'bchtest', or 'bchreg'.\n *\n * @private\n * @param {string} prefix \n * @returns {boolean}\n */\n\nfunction isValidPrefix(prefix) {\n  return hasSingleCase(prefix) && VALID_PREFIXES.indexOf(prefix.toLowerCase()) !== -1;\n}\n/**\n * Derives an array from the given prefix to be used in the computation\n * of the address' checksum.\n *\n * @private\n * @param {string} prefix Network prefix. E.g.: 'bitcoincash'. \n * @returns {Uint8Array}\n */\n\n\nfunction prefixToUint5Array(prefix) {\n  var result = new Uint8Array(prefix.length);\n\n  for (var i = 0; i < prefix.length; ++i) {\n    result[i] = prefix[i].charCodeAt(0) & 31;\n  }\n\n  return result;\n}\n/**\n * Returns an array representation of the given checksum to be encoded\n * within the address' payload.\n *\n * @private\n * @param {BigInteger} checksum Computed checksum.\n * @returns {Uint8Array}\n */\n\n\nfunction checksumToUint5Array(checksum) {\n  var result = new Uint8Array(8);\n\n  for (var i = 0; i < 8; ++i) {\n    result[7 - i] = checksum.and(31).toJSNumber();\n    checksum = checksum.shiftRight(5);\n  }\n\n  return result;\n}\n/**\n * Returns the bit representation of the given type within the version\n * byte.\n *\n * @private\n * @param {string} type Address type. Either 'P2PKH' or 'P2SH'.\n * @returns {number}\n * @throws {ValidationError}\n */\n\n\nfunction getTypeBits(type) {\n  switch (type) {\n    case 'P2PKH':\n      return 0;\n\n    case 'P2SH':\n      return 8;\n\n    default:\n      throw new ValidationError('Invalid type: ' + type + '.');\n  }\n}\n/**\n * Retrieves the address type from its bit representation within the\n * version byte.\n *\n * @private\n * @param {number} versionByte\n * @returns {string}\n * @throws {ValidationError}\n */\n\n\nfunction getType(versionByte) {\n  switch (versionByte & 120) {\n    case 0:\n      return 'P2PKH';\n\n    case 8:\n      return 'P2SH';\n\n    default:\n      throw new ValidationError('Invalid address type in version byte: ' + versionByte + '.');\n  }\n}\n/**\n * Returns the bit representation of the length in bits of the given\n * hash within the version byte.\n *\n * @private\n * @param {Uint8Array} hash Hash to encode represented as an array of 8-bit integers.\n * @returns {number}\n * @throws {ValidationError}\n */\n\n\nfunction getHashSizeBits(hash) {\n  switch (hash.length * 8) {\n    case 160:\n      return 0;\n\n    case 192:\n      return 1;\n\n    case 224:\n      return 2;\n\n    case 256:\n      return 3;\n\n    case 320:\n      return 4;\n\n    case 384:\n      return 5;\n\n    case 448:\n      return 6;\n\n    case 512:\n      return 7;\n\n    default:\n      throw new ValidationError('Invalid hash size: ' + hash.length + '.');\n  }\n}\n/**\n * Retrieves the the length in bits of the encoded hash from its bit\n * representation within the version byte.\n *\n * @private\n * @param {number} versionByte\n * @returns {number}\n */\n\n\nfunction getHashSize(versionByte) {\n  switch (versionByte & 7) {\n    case 0:\n      return 160;\n\n    case 1:\n      return 192;\n\n    case 2:\n      return 224;\n\n    case 3:\n      return 256;\n\n    case 4:\n      return 320;\n\n    case 5:\n      return 384;\n\n    case 6:\n      return 448;\n\n    case 7:\n      return 512;\n  }\n}\n/**\n * Converts an array of 8-bit integers into an array of 5-bit integers,\n * right-padding with zeroes if necessary.\n *\n * @private\n * @param {Uint8Array} data\n * @returns {Uint8Array}\n */\n\n\nfunction toUint5Array(data) {\n  return convertBits(data, 8, 5);\n}\n/**\n * Converts an array of 5-bit integers back into an array of 8-bit integers,\n * removing extra zeroes left from padding if necessary.\n * Throws a {@link ValidationError} if input is not a zero-padded array of 8-bit integers.\n *\n * @private\n * @param {Uint8Array} data\n * @returns {Uint8Array}\n * @throws {ValidationError}\n */\n\n\nfunction fromUint5Array(data) {\n  return convertBits(data, 5, 8, true);\n}\n/**\n * Returns the concatenation a and b.\n *\n * @private\n * @param {Uint8Array} a \n * @param {Uint8Array} b \n * @returns {Uint8Array}\n * @throws {ValidationError}\n */\n\n\nfunction concat(a, b) {\n  var ab = new Uint8Array(a.length + b.length);\n  ab.set(a);\n  ab.set(b, a.length);\n  return ab;\n}\n/**\n * Computes a checksum from the given input data as specified for the CashAddr\n * format: https://github.com/Bitcoin-UAHF/spec/blob/master/cashaddr.md.\n *\n * @private\n * @param {Uint8Array} data Array of 5-bit integers over which the checksum is to be computed.\n * @returns {BigInteger}\n */\n\n\nfunction polymod(data) {\n  var GENERATOR = [0x98f2bc8e61, 0x79b76d99e2, 0xf33e5fb3c4, 0xae2eabe2a8, 0x1e4f43e470];\n  var checksum = bigInt(1);\n\n  for (var i = 0; i < data.length; ++i) {\n    var value = data[i];\n    var topBits = checksum.shiftRight(35);\n    checksum = checksum.and(0x07ffffffff).shiftLeft(5).xor(value);\n\n    for (var j = 0; j < GENERATOR.length; ++j) {\n      if (topBits.shiftRight(j).and(1).equals(1)) {\n        checksum = checksum.xor(GENERATOR[j]);\n      }\n    }\n  }\n\n  return checksum.xor(1);\n}\n/**\n * Verify that the payload has not been corrupted by checking that the\n * checksum is valid.\n * \n * @private\n * @param {string} prefix Network prefix. E.g.: 'bitcoincash'.\n * @param {Uint8Array} payload Array of 5-bit integers containing the address' payload.\n * @returns {boolean}\n */\n\n\nfunction validChecksum(prefix, payload) {\n  var prefixData = concat(prefixToUint5Array(prefix), new Uint8Array(1));\n  var checksumData = concat(prefixData, payload);\n  return polymod(checksumData).equals(0);\n}\n/**\n * Returns true if, and only if, the given string contains either uppercase\n * or lowercase letters, but not both.\n *\n * @private\n * @param {string} string Input string.\n * @returns {boolean}\n */\n\n\nfunction hasSingleCase(string) {\n  return string === string.toLowerCase() || string === string.toUpperCase();\n}\n\nmodule.exports = {\n  encode: encode,\n  decode: decode,\n  ValidationError: ValidationError\n};","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/cashaddrjs/src/cashaddr.js"],"names":["base32","require","bigInt","convertBits","validation","validate","encode","prefix","type","hash","isValidPrefix","Uint8Array","prefixData","concat","prefixToUint5Array","versionByte","getTypeBits","getHashSizeBits","payloadData","toUint5Array","checksumData","payload","checksumToUint5Array","polymod","decode","address","hasSingleCase","pieces","toLowerCase","split","length","validChecksum","fromUint5Array","subarray","getHashSize","getType","ValidationError","VALID_PREFIXES","indexOf","result","i","charCodeAt","checksum","and","toJSNumber","shiftRight","data","a","b","ab","set","GENERATOR","value","topBits","shiftLeft","xor","j","equals","string","toUpperCase","module","exports"],"mappings":"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","sourcesContent":["/**\n * @license\n * https://github.com/ealmansi/cashaddrjs\n * Copyright (c) 2017-2020 Emilio Almansi\n * Distributed under the MIT software license, see the accompanying\n * file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n */\n\n'use strict';\n\nvar base32 = require('./base32');\nvar bigInt = require('big-integer');\nvar convertBits = require('./convertBits');\nvar validation = require('./validation');\nvar validate = validation.validate;\n\n/**\n * Encoding and decoding of the new Cash Address format for Bitcoin Cash. <br />\n * Compliant with the original cashaddr specification:\n * {@link https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/cashaddr.md}\n * @module cashaddr\n */\n\n/**\n * Encodes a hash from a given type into a Bitcoin Cash address with the given prefix.\n * \n * @static\n * @param {string} prefix Network prefix. E.g.: 'bitcoincash'.\n * @param {string} type Type of address to generate. Either 'P2PKH' or 'P2SH'.\n * @param {Uint8Array} hash Hash to encode represented as an array of 8-bit integers.\n * @returns {string}\n * @throws {ValidationError}\n */\nfunction encode(prefix, type, hash) {\n  validate(typeof prefix === 'string' && isValidPrefix(prefix), 'Invalid prefix: ' + prefix + '.');\n  validate(typeof type === 'string', 'Invalid type: ' + type + '.');\n  validate(hash instanceof Uint8Array, 'Invalid hash: ' + hash + '.');\n  var prefixData = concat(prefixToUint5Array(prefix), new Uint8Array(1));\n  var versionByte = getTypeBits(type) + getHashSizeBits(hash);\n  var payloadData = toUint5Array(concat(new Uint8Array([versionByte]), hash));\n  var checksumData = concat(concat(prefixData, payloadData), new Uint8Array(8));\n  var payload = concat(payloadData, checksumToUint5Array(polymod(checksumData)));\n  return prefix + ':' + base32.encode(payload);\n}\n\n/**\n * Decodes the given address into its constituting prefix, type and hash. See [#encode()]{@link encode}.\n * \n * @static\n * @param {string} address Address to decode. E.g.: 'bitcoincash:qpm2qsznhks23z7629mms6s4cwef74vcwvy22gdx6a'.\n * @returns {object}\n * @throws {ValidationError}\n */\nfunction decode(address) {\n  validate(typeof address === 'string' && hasSingleCase(address), 'Invalid address: ' + address + '.');\n  var pieces = address.toLowerCase().split(':');\n  validate(pieces.length === 2, 'Missing prefix: ' + address + '.');\n  var prefix = pieces[0];\n  var payload = base32.decode(pieces[1]);\n  validate(validChecksum(prefix, payload), 'Invalid checksum: ' + address + '.');\n  var payloadData = fromUint5Array(payload.subarray(0, -8));\n  var versionByte = payloadData[0];\n  var hash = payloadData.subarray(1);\n  validate(getHashSize(versionByte) === hash.length * 8, 'Invalid hash size: ' + address + '.');\n  var type = getType(versionByte);\n  return {\n    prefix: prefix,\n    type: type,\n    hash: hash,\n  };\n}\n\n/**\n * Error thrown when encoding or decoding fail due to invalid input.\n *\n * @constructor ValidationError\n * @param {string} message Error description.\n */\nvar ValidationError = validation.ValidationError;\n\n/**\n * Valid address prefixes.\n *\n * @private\n */\nvar VALID_PREFIXES = ['bitcoincash', 'bchtest', 'bchreg'];\n\n/**\n * Checks whether a string is a valid prefix; ie., it has a single letter case\n * and is one of 'bitcoincash', 'bchtest', or 'bchreg'.\n *\n * @private\n * @param {string} prefix \n * @returns {boolean}\n */\nfunction isValidPrefix(prefix) {\n  return hasSingleCase(prefix) && VALID_PREFIXES.indexOf(prefix.toLowerCase()) !== -1;\n}\n\n/**\n * Derives an array from the given prefix to be used in the computation\n * of the address' checksum.\n *\n * @private\n * @param {string} prefix Network prefix. E.g.: 'bitcoincash'. \n * @returns {Uint8Array}\n */\nfunction prefixToUint5Array(prefix) {\n  var result = new Uint8Array(prefix.length);\n  for (var i = 0; i < prefix.length; ++i) {\n    result[i] = prefix[i].charCodeAt(0) & 31;\n  }\n  return result;\n}\n\n/**\n * Returns an array representation of the given checksum to be encoded\n * within the address' payload.\n *\n * @private\n * @param {BigInteger} checksum Computed checksum.\n * @returns {Uint8Array}\n */\nfunction checksumToUint5Array(checksum) {\n  var result = new Uint8Array(8);\n  for (var i = 0; i < 8; ++i) {\n    result[7 - i] = checksum.and(31).toJSNumber();\n    checksum = checksum.shiftRight(5);\n  }\n  return result;\n}\n\n/**\n * Returns the bit representation of the given type within the version\n * byte.\n *\n * @private\n * @param {string} type Address type. Either 'P2PKH' or 'P2SH'.\n * @returns {number}\n * @throws {ValidationError}\n */\nfunction getTypeBits(type) {\n  switch (type) {\n  case 'P2PKH':\n    return 0;\n  case 'P2SH':\n    return 8;\n  default:\n    throw new ValidationError('Invalid type: ' + type + '.');\n  }\n}\n\n/**\n * Retrieves the address type from its bit representation within the\n * version byte.\n *\n * @private\n * @param {number} versionByte\n * @returns {string}\n * @throws {ValidationError}\n */\nfunction getType(versionByte) {\n  switch (versionByte & 120) {\n  case 0:\n    return 'P2PKH';\n  case 8:\n    return 'P2SH';\n  default:\n    throw new ValidationError('Invalid address type in version byte: ' + versionByte + '.');\n  }\n}\n\n/**\n * Returns the bit representation of the length in bits of the given\n * hash within the version byte.\n *\n * @private\n * @param {Uint8Array} hash Hash to encode represented as an array of 8-bit integers.\n * @returns {number}\n * @throws {ValidationError}\n */\nfunction getHashSizeBits(hash) {\n  switch (hash.length * 8) {\n  case 160:\n    return 0;\n  case 192:\n    return 1;\n  case 224:\n    return 2;\n  case 256:\n    return 3;\n  case 320:\n    return 4;\n  case 384:\n    return 5;\n  case 448:\n    return 6;\n  case 512:\n    return 7;\n  default:\n    throw new ValidationError('Invalid hash size: ' + hash.length + '.');\n  }\n}\n\n/**\n * Retrieves the the length in bits of the encoded hash from its bit\n * representation within the version byte.\n *\n * @private\n * @param {number} versionByte\n * @returns {number}\n */\nfunction getHashSize(versionByte) {\n  switch (versionByte & 7) {\n  case 0:\n    return 160;\n  case 1:\n    return 192;\n  case 2:\n    return 224;\n  case 3:\n    return 256;\n  case 4:\n    return 320;\n  case 5:\n    return 384;\n  case 6:\n    return 448;\n  case 7:\n    return 512;\n  }\n}\n\n/**\n * Converts an array of 8-bit integers into an array of 5-bit integers,\n * right-padding with zeroes if necessary.\n *\n * @private\n * @param {Uint8Array} data\n * @returns {Uint8Array}\n */\nfunction toUint5Array(data) {\n  return convertBits(data, 8, 5);\n}\n\n/**\n * Converts an array of 5-bit integers back into an array of 8-bit integers,\n * removing extra zeroes left from padding if necessary.\n * Throws a {@link ValidationError} if input is not a zero-padded array of 8-bit integers.\n *\n * @private\n * @param {Uint8Array} data\n * @returns {Uint8Array}\n * @throws {ValidationError}\n */\nfunction fromUint5Array(data) {\n  return convertBits(data, 5, 8, true);\n}\n\n/**\n * Returns the concatenation a and b.\n *\n * @private\n * @param {Uint8Array} a \n * @param {Uint8Array} b \n * @returns {Uint8Array}\n * @throws {ValidationError}\n */\nfunction concat(a, b) {\n  var ab = new Uint8Array(a.length + b.length);\n  ab.set(a);\n  ab.set(b, a.length);\n  return ab;\n}\n\n/**\n * Computes a checksum from the given input data as specified for the CashAddr\n * format: https://github.com/Bitcoin-UAHF/spec/blob/master/cashaddr.md.\n *\n * @private\n * @param {Uint8Array} data Array of 5-bit integers over which the checksum is to be computed.\n * @returns {BigInteger}\n */\nfunction polymod(data) {\n  var GENERATOR = [0x98f2bc8e61, 0x79b76d99e2, 0xf33e5fb3c4, 0xae2eabe2a8, 0x1e4f43e470];\n  var checksum = bigInt(1);\n  for (var i = 0; i < data.length; ++i) {\n    var value = data[i];\n    var topBits = checksum.shiftRight(35);\n    checksum = checksum.and(0x07ffffffff).shiftLeft(5).xor(value);\n    for (var j = 0; j < GENERATOR.length; ++j) {\n      if (topBits.shiftRight(j).and(1).equals(1)) {\n        checksum = checksum.xor(GENERATOR[j]);\n      }\n    }\n  }\n  return checksum.xor(1);\n}\n\n/**\n * Verify that the payload has not been corrupted by checking that the\n * checksum is valid.\n * \n * @private\n * @param {string} prefix Network prefix. E.g.: 'bitcoincash'.\n * @param {Uint8Array} payload Array of 5-bit integers containing the address' payload.\n * @returns {boolean}\n */\nfunction validChecksum(prefix, payload) {\n  var prefixData = concat(prefixToUint5Array(prefix), new Uint8Array(1));\n  var checksumData = concat(prefixData, payload);\n  return polymod(checksumData).equals(0);\n}\n\n/**\n * Returns true if, and only if, the given string contains either uppercase\n * or lowercase letters, but not both.\n *\n * @private\n * @param {string} string Input string.\n * @returns {boolean}\n */\nfunction hasSingleCase(string) {\n  return string === string.toLowerCase() || string === string.toUpperCase();\n}\n\nmodule.exports = {\n  encode: encode,\n  decode: decode,\n  ValidationError: ValidationError,\n};\n"]},"metadata":{},"sourceType":"script"}