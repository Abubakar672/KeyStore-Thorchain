{"ast":null,"code":"var typeforce = require('typeforce');\n\nvar types = require('./types');\n\nvar BigInteger = require('bigi');\n\nvar ECSignature = require('./ecsignature');\n\nvar ecurve = require('ecurve');\n\nvar secp256k1 = ecurve.getCurveByName('secp256k1');\n\nvar deterministicGenerateK = require('./rfc6979').deterministicGenerateK;\n\nvar N_OVER_TWO = secp256k1.n.shiftRight(1);\n\nfunction sign(hash, d) {\n  typeforce(types.tuple(types.Hash256bit, types.BigInt), arguments);\n  var x = d.toBuffer(32);\n  var e = BigInteger.fromBuffer(hash);\n  var n = secp256k1.n;\n  var G = secp256k1.G;\n  var r, s;\n  deterministicGenerateK(hash, x, function (k) {\n    var Q = G.multiply(k);\n    if (secp256k1.isInfinity(Q)) return false;\n    r = Q.affineX.mod(n);\n    if (r.signum() === 0) return false;\n    s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);\n    if (s.signum() === 0) return false;\n    return true;\n  }); // enforce low S values, see bip62: 'low s values in signatures'\n\n  if (s.compareTo(N_OVER_TWO) > 0) {\n    s = n.subtract(s);\n  }\n\n  return new ECSignature(r, s);\n}\n\nfunction verify(hash, signature, Q) {\n  typeforce(types.tuple(types.Hash256bit, types.ECSignature, types.ECPoint), arguments);\n  var n = secp256k1.n;\n  var G = secp256k1.G;\n  var r = signature.r;\n  var s = signature.s; // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1]\n\n  if (r.signum() <= 0 || r.compareTo(n) >= 0) return false;\n  if (s.signum() <= 0 || s.compareTo(n) >= 0) return false; // 1.4.2 H = Hash(M), already done by the user\n  // 1.4.3 e = H\n\n  var e = BigInteger.fromBuffer(hash); // Compute s^-1\n\n  var sInv = s.modInverse(n); // 1.4.4 Compute u1 = es^−1 mod n\n  //               u2 = rs^−1 mod n\n\n  var u1 = e.multiply(sInv).mod(n);\n  var u2 = r.multiply(sInv).mod(n); // 1.4.5 Compute R = (xR, yR)\n  //               R = u1G + u2Q\n\n  var R = G.multiplyTwo(u1, Q, u2); // 1.4.5 (cont.) Enforce R is not at infinity\n\n  if (secp256k1.isInfinity(R)) return false; // 1.4.6 Convert the field element R.x to an integer\n\n  var xR = R.affineX; // 1.4.7 Set v = xR mod n\n\n  var v = xR.mod(n); // 1.4.8 If v = r, output \"valid\", and if v != r, output \"invalid\"\n\n  return v.equals(r);\n}\n\nmodule.exports = {\n  deterministicGenerateK: deterministicGenerateK,\n  sign: sign,\n  verify: verify,\n  // TODO: remove\n  __curve: secp256k1\n};","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@psf/bitcoincashjs-lib/src/ecdsa.js"],"names":["typeforce","require","types","BigInteger","ECSignature","ecurve","secp256k1","getCurveByName","deterministicGenerateK","N_OVER_TWO","n","shiftRight","sign","hash","d","tuple","Hash256bit","BigInt","arguments","x","toBuffer","e","fromBuffer","G","r","s","k","Q","multiply","isInfinity","affineX","mod","signum","modInverse","add","compareTo","subtract","verify","signature","ECPoint","sInv","u1","u2","R","multiplyTwo","xR","v","equals","module","exports","__curve"],"mappings":"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","sourcesContent":["var typeforce = require('typeforce')\nvar types = require('./types')\n\nvar BigInteger = require('bigi')\nvar ECSignature = require('./ecsignature')\n\nvar ecurve = require('ecurve')\nvar secp256k1 = ecurve.getCurveByName('secp256k1')\n\nvar deterministicGenerateK = require('./rfc6979').deterministicGenerateK\n\nvar N_OVER_TWO = secp256k1.n.shiftRight(1)\n\nfunction sign (hash, d) {\n  typeforce(types.tuple(types.Hash256bit, types.BigInt), arguments)\n\n  var x = d.toBuffer(32)\n  var e = BigInteger.fromBuffer(hash)\n  var n = secp256k1.n\n  var G = secp256k1.G\n\n  var r, s\n  deterministicGenerateK(hash, x, function (k) {\n    var Q = G.multiply(k)\n\n    if (secp256k1.isInfinity(Q)) return false\n\n    r = Q.affineX.mod(n)\n    if (r.signum() === 0) return false\n\n    s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n)\n    if (s.signum() === 0) return false\n\n    return true\n  })\n\n  // enforce low S values, see bip62: 'low s values in signatures'\n  if (s.compareTo(N_OVER_TWO) > 0) {\n    s = n.subtract(s)\n  }\n\n  return new ECSignature(r, s)\n}\n\nfunction verify (hash, signature, Q) {\n  typeforce(types.tuple(\n    types.Hash256bit,\n    types.ECSignature,\n    types.ECPoint\n  ), arguments)\n\n  var n = secp256k1.n\n  var G = secp256k1.G\n\n  var r = signature.r\n  var s = signature.s\n\n  // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1]\n  if (r.signum() <= 0 || r.compareTo(n) >= 0) return false\n  if (s.signum() <= 0 || s.compareTo(n) >= 0) return false\n\n  // 1.4.2 H = Hash(M), already done by the user\n  // 1.4.3 e = H\n  var e = BigInteger.fromBuffer(hash)\n\n  // Compute s^-1\n  var sInv = s.modInverse(n)\n\n  // 1.4.4 Compute u1 = es^−1 mod n\n  //               u2 = rs^−1 mod n\n  var u1 = e.multiply(sInv).mod(n)\n  var u2 = r.multiply(sInv).mod(n)\n\n  // 1.4.5 Compute R = (xR, yR)\n  //               R = u1G + u2Q\n  var R = G.multiplyTwo(u1, Q, u2)\n\n  // 1.4.5 (cont.) Enforce R is not at infinity\n  if (secp256k1.isInfinity(R)) return false\n\n  // 1.4.6 Convert the field element R.x to an integer\n  var xR = R.affineX\n\n  // 1.4.7 Set v = xR mod n\n  var v = xR.mod(n)\n\n  // 1.4.8 If v = r, output \"valid\", and if v != r, output \"invalid\"\n  return v.equals(r)\n}\n\nmodule.exports = {\n  deterministicGenerateK: deterministicGenerateK,\n  sign: sign,\n  verify: verify,\n\n  // TODO: remove\n  __curve: secp256k1\n}\n"]},"metadata":{},"sourceType":"script"}