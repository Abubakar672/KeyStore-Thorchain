{"ast":null,"code":"// Copyright 2017-2021 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { keccakAsU8a } from \"../keccak/index.js\";\nimport { secp256k1Expand } from \"../secp256k1/index.js\";\n\nfunction getH160(u8a) {\n  if ([33, 65].includes(u8a.length)) {\n    u8a = keccakAsU8a(secp256k1Expand(u8a));\n  }\n\n  return u8a.slice(-20);\n}\n\nexport function ethereumEncode(addressOrPublic) {\n  if (!addressOrPublic) {\n    return '0x';\n  }\n\n  const u8aAddress = u8aToU8a(addressOrPublic);\n  assert([20, 32, 33, 65].includes(u8aAddress.length), 'Invalid address or publicKey passed');\n  const address = u8aToHex(getH160(u8aAddress), -1, false);\n  const hash = u8aToHex(keccakAsU8a(address), -1, false);\n  let result = '';\n\n  for (let index = 0; index < 40; index++) {\n    result = `${result}${parseInt(hash[index], 16) > 7 ? address[index].toUpperCase() : address[index]}`;\n  }\n\n  return `0x${result}`;\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/util-crypto/ethereum/encode.js"],"names":["assert","u8aToHex","u8aToU8a","keccakAsU8a","secp256k1Expand","getH160","u8a","includes","length","slice","ethereumEncode","addressOrPublic","u8aAddress","address","hash","result","index","parseInt","toUpperCase"],"mappings":"AAAA;AACA;AACA,SAASA,MAAT,EAAiBC,QAAjB,EAA2BC,QAA3B,QAA2C,gBAA3C;AACA,SAASC,WAAT,QAA4B,oBAA5B;AACA,SAASC,eAAT,QAAgC,uBAAhC;;AAEA,SAASC,OAAT,CAAiBC,GAAjB,EAAsB;AACpB,MAAI,CAAC,EAAD,EAAK,EAAL,EAASC,QAAT,CAAkBD,GAAG,CAACE,MAAtB,CAAJ,EAAmC;AACjCF,IAAAA,GAAG,GAAGH,WAAW,CAACC,eAAe,CAACE,GAAD,CAAhB,CAAjB;AACD;;AAED,SAAOA,GAAG,CAACG,KAAJ,CAAU,CAAC,EAAX,CAAP;AACD;;AAED,OAAO,SAASC,cAAT,CAAwBC,eAAxB,EAAyC;AAC9C,MAAI,CAACA,eAAL,EAAsB;AACpB,WAAO,IAAP;AACD;;AAED,QAAMC,UAAU,GAAGV,QAAQ,CAACS,eAAD,CAA3B;AACAX,EAAAA,MAAM,CAAC,CAAC,EAAD,EAAK,EAAL,EAAS,EAAT,EAAa,EAAb,EAAiBO,QAAjB,CAA0BK,UAAU,CAACJ,MAArC,CAAD,EAA+C,qCAA/C,CAAN;AACA,QAAMK,OAAO,GAAGZ,QAAQ,CAACI,OAAO,CAACO,UAAD,CAAR,EAAsB,CAAC,CAAvB,EAA0B,KAA1B,CAAxB;AACA,QAAME,IAAI,GAAGb,QAAQ,CAACE,WAAW,CAACU,OAAD,CAAZ,EAAuB,CAAC,CAAxB,EAA2B,KAA3B,CAArB;AACA,MAAIE,MAAM,GAAG,EAAb;;AAEA,OAAK,IAAIC,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAG,EAA5B,EAAgCA,KAAK,EAArC,EAAyC;AACvCD,IAAAA,MAAM,GAAI,GAAEA,MAAO,GAAEE,QAAQ,CAACH,IAAI,CAACE,KAAD,CAAL,EAAc,EAAd,CAAR,GAA4B,CAA5B,GAAgCH,OAAO,CAACG,KAAD,CAAP,CAAeE,WAAf,EAAhC,GAA+DL,OAAO,CAACG,KAAD,CAAQ,EAAnG;AACD;;AAED,SAAQ,KAAID,MAAO,EAAnB;AACD","sourcesContent":["// Copyright 2017-2021 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { keccakAsU8a } from \"../keccak/index.js\";\nimport { secp256k1Expand } from \"../secp256k1/index.js\";\n\nfunction getH160(u8a) {\n  if ([33, 65].includes(u8a.length)) {\n    u8a = keccakAsU8a(secp256k1Expand(u8a));\n  }\n\n  return u8a.slice(-20);\n}\n\nexport function ethereumEncode(addressOrPublic) {\n  if (!addressOrPublic) {\n    return '0x';\n  }\n\n  const u8aAddress = u8aToU8a(addressOrPublic);\n  assert([20, 32, 33, 65].includes(u8aAddress.length), 'Invalid address or publicKey passed');\n  const address = u8aToHex(getH160(u8aAddress), -1, false);\n  const hash = u8aToHex(keccakAsU8a(address), -1, false);\n  let result = '';\n\n  for (let index = 0; index < 40; index++) {\n    result = `${result}${parseInt(hash[index], 16) > 7 ? address[index].toUpperCase() : address[index]}`;\n  }\n\n  return `0x${result}`;\n}"]},"metadata":{},"sourceType":"module"}