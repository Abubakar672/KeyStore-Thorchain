{"ast":null,"code":"// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { bnToBn, isBigInt, isBn, isFunction, isNumber, stringify } from '@polkadot/util';\n/** @internal **/\n\nfunction isArrayLike(arg) {\n  return arg instanceof Uint8Array || Array.isArray(arg);\n}\n/** @internal **/\n\n\nfunction isCodec(arg) {\n  return isFunction(arg && arg.toU8a);\n}\n/** @internal **/\n\n\nfunction isEnum(arg) {\n  return isCodec(arg) && isNumber(arg.index) && isCodec(arg.value);\n}\n/** @internal */\n\n\nfunction isNumberLike(arg) {\n  return isNumber(arg) || isBn(arg) || isBigInt(arg);\n}\n/** @internal */\n\n\nfunction sortArray(a, b) {\n  // Vec, Tuple, Bytes etc.\n  let sortRes = 0;\n  const minLen = Math.min(a.length, b.length);\n\n  for (let i = 0; i < minLen; ++i) {\n    sortRes = sortAsc(a[i], b[i]);\n\n    if (sortRes !== 0) {\n      return sortRes;\n    }\n  }\n\n  return a.length - b.length;\n}\n/**\n* Sort keys/values of BTreeSet/BTreeMap in ascending order for encoding compatibility with Rust's BTreeSet/BTreeMap\n* (https://doc.rust-lang.org/stable/std/collections/struct.BTreeSet.html)\n* (https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html)\n*/\n\n\nexport function sortAsc(a, b) {\n  if (isNumberLike(a) && isNumberLike(b)) {\n    return bnToBn(a).cmp(bnToBn(b));\n  } else if (a instanceof Map && b instanceof Map) {\n    return sortAsc(Array.from(a.values()), Array.from(b.values()));\n  } else if (isEnum(a) && isEnum(b)) {\n    return sortAsc(a.index, b.index) || sortAsc(a.value, b.value);\n  } else if (isArrayLike(a) && isArrayLike(b)) {\n    return sortArray(a, b);\n  } else if (isCodec(a) && isCodec(b)) {\n    // Text, Bool etc.\n    return sortAsc(a.toU8a(true), b.toU8a(true));\n  }\n\n  throw new Error(`Attempting to sort unrecognized values: ${stringify(a)} (typeof ${typeof a}) <-> ${stringify(b)} (typeof ${typeof b})`);\n}\nexport function sortSet(set) {\n  return new Set(Array.from(set).sort(sortAsc));\n}\nexport function sortMap(map) {\n  return new Map(Array.from(map.entries()).sort(([keyA], [keyB]) => sortAsc(keyA, keyB)));\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/types/codec/utils/sortValues.js"],"names":["bnToBn","isBigInt","isBn","isFunction","isNumber","stringify","isArrayLike","arg","Uint8Array","Array","isArray","isCodec","toU8a","isEnum","index","value","isNumberLike","sortArray","a","b","sortRes","minLen","Math","min","length","i","sortAsc","cmp","Map","from","values","Error","sortSet","set","Set","sort","sortMap","map","entries","keyA","keyB"],"mappings":"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","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { bnToBn, isBigInt, isBn, isFunction, isNumber, stringify } from '@polkadot/util';\n\n/** @internal **/\nfunction isArrayLike(arg) {\n  return arg instanceof Uint8Array || Array.isArray(arg);\n}\n/** @internal **/\n\n\nfunction isCodec(arg) {\n  return isFunction(arg && arg.toU8a);\n}\n/** @internal **/\n\n\nfunction isEnum(arg) {\n  return isCodec(arg) && isNumber(arg.index) && isCodec(arg.value);\n}\n/** @internal */\n\n\nfunction isNumberLike(arg) {\n  return isNumber(arg) || isBn(arg) || isBigInt(arg);\n}\n/** @internal */\n\n\nfunction sortArray(a, b) {\n  // Vec, Tuple, Bytes etc.\n  let sortRes = 0;\n  const minLen = Math.min(a.length, b.length);\n\n  for (let i = 0; i < minLen; ++i) {\n    sortRes = sortAsc(a[i], b[i]);\n\n    if (sortRes !== 0) {\n      return sortRes;\n    }\n  }\n\n  return a.length - b.length;\n}\n/**\n* Sort keys/values of BTreeSet/BTreeMap in ascending order for encoding compatibility with Rust's BTreeSet/BTreeMap\n* (https://doc.rust-lang.org/stable/std/collections/struct.BTreeSet.html)\n* (https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html)\n*/\n\n\nexport function sortAsc(a, b) {\n  if (isNumberLike(a) && isNumberLike(b)) {\n    return bnToBn(a).cmp(bnToBn(b));\n  } else if (a instanceof Map && b instanceof Map) {\n    return sortAsc(Array.from(a.values()), Array.from(b.values()));\n  } else if (isEnum(a) && isEnum(b)) {\n    return sortAsc(a.index, b.index) || sortAsc(a.value, b.value);\n  } else if (isArrayLike(a) && isArrayLike(b)) {\n    return sortArray(a, b);\n  } else if (isCodec(a) && isCodec(b)) {\n    // Text, Bool etc.\n    return sortAsc(a.toU8a(true), b.toU8a(true));\n  }\n\n  throw new Error(`Attempting to sort unrecognized values: ${stringify(a)} (typeof ${typeof a}) <-> ${stringify(b)} (typeof ${typeof b})`);\n}\nexport function sortSet(set) {\n  return new Set(Array.from(set).sort(sortAsc));\n}\nexport function sortMap(map) {\n  return new Map(Array.from(map.entries()).sort(([keyA], [keyB]) => sortAsc(keyA, keyB)));\n}"]},"metadata":{},"sourceType":"module"}