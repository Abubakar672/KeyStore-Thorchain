{"ast":null,"code":"// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { flattenUniq } from \"./flattenUniq.js\";\nimport { validateTypes } from \"./validateTypes.js\";\n/** @internal */\n\nfunction extractTypes(lookup, types) {\n  return types.map(({\n    type\n  }) => lookup.getTypeDef(type).type);\n}\n/** @internal */\n\n\nfunction extractFieldTypes(lookup, type) {\n  return lookup.getSiType(type).def.asVariant.variants.map(({\n    fields\n  }) => extractTypes(lookup, fields));\n}\n/** @internal */\n\n\nfunction getPalletNames({\n  lookup,\n  pallets\n}) {\n  return pallets.reduce((all, {\n    calls,\n    constants,\n    events,\n    storage\n  }) => {\n    all.push([extractTypes(lookup, constants)]);\n\n    if (calls.isSome) {\n      all.push(extractFieldTypes(lookup, calls.unwrap().type));\n    }\n\n    if (events.isSome) {\n      all.push(extractFieldTypes(lookup, events.unwrap().type));\n    }\n\n    if (storage.isSome) {\n      all.push(storage.unwrap().items.map(({\n        type\n      }) => {\n        if (type.isPlain) {\n          return [lookup.getTypeDef(type.asPlain).type];\n        }\n\n        const {\n          hashers,\n          key,\n          value\n        } = type.asMap;\n        return hashers.length === 1 ? [lookup.getTypeDef(value).type, lookup.getTypeDef(key).type] : [lookup.getTypeDef(value).type, ...lookup.getSiType(key).def.asTuple.map(t => lookup.getTypeDef(t).type)];\n      }));\n    }\n\n    return all;\n  }, []);\n}\n/** @internal */\n\n\nexport function getUniqTypes(registry, meta, throwError) {\n  return validateTypes(registry, throwError, flattenUniq(getPalletNames(meta)));\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/types/metadata/util/getUniqTypes.js"],"names":["flattenUniq","validateTypes","extractTypes","lookup","types","map","type","getTypeDef","extractFieldTypes","getSiType","def","asVariant","variants","fields","getPalletNames","pallets","reduce","all","calls","constants","events","storage","push","isSome","unwrap","items","isPlain","asPlain","hashers","key","value","asMap","length","asTuple","t","getUniqTypes","registry","meta","throwError"],"mappings":"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","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { flattenUniq } from \"./flattenUniq.js\";\nimport { validateTypes } from \"./validateTypes.js\";\n/** @internal */\n\nfunction extractTypes(lookup, types) {\n  return types.map(({\n    type\n  }) => lookup.getTypeDef(type).type);\n}\n/** @internal */\n\n\nfunction extractFieldTypes(lookup, type) {\n  return lookup.getSiType(type).def.asVariant.variants.map(({\n    fields\n  }) => extractTypes(lookup, fields));\n}\n/** @internal */\n\n\nfunction getPalletNames({\n  lookup,\n  pallets\n}) {\n  return pallets.reduce((all, {\n    calls,\n    constants,\n    events,\n    storage\n  }) => {\n    all.push([extractTypes(lookup, constants)]);\n\n    if (calls.isSome) {\n      all.push(extractFieldTypes(lookup, calls.unwrap().type));\n    }\n\n    if (events.isSome) {\n      all.push(extractFieldTypes(lookup, events.unwrap().type));\n    }\n\n    if (storage.isSome) {\n      all.push(storage.unwrap().items.map(({\n        type\n      }) => {\n        if (type.isPlain) {\n          return [lookup.getTypeDef(type.asPlain).type];\n        }\n\n        const {\n          hashers,\n          key,\n          value\n        } = type.asMap;\n        return hashers.length === 1 ? [lookup.getTypeDef(value).type, lookup.getTypeDef(key).type] : [lookup.getTypeDef(value).type, ...lookup.getSiType(key).def.asTuple.map(t => lookup.getTypeDef(t).type)];\n      }));\n    }\n\n    return all;\n  }, []);\n}\n/** @internal */\n\n\nexport function getUniqTypes(registry, meta, throwError) {\n  return validateTypes(registry, throwError, flattenUniq(getPalletNames(meta)));\n}"]},"metadata":{},"sourceType":"module"}