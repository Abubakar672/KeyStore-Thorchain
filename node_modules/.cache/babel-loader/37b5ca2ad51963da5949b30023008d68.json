{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { catchError, combineLatest, map, of, switchMap } from 'rxjs';\nimport { isFunction, stringToHex } from '@polkadot/util';\nimport { memo } from \"../util/index.js\";\nconst DEMOCRACY_ID = stringToHex('democrac');\n\nfunction queryQueue(api) {\n  return api.query.democracy.dispatchQueue().pipe(switchMap(dispatches => combineLatest([of(dispatches), api.derive.democracy.preimages(dispatches.map(([, hash]) => hash))])), map(([dispatches, images]) => dispatches.map(([at, imageHash, index], dispatchIndex) => ({\n    at,\n    image: images[dispatchIndex],\n    imageHash,\n    index\n  }))));\n}\n\nfunction schedulerEntries(api) {\n  // We don't get entries, but rather we get the keys (triggered via finished referendums) and\n  // the subscribe to those keys - this means we pickup when the schedulers actually executes\n  // at a block, the entry for that block will become empty\n  return api.derive.democracy.referendumsFinished().pipe(switchMap(() => api.query.scheduler.agenda.keys()), switchMap(keys => {\n    const blockNumbers = keys.map(({\n      args: [blockNumber]\n    }) => blockNumber);\n    return blockNumbers.length ? combineLatest([of(blockNumbers), // this should simply be api.query.scheduler.agenda.multi<Vec<Option<Scheduled>>>,\n    // however we have had cases on Darwinia where the indices have moved around after an\n    // upgrade, which results in invalid on-chain data\n    combineLatest(blockNumbers.map(blockNumber => api.query.scheduler.agenda(blockNumber).pipe( // this does create an issue since it discards all at that block\n    catchError(() => of(null)))))]) : of([[], []]);\n  }));\n}\n\nfunction queryScheduler(api) {\n  return schedulerEntries(api).pipe(switchMap(([blockNumbers, agendas]) => {\n    const result = [];\n    blockNumbers.forEach((at, index) => {\n      (agendas[index] || []).filter(opt => opt.isSome).forEach(optScheduled => {\n        const scheduled = optScheduled.unwrap();\n\n        if (scheduled.maybeId.isSome) {\n          const id = scheduled.maybeId.unwrap().toHex();\n\n          if (id.startsWith(DEMOCRACY_ID)) {\n            const [, index] = api.registry.createType('(u64, ReferendumIndex)', id);\n            const imageHash = scheduled.call.args[0];\n            result.push({\n              at,\n              imageHash,\n              index\n            });\n          }\n        }\n      });\n    });\n    return result.length ? combineLatest([of(result), api.derive.democracy.preimages(result.map(({\n      imageHash\n    }) => imageHash))]) : of([[], []]);\n  }), map(([infos, images]) => infos.map((info, index) => _objectSpread(_objectSpread({}, info), {}, {\n    image: images[index]\n  }))));\n}\n\nexport function dispatchQueue(instanceId, api) {\n  return memo(instanceId, () => {\n    var _api$query$scheduler;\n\n    return isFunction((_api$query$scheduler = api.query.scheduler) === null || _api$query$scheduler === void 0 ? void 0 : _api$query$scheduler.agenda) ? queryScheduler(api) : api.query.democracy.dispatchQueue ? queryQueue(api) : of([]);\n  });\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/api-derive/democracy/dispatchQueue.js"],"names":["_defineProperty","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","catchError","combineLatest","map","of","switchMap","isFunction","stringToHex","memo","DEMOCRACY_ID","queryQueue","api","query","democracy","dispatchQueue","pipe","dispatches","derive","preimages","hash","images","at","imageHash","index","dispatchIndex","image","schedulerEntries","referendumsFinished","scheduler","agenda","blockNumbers","args","blockNumber","queryScheduler","agendas","result","opt","isSome","optScheduled","scheduled","unwrap","maybeId","id","toHex","startsWith","registry","createType","call","infos","info","instanceId","_api$query$scheduler"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { catchError, combineLatest, map, of, switchMap } from 'rxjs';\nimport { isFunction, stringToHex } from '@polkadot/util';\nimport { memo } from \"../util/index.js\";\nconst DEMOCRACY_ID = stringToHex('democrac');\n\nfunction queryQueue(api) {\n  return api.query.democracy.dispatchQueue().pipe(switchMap(dispatches => combineLatest([of(dispatches), api.derive.democracy.preimages(dispatches.map(([, hash]) => hash))])), map(([dispatches, images]) => dispatches.map(([at, imageHash, index], dispatchIndex) => ({\n    at,\n    image: images[dispatchIndex],\n    imageHash,\n    index\n  }))));\n}\n\nfunction schedulerEntries(api) {\n  // We don't get entries, but rather we get the keys (triggered via finished referendums) and\n  // the subscribe to those keys - this means we pickup when the schedulers actually executes\n  // at a block, the entry for that block will become empty\n  return api.derive.democracy.referendumsFinished().pipe(switchMap(() => api.query.scheduler.agenda.keys()), switchMap(keys => {\n    const blockNumbers = keys.map(({\n      args: [blockNumber]\n    }) => blockNumber);\n    return blockNumbers.length ? combineLatest([of(blockNumbers), // this should simply be api.query.scheduler.agenda.multi<Vec<Option<Scheduled>>>,\n    // however we have had cases on Darwinia where the indices have moved around after an\n    // upgrade, which results in invalid on-chain data\n    combineLatest(blockNumbers.map(blockNumber => api.query.scheduler.agenda(blockNumber).pipe( // this does create an issue since it discards all at that block\n    catchError(() => of(null)))))]) : of([[], []]);\n  }));\n}\n\nfunction queryScheduler(api) {\n  return schedulerEntries(api).pipe(switchMap(([blockNumbers, agendas]) => {\n    const result = [];\n    blockNumbers.forEach((at, index) => {\n      (agendas[index] || []).filter(opt => opt.isSome).forEach(optScheduled => {\n        const scheduled = optScheduled.unwrap();\n\n        if (scheduled.maybeId.isSome) {\n          const id = scheduled.maybeId.unwrap().toHex();\n\n          if (id.startsWith(DEMOCRACY_ID)) {\n            const [, index] = api.registry.createType('(u64, ReferendumIndex)', id);\n            const imageHash = scheduled.call.args[0];\n            result.push({\n              at,\n              imageHash,\n              index\n            });\n          }\n        }\n      });\n    });\n    return result.length ? combineLatest([of(result), api.derive.democracy.preimages(result.map(({\n      imageHash\n    }) => imageHash))]) : of([[], []]);\n  }), map(([infos, images]) => infos.map((info, index) => _objectSpread(_objectSpread({}, info), {}, {\n    image: images[index]\n  }))));\n}\n\nexport function dispatchQueue(instanceId, api) {\n  return memo(instanceId, () => {\n    var _api$query$scheduler;\n\n    return isFunction((_api$query$scheduler = api.query.scheduler) === null || _api$query$scheduler === void 0 ? void 0 : _api$query$scheduler.agenda) ? queryScheduler(api) : api.query.democracy.dispatchQueue ? queryQueue(api) : of([]);\n  });\n}"]},"metadata":{},"sourceType":"module"}