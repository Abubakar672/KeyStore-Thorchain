{"ast":null,"code":"// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, compactFromU8a, compactToU8a, isString, u8aConcat, u8aToU8a } from '@polkadot/util';\nimport { Raw } from \"../codec/Raw.js\";\n/** @internal */\n\nfunction decodeBitVecU8a(value) {\n  if (!value || !value.length) {\n    return [0, new Uint8Array()];\n  } // handle all other Uint8Array inputs, these do have a length prefix which is the number of bits encoded\n\n\n  const [offset, length] = compactFromU8a(value);\n  const total = offset + Math.ceil(length.toNumber() / 8);\n  assert(total <= value.length, () => `BitVec: required length less than remainder, expected at least ${total}, found ${value.length}`);\n  return [length.toNumber(), value.subarray(offset, total)];\n}\n/** @internal */\n\n\nfunction decodeBitVec(value) {\n  if (Array.isArray(value) || isString(value)) {\n    const u8a = u8aToU8a(value);\n    return [u8a.length / 8, u8a];\n  }\n\n  return decodeBitVecU8a(value);\n}\n/**\n * @name BitVec\n * @description\n * A BitVec that represents an array of bits. The bits are however stored encoded. The difference between this\n * and a normal Bytes would be that the length prefix indicates the number of bits encoded, not the bytes\n */\n\n\nexport class BitVec extends Raw {\n  constructor(registry, value) {\n    const [decodedLength, u8a] = decodeBitVec(value);\n    super(registry, u8a);\n    this._decodedLength = void 0;\n    this._decodedLength = decodedLength;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return this.length + compactToU8a(this._decodedLength).length;\n  }\n\n  toHuman() {\n    return `0b${[...this.toU8a(true)].map(d => `00000000${d.toString(2)}`.slice(-8)).join('_')}`;\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return 'BitVec';\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    const bitVec = super.toU8a();\n    return isBare ? bitVec : u8aConcat(compactToU8a(this._decodedLength), bitVec);\n  }\n\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/types/primitive/BitVec.js"],"names":["assert","compactFromU8a","compactToU8a","isString","u8aConcat","u8aToU8a","Raw","decodeBitVecU8a","value","length","Uint8Array","offset","total","Math","ceil","toNumber","subarray","decodeBitVec","Array","isArray","u8a","BitVec","constructor","registry","decodedLength","_decodedLength","encodedLength","toHuman","toU8a","map","d","toString","slice","join","toRawType","isBare","bitVec"],"mappings":"AAAA;AACA;AACA,SAASA,MAAT,EAAiBC,cAAjB,EAAiCC,YAAjC,EAA+CC,QAA/C,EAAyDC,SAAzD,EAAoEC,QAApE,QAAoF,gBAApF;AACA,SAASC,GAAT,QAAoB,iBAApB;AACA;;AAEA,SAASC,eAAT,CAAyBC,KAAzB,EAAgC;AAC9B,MAAI,CAACA,KAAD,IAAU,CAACA,KAAK,CAACC,MAArB,EAA6B;AAC3B,WAAO,CAAC,CAAD,EAAI,IAAIC,UAAJ,EAAJ,CAAP;AACD,GAH6B,CAG5B;;;AAGF,QAAM,CAACC,MAAD,EAASF,MAAT,IAAmBR,cAAc,CAACO,KAAD,CAAvC;AACA,QAAMI,KAAK,GAAGD,MAAM,GAAGE,IAAI,CAACC,IAAL,CAAUL,MAAM,CAACM,QAAP,KAAoB,CAA9B,CAAvB;AACAf,EAAAA,MAAM,CAACY,KAAK,IAAIJ,KAAK,CAACC,MAAhB,EAAwB,MAAO,kEAAiEG,KAAM,WAAUJ,KAAK,CAACC,MAAO,EAA7H,CAAN;AACA,SAAO,CAACA,MAAM,CAACM,QAAP,EAAD,EAAoBP,KAAK,CAACQ,QAAN,CAAeL,MAAf,EAAuBC,KAAvB,CAApB,CAAP;AACD;AACD;;;AAGA,SAASK,YAAT,CAAsBT,KAAtB,EAA6B;AAC3B,MAAIU,KAAK,CAACC,OAAN,CAAcX,KAAd,KAAwBL,QAAQ,CAACK,KAAD,CAApC,EAA6C;AAC3C,UAAMY,GAAG,GAAGf,QAAQ,CAACG,KAAD,CAApB;AACA,WAAO,CAACY,GAAG,CAACX,MAAJ,GAAa,CAAd,EAAiBW,GAAjB,CAAP;AACD;;AAED,SAAOb,eAAe,CAACC,KAAD,CAAtB;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;;AAGA,OAAO,MAAMa,MAAN,SAAqBf,GAArB,CAAyB;AAC9BgB,EAAAA,WAAW,CAACC,QAAD,EAAWf,KAAX,EAAkB;AAC3B,UAAM,CAACgB,aAAD,EAAgBJ,GAAhB,IAAuBH,YAAY,CAACT,KAAD,CAAzC;AACA,UAAMe,QAAN,EAAgBH,GAAhB;AACA,SAAKK,cAAL,GAAsB,KAAK,CAA3B;AACA,SAAKA,cAAL,GAAsBD,aAAtB;AACD;AACD;AACF;AACA;;;AAGmB,MAAbE,aAAa,GAAG;AAClB,WAAO,KAAKjB,MAAL,GAAcP,YAAY,CAAC,KAAKuB,cAAN,CAAZ,CAAkChB,MAAvD;AACD;;AAEDkB,EAAAA,OAAO,GAAG;AACR,WAAQ,KAAI,CAAC,GAAG,KAAKC,KAAL,CAAW,IAAX,CAAJ,EAAsBC,GAAtB,CAA0BC,CAAC,IAAK,WAAUA,CAAC,CAACC,QAAF,CAAW,CAAX,CAAc,EAAzB,CAA2BC,KAA3B,CAAiC,CAAC,CAAlC,CAA/B,EAAqEC,IAArE,CAA0E,GAA1E,CAA+E,EAA3F;AACD;AACD;AACF;AACA;;;AAGEC,EAAAA,SAAS,GAAG;AACV,WAAO,QAAP;AACD;AACD;AACF;AACA;AACA;;;AAGEN,EAAAA,KAAK,CAACO,MAAD,EAAS;AACZ,UAAMC,MAAM,GAAG,MAAMR,KAAN,EAAf;AACA,WAAOO,MAAM,GAAGC,MAAH,GAAYhC,SAAS,CAACF,YAAY,CAAC,KAAKuB,cAAN,CAAb,EAAoCW,MAApC,CAAlC;AACD;;AApC6B","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, compactFromU8a, compactToU8a, isString, u8aConcat, u8aToU8a } from '@polkadot/util';\nimport { Raw } from \"../codec/Raw.js\";\n/** @internal */\n\nfunction decodeBitVecU8a(value) {\n  if (!value || !value.length) {\n    return [0, new Uint8Array()];\n  } // handle all other Uint8Array inputs, these do have a length prefix which is the number of bits encoded\n\n\n  const [offset, length] = compactFromU8a(value);\n  const total = offset + Math.ceil(length.toNumber() / 8);\n  assert(total <= value.length, () => `BitVec: required length less than remainder, expected at least ${total}, found ${value.length}`);\n  return [length.toNumber(), value.subarray(offset, total)];\n}\n/** @internal */\n\n\nfunction decodeBitVec(value) {\n  if (Array.isArray(value) || isString(value)) {\n    const u8a = u8aToU8a(value);\n    return [u8a.length / 8, u8a];\n  }\n\n  return decodeBitVecU8a(value);\n}\n/**\n * @name BitVec\n * @description\n * A BitVec that represents an array of bits. The bits are however stored encoded. The difference between this\n * and a normal Bytes would be that the length prefix indicates the number of bits encoded, not the bytes\n */\n\n\nexport class BitVec extends Raw {\n  constructor(registry, value) {\n    const [decodedLength, u8a] = decodeBitVec(value);\n    super(registry, u8a);\n    this._decodedLength = void 0;\n    this._decodedLength = decodedLength;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return this.length + compactToU8a(this._decodedLength).length;\n  }\n\n  toHuman() {\n    return `0b${[...this.toU8a(true)].map(d => `00000000${d.toString(2)}`.slice(-8)).join('_')}`;\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return 'BitVec';\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    const bitVec = super.toU8a();\n    return isBare ? bitVec : u8aConcat(compactToU8a(this._decodedLength), bitVec);\n  }\n\n}"]},"metadata":{},"sourceType":"module"}