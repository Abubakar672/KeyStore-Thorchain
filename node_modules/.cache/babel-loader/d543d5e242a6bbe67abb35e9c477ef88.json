{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { assert, isNumber, isString, stringCamelCase, stringify, stringUpperFirst } from '@polkadot/util';\nimport { Struct } from \"../codec/Struct.js\";\nimport { withTypeString } from \"../create/encodeTypes.js\";\nimport { getTypeDef } from \"../create/getTypeDef.js\";\nimport { TypeDefInfo } from \"../types/index.js\"; // Just a placeholder for a type.unrwapOr()\n\nconst TYPE_UNWRAP = {\n  toNumber: () => -1\n}; // Alias the primitive enum with out known values\n\nconst PRIMITIVE_ALIAS = {\n  Char: 'u32',\n  // Rust char is 4-bytes\n  Str: 'Text'\n}; // These are types where we have a specific decoding/encoding override + helpers\n\nconst PRIMITIVE_PATHS = [// match {node, polkadot, ...}_runtime\n'*_runtime::Call', '*_runtime::Event', // these have a specific encoding or logic (for pallets)\n'pallet_democracy::vote::Vote', 'pallet_identity::types::Data', // these are well-known types with additional encoding\n'sp_core::crypto::AccountId32', 'sp_runtime::generic::era::Era', 'sp_runtime::multiaddress::MultiAddress', // shorten some well-known types\n'primitive_types::*', 'sp_arithmetic::per_things::*', // ink!\n'ink_env::types::*'].map(p => p.split('::')); // Mappings for types that should be converted to set via BitVec\n\nconst SETS = ['pallet_identity::types::BitFlags'].map(p => p.split('::')); // These we never use these as top-level names, they are wrappers\n\nconst WRAPPERS = ['BoundedBTreeMap', 'BoundedVec', 'Box', 'BTreeMap', 'Cow', 'Result', 'Option', 'WeakBoundedVec']; // These are reserved and/or conflicts with built-in Codec definitions\n\nconst RESERVED = ['call', 'entries', 'hash', 'keys', 'new', 'size'];\n\nfunction matchParts(first, second) {\n  return first.length === second.length && first.every((a, index) => {\n    const b = second[index].toString();\n    return a === '*' || a === b || a.includes('*') && a.includes('_') && b.includes('_') && matchParts(a.split('_'), b.split('_'));\n  });\n} // check if the path matches the PRIMITIVE_SP (with wildcards)\n\n\nfunction getPrimitivePath(path) {\n  // TODO We need to handle ink! Balance in some way\n  return path.length && PRIMITIVE_PATHS.some(p => matchParts(p, path)) ? path[path.length - 1].toString() : null;\n}\n\nfunction removeDuplicateNames(lookup, names) {\n  const rewrite = {};\n  return names.map(([lookupIndex, name, params]) => {\n    if (!name) {\n      return [lookupIndex, null];\n    } // those where the name is matching\n\n\n    const allSame = names.filter(([, oName]) => name === oName); // are there among matching names\n\n    const anyDiff = allSame.some(([oIndex,, oParams]) => lookupIndex !== oIndex && (params.length !== oParams.length || params.some((p, index) => !p.name.eq(oParams[index].name) || p.type.unwrapOr(TYPE_UNWRAP).toNumber() !== oParams[index].type.unwrapOr(TYPE_UNWRAP).toNumber()))); // everything matches, we can combine these\n\n    if (!anyDiff || !allSame[0][2].length) {\n      return [lookupIndex, name];\n    } // find the first parameter that yields differences\n\n\n    const paramIdx = allSame[0][2].findIndex(({\n      type\n    }, index) => allSame.every(([,, params]) => params[index].type.isSome) && allSame.every(([,, params], aIndex) => aIndex === 0 || !params[index].type.eq(type))); // No param found that is different\n\n    if (paramIdx === -1) {\n      return [lookupIndex, name];\n    } // see if using the param type helps\n\n\n    const adjusted = allSame.map(([oIndex, oName, oParams]) => {\n      const {\n        def,\n        path\n      } = lookup.getSiType(oParams[paramIdx].type.unwrap());\n\n      if (!def.isPrimitive && !path.length) {\n        return [oIndex, null];\n      }\n\n      return [oIndex, def.isPrimitive ? `${oName}${def.asPrimitive.toString()}` : `${oName}${path[path.length - 1].toString()}`];\n    }); // any dupes remaining?\n\n    const noDupes = adjusted.every(([i, n]) => !!n && !adjusted.some(([ai, an]) => i !== ai && n === an));\n\n    if (noDupes) {\n      // we filtered above for null names\n      adjusted.forEach(([index, name]) => {\n        rewrite[index] = name;\n      });\n    }\n\n    return noDupes ? [lookupIndex, name] : [lookupIndex, null];\n  }).filter(n => !!n[1]).map(([lookupIndex, name]) => [lookupIndex, rewrite[lookupIndex] || name]);\n}\n\nfunction extractName(types, {\n  id,\n  type: {\n    params,\n    path\n  }\n}) {\n  const lookupIndex = id.toNumber();\n\n  if (!path.length || WRAPPERS.includes(path[path.length - 1].toString())) {\n    return [lookupIndex, null, []];\n  }\n\n  const parts = path.map(p => stringUpperFirst(stringCamelCase(p))).filter((p, index) => ( // Remove ::{pallet, traits, types}::\n  index !== 1 || !['Pallet', 'Traits', 'Types'].includes(p.toString())) && ( // sp_runtime::generic::digest::Digest -> sp_runtime::generic::Digest\n  // sp_runtime::multiaddress::MultiAddress -> sp_runtime::MultiAddress\n  index === path.length - 1 || p.toLowerCase() !== path[index + 1].toLowerCase()));\n  let typeName = parts.join('');\n\n  if (parts.length === 2 && parts[parts.length - 1] === 'RawOrigin' && params.length === 2 && params[1].type.isSome) {\n    // Do magic for RawOrigin lookup\n    const instanceType = types[params[1].type.unwrap().toNumber()];\n\n    if (instanceType.type.path.length === 2) {\n      typeName = `${typeName}${instanceType.type.path[1].toString()}`;\n    }\n  }\n\n  return [lookupIndex, typeName, params];\n}\n\nfunction extractNames(lookup, types) {\n  const dedup = removeDuplicateNames(lookup, types.map(t => extractName(types, t)));\n  const [names, typesNew] = dedup.reduce(([names, types], [lookupIndex, name]) => {\n    // We set the name for this specific type\n    names[lookupIndex] = name; // we map to the actual lookupIndex\n\n    types[name] = lookup.registry.createLookupType(lookupIndex);\n    return [names, types];\n  }, [{}, {}]);\n  lookup.registry.register(typesNew);\n  return names;\n}\n\nvar _names = /*#__PURE__*/_classPrivateFieldLooseKey(\"names\");\n\nvar _typeDefs = /*#__PURE__*/_classPrivateFieldLooseKey(\"typeDefs\");\n\nvar _createSiDef = /*#__PURE__*/_classPrivateFieldLooseKey(\"createSiDef\");\n\nvar _getLookupId = /*#__PURE__*/_classPrivateFieldLooseKey(\"getLookupId\");\n\nvar _extract = /*#__PURE__*/_classPrivateFieldLooseKey(\"extract\");\n\nvar _extractArray = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractArray\");\n\nvar _extractBitSequence = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractBitSequence\");\n\nvar _extractCompact = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractCompact\");\n\nvar _extractComposite = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractComposite\");\n\nvar _extractCompositeSet = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractCompositeSet\");\n\nvar _extractFields = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractFields\");\n\nvar _extractFieldsAlias = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractFieldsAlias\");\n\nvar _extractHistoric = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractHistoric\");\n\nvar _extractPrimitive = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractPrimitive\");\n\nvar _extractPrimitivePath = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractPrimitivePath\");\n\nvar _extractSequence = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractSequence\");\n\nvar _extractTuple = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractTuple\");\n\nvar _extractVariant = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractVariant\");\n\nvar _extractVariantEnum = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractVariantEnum\");\n\nexport class GenericPortableRegistry extends Struct {\n  constructor(registry, value) {\n    super(registry, {\n      types: 'Vec<PortableType>'\n    }, value);\n    Object.defineProperty(this, _extractVariantEnum, {\n      value: _extractVariantEnum2\n    });\n    Object.defineProperty(this, _extractVariant, {\n      value: _extractVariant2\n    });\n    Object.defineProperty(this, _extractTuple, {\n      value: _extractTuple2\n    });\n    Object.defineProperty(this, _extractSequence, {\n      value: _extractSequence2\n    });\n    Object.defineProperty(this, _extractPrimitivePath, {\n      value: _extractPrimitivePath2\n    });\n    Object.defineProperty(this, _extractPrimitive, {\n      value: _extractPrimitive2\n    });\n    Object.defineProperty(this, _extractHistoric, {\n      value: _extractHistoric2\n    });\n    Object.defineProperty(this, _extractFieldsAlias, {\n      value: _extractFieldsAlias2\n    });\n    Object.defineProperty(this, _extractFields, {\n      value: _extractFields2\n    });\n    Object.defineProperty(this, _extractCompositeSet, {\n      value: _extractCompositeSet2\n    });\n    Object.defineProperty(this, _extractComposite, {\n      value: _extractComposite2\n    });\n    Object.defineProperty(this, _extractCompact, {\n      value: _extractCompact2\n    });\n    Object.defineProperty(this, _extractBitSequence, {\n      value: _extractBitSequence2\n    });\n    Object.defineProperty(this, _extractArray, {\n      value: _extractArray2\n    });\n    Object.defineProperty(this, _extract, {\n      value: _extract2\n    });\n    Object.defineProperty(this, _getLookupId, {\n      value: _getLookupId2\n    });\n    Object.defineProperty(this, _createSiDef, {\n      value: _createSiDef2\n    });\n    Object.defineProperty(this, _names, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _typeDefs, {\n      writable: true,\n      value: {}\n    });\n    _classPrivateFieldLooseBase(this, _names)[_names] = extractNames(this, this.types);\n  }\n  /**\n   * @description The types of the registry\n   */\n\n\n  get types() {\n    return this.get('types');\n  }\n  /**\n   * @description Returns the name for a specific lookup\n   */\n\n\n  getName(lookupId) {\n    return _classPrivateFieldLooseBase(this, _names)[_names][_classPrivateFieldLooseBase(this, _getLookupId)[_getLookupId](lookupId)];\n  }\n  /**\n   * @description Finds a specific type in the registry\n   */\n\n\n  getSiType(lookupId) {\n    const found = this.types[_classPrivateFieldLooseBase(this, _getLookupId)[_getLookupId](lookupId)];\n\n    assert(found, () => `PortableRegistry: Unable to find type with lookupId ${lookupId.toString()}`);\n    return found.type;\n  }\n  /**\n   * @description Lookup the type definition for the index\n   */\n\n\n  getTypeDef(lookupId) {\n    const lookupIndex = _classPrivateFieldLooseBase(this, _getLookupId)[_getLookupId](lookupId);\n\n    if (!_classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex]) {\n      const lookupName = _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex];\n\n      const empty = {\n        info: TypeDefInfo.DoNotConstruct,\n        lookupIndex,\n        lookupName,\n        type: this.registry.createLookupType(lookupIndex)\n      }; // Set named items since we will get into circular lookups along the way\n\n      if (lookupName) {\n        _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex] = empty;\n      }\n\n      const extracted = _classPrivateFieldLooseBase(this, _extract)[_extract](this.getSiType(lookupId), lookupIndex); // For non-named items, we only set this right at the end\n\n\n      if (!lookupName) {\n        _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex] = empty;\n      }\n\n      Object.keys(extracted).forEach(k => {\n        if (k !== 'lookupName' || extracted[k]) {\n          // these are safe since we are looking through the keys as set\n          _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex][k] = extracted[k];\n        }\n      }); // don't set lookupName on lower-level, we want to always direct to the type\n\n      if (extracted.info === TypeDefInfo.Plain) {\n        _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex].lookupNameRoot = _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex].lookupName;\n        delete _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex].lookupName;\n      }\n    }\n\n    return _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex];\n  }\n\n}\n\nfunction _createSiDef2(lookupId) {\n  const typeDef = this.getTypeDef(lookupId);\n  const lookupIndex = lookupId.toNumber(); // Setup for a lookup on complex types\n\n  return [TypeDefInfo.Enum, TypeDefInfo.Struct].includes(typeDef.info) && typeDef.lookupName ? {\n    docs: typeDef.docs,\n    info: TypeDefInfo.Si,\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n    type: this.registry.createLookupType(lookupId)\n  } : typeDef;\n}\n\nfunction _getLookupId2(lookupId) {\n  if (isString(lookupId)) {\n    assert(this.registry.isLookupType(lookupId), () => `PortableRegistry: Expected a lookup string type, found ${lookupId}`);\n    return parseInt(lookupId.replace('Lookup', ''), 10);\n  } else if (isNumber(lookupId)) {\n    return lookupId;\n  }\n\n  return lookupId.toNumber();\n}\n\nfunction _extract2(type, lookupIndex) {\n  const namespace = [...type.path].join('::');\n  let typeDef;\n  const primType = getPrimitivePath(type.path);\n\n  try {\n    if (primType) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractPrimitivePath)[_extractPrimitivePath](lookupIndex, primType);\n    } else if (type.def.isArray) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractArray)[_extractArray](lookupIndex, type.def.asArray);\n    } else if (type.def.isBitSequence) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractBitSequence)[_extractBitSequence](lookupIndex, type.def.asBitSequence);\n    } else if (type.def.isCompact) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractCompact)[_extractCompact](lookupIndex, type.def.asCompact);\n    } else if (type.def.isComposite) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractComposite)[_extractComposite](lookupIndex, type, type.def.asComposite);\n    } else if (type.def.isHistoricMetaCompat) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractHistoric)[_extractHistoric](lookupIndex, type.def.asHistoricMetaCompat);\n    } else if (type.def.isPrimitive) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractPrimitive)[_extractPrimitive](lookupIndex, type);\n    } else if (type.def.isSequence) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractSequence)[_extractSequence](lookupIndex, type.def.asSequence);\n    } else if (type.def.isTuple) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractTuple)[_extractTuple](lookupIndex, type.def.asTuple);\n    } else if (type.def.isVariant) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractVariant)[_extractVariant](lookupIndex, type, type.def.asVariant);\n    } else {\n      throw new Error(`No SiTypeDef handler for ${type.def.toString()}`);\n    }\n  } catch (error) {\n    throw new Error(`PortableRegistry: ${lookupIndex}${namespace ? ` (${namespace})` : ''}: Error extracting ${stringify(type)}: ${error.message}`);\n  }\n\n  return _objectSpread({\n    docs: type.docs.map(d => d.toString()),\n    namespace\n  }, typeDef);\n}\n\nfunction _extractArray2(_, {\n  len: length,\n  type\n}) {\n  assert(!length || length.toNumber() <= 256, 'Only support for [Type; <length>], where length <= 256');\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.VecFixed,\n    length: length.toNumber(),\n    sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type)\n  });\n}\n\nfunction _extractBitSequence2(_, {\n  bitOrderType,\n  bitStoreType\n}) {\n  const bitOrder = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](bitOrderType);\n\n  const bitStore = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](bitStoreType); // NOTE: Currently the BitVec type is one-way only, i.e. we only use it to decode, not\n  // re-encode stuff. As such we ignore the msb/lsb identifier given by bitOrderType, or rather\n  // we don't pass it though at all\n\n\n  assert(['bitvec::order::Lsb0', 'bitvec::order::Msb0'].includes(bitOrder.namespace || ''), () => `Unexpected bitOrder found as ${bitOrder.namespace || '<unknown>'}`);\n  assert(bitStore.info === TypeDefInfo.Plain && bitStore.type === 'u8', () => `Only u8 bitStore is currently supported, found ${bitStore.type}`);\n  return {\n    info: TypeDefInfo.Plain,\n    type: 'BitVec'\n  };\n}\n\nfunction _extractCompact2(_, {\n  type\n}) {\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Compact,\n    sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type)\n  });\n}\n\nfunction _extractComposite2(lookupIndex, {\n  params,\n  path\n}, {\n  fields\n}) {\n  const specialVariant = path[0].toString();\n\n  if (path.length === 1 && specialVariant === 'BTreeMap') {\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.BTreeMap,\n      sub: params.map(({\n        type\n      }) => _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type.unwrap()))\n    });\n  } else if (['Range', 'RangeInclusive'].includes(specialVariant)) {\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Range,\n      sub: fields.map(({\n        name,\n        type\n      }, index) => _objectSpread({\n        name: name.isSome ? name.unwrap().toString() : ['start', 'end'][index]\n      }, _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type)))\n    });\n  }\n\n  return SETS.some(p => matchParts(p, path)) ? _classPrivateFieldLooseBase(this, _extractCompositeSet)[_extractCompositeSet](lookupIndex, params, fields) : _classPrivateFieldLooseBase(this, _extractFields)[_extractFields](lookupIndex, fields);\n}\n\nfunction _extractCompositeSet2(_, params, fields) {\n  assert(params.length === 1 && fields.length === 1, 'Set handling expects param/field as single entries');\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Set,\n    length: this.registry.createType(this.registry.createLookupType(fields[0].type)).bitLength(),\n    sub: this.getSiType(params[0].type.unwrap()).def.asVariant.variants.map(({\n      index,\n      name\n    }) => ({\n      // This will be an issue > 2^53 - 1 ... don't have those (yet)\n      index: index.toNumber(),\n      info: TypeDefInfo.Plain,\n      name: name.toString(),\n      type: 'Null'\n    }))\n  });\n}\n\nfunction _extractFields2(lookupIndex, fields) {\n  const [isStruct, isTuple] = fields.reduce(([isAllNamed, isAllUnnamed], {\n    name\n  }) => [isAllNamed && name.isSome, isAllUnnamed && name.isNone], [true, true]);\n  assert(isTuple || isStruct, 'Invalid fields type detected, expected either Tuple (all unnamed) or Struct (all named)');\n\n  if (fields.length === 0) {\n    return {\n      info: TypeDefInfo.Null,\n      type: 'Null'\n    };\n  } else if (isTuple && fields.length === 1) {\n    const typeDef = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](fields[0].type);\n\n    return _objectSpread(_objectSpread({}, typeDef), lookupIndex === -1 ? {} : {\n      lookupIndex,\n      lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n      lookupNameRoot: typeDef.lookupName\n    });\n  }\n\n  const [sub, alias] = _classPrivateFieldLooseBase(this, _extractFieldsAlias)[_extractFieldsAlias](fields);\n\n  return withTypeString(this.registry, _objectSpread(_objectSpread(_objectSpread({\n    info: isTuple // Tuple check first\n    ? TypeDefInfo.Tuple : TypeDefInfo.Struct\n  }, alias.size ? {\n    alias\n  } : {}), lookupIndex === -1 ? {} : {\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex]\n  }), {}, {\n    sub\n  }));\n}\n\nfunction _extractFieldsAlias2(fields) {\n  const alias = new Map();\n  const sub = fields.map(({\n    docs,\n    name,\n    type\n  }) => {\n    const typeDef = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type);\n\n    if (name.isNone) {\n      return typeDef;\n    }\n\n    let nameField = stringCamelCase(name.unwrap());\n    let nameOrig = null;\n\n    if (nameField.includes('#')) {\n      nameOrig = nameField;\n      nameField = nameOrig.replace(/#/g, '_');\n    } else if (RESERVED.includes(nameField)) {\n      nameOrig = nameField;\n      nameField = `${nameField}_`;\n    }\n\n    if (nameOrig) {\n      alias.set(nameField, nameOrig);\n    }\n\n    return _objectSpread(_objectSpread({}, typeDef), {}, {\n      docs: docs.map(d => d.toString()),\n      name: nameField\n    });\n  });\n  return [sub, alias];\n}\n\nfunction _extractHistoric2(_, type) {\n  return _objectSpread(_objectSpread({}, getTypeDef(type)), {}, {\n    displayName: type.toString(),\n    isFromSi: true\n  });\n}\n\nfunction _extractPrimitive2(_, type) {\n  const typeStr = type.def.asPrimitive.type.toString();\n  return {\n    info: TypeDefInfo.Plain,\n    type: PRIMITIVE_ALIAS[typeStr] || typeStr.toLowerCase()\n  };\n}\n\nfunction _extractPrimitivePath2(_, type) {\n  return {\n    info: TypeDefInfo.Plain,\n    type\n  };\n}\n\nfunction _extractSequence2(lookupIndex, {\n  type\n}) {\n  const sub = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type);\n\n  if (sub.type === 'u8') {\n    return {\n      info: TypeDefInfo.Plain,\n      type: 'Bytes'\n    };\n  }\n\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Vec,\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n    sub\n  });\n}\n\nfunction _extractTuple2(lookupIndex, ids) {\n  if (ids.length === 0) {\n    return {\n      info: TypeDefInfo.Null,\n      type: 'Null'\n    };\n  } else if (ids.length === 1) {\n    return this.getTypeDef(ids[0]);\n  }\n\n  const sub = ids.map(type => _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type));\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Tuple,\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n    sub\n  });\n}\n\nfunction _extractVariant2(lookupIndex, {\n  params,\n  path\n}, {\n  variants\n}) {\n  const specialVariant = path[0].toString();\n\n  if (specialVariant === 'Option') {\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Option,\n      sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](params[0].type.unwrap())\n    });\n  } else if (specialVariant === 'Result') {\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Result,\n      sub: params.map(({\n        type\n      }, index) => _objectSpread({\n        name: ['Ok', 'Error'][index]\n      }, _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type.unwrap())))\n    });\n  } else if (variants.length === 0) {\n    return {\n      info: TypeDefInfo.Null,\n      type: 'Null'\n    };\n  }\n\n  return _classPrivateFieldLooseBase(this, _extractVariantEnum)[_extractVariantEnum](lookupIndex, variants);\n}\n\nfunction _extractVariantEnum2(lookupIndex, variants) {\n  const sub = []; // we may get entries out of order, arrange them first before creating with gaps filled\n  // NOTE: Since we mutate, use a copy of the array as an input\n\n  [...variants].sort((a, b) => a.index.cmp(b.index)).forEach(({\n    fields,\n    index,\n    name\n  }) => {\n    const desired = index.toNumber();\n\n    while (sub.length !== desired) {\n      sub.push({\n        index: sub.length,\n        info: TypeDefInfo.Null,\n        name: `Unused${sub.length}`,\n        type: 'Null'\n      });\n    }\n\n    sub.push(_objectSpread(_objectSpread({}, _classPrivateFieldLooseBase(this, _extractFields)[_extractFields](-1, fields)), {}, {\n      index: index.toNumber(),\n      name: name.toString()\n    }));\n  });\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Enum,\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n    sub\n  });\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/types/generic/PortableRegistry.js"],"names":["_defineProperty","_classPrivateFieldLooseBase","_classPrivateFieldLooseKey","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","assert","isNumber","isString","stringCamelCase","stringify","stringUpperFirst","Struct","withTypeString","getTypeDef","TypeDefInfo","TYPE_UNWRAP","toNumber","PRIMITIVE_ALIAS","Char","Str","PRIMITIVE_PATHS","map","p","split","SETS","WRAPPERS","RESERVED","matchParts","first","second","every","a","index","b","toString","includes","getPrimitivePath","path","some","removeDuplicateNames","lookup","names","rewrite","lookupIndex","name","params","allSame","oName","anyDiff","oIndex","oParams","eq","type","unwrapOr","paramIdx","findIndex","isSome","aIndex","adjusted","def","getSiType","unwrap","isPrimitive","asPrimitive","noDupes","n","ai","an","extractName","types","id","parts","toLowerCase","typeName","join","instanceType","extractNames","dedup","t","typesNew","reduce","registry","createLookupType","register","_names","_typeDefs","_createSiDef","_getLookupId","_extract","_extractArray","_extractBitSequence","_extractCompact","_extractComposite","_extractCompositeSet","_extractFields","_extractFieldsAlias","_extractHistoric","_extractPrimitive","_extractPrimitivePath","_extractSequence","_extractTuple","_extractVariant","_extractVariantEnum","GenericPortableRegistry","constructor","value","_extractVariantEnum2","_extractVariant2","_extractTuple2","_extractSequence2","_extractPrimitivePath2","_extractPrimitive2","_extractHistoric2","_extractFieldsAlias2","_extractFields2","_extractCompositeSet2","_extractComposite2","_extractCompact2","_extractBitSequence2","_extractArray2","_extract2","_getLookupId2","_createSiDef2","writable","get","getName","lookupId","found","lookupName","empty","info","DoNotConstruct","extracted","k","Plain","lookupNameRoot","typeDef","Enum","docs","Si","isLookupType","parseInt","replace","namespace","primType","isArray","asArray","isBitSequence","asBitSequence","isCompact","asCompact","isComposite","asComposite","isHistoricMetaCompat","asHistoricMetaCompat","isSequence","asSequence","isTuple","asTuple","isVariant","asVariant","Error","error","message","d","_","len","VecFixed","sub","bitOrderType","bitStoreType","bitOrder","bitStore","Compact","fields","specialVariant","BTreeMap","Range","Set","createType","bitLength","variants","isStruct","isAllNamed","isAllUnnamed","isNone","Null","alias","Tuple","size","Map","nameField","nameOrig","set","displayName","isFromSi","typeStr","Vec","ids","Option","Result","sort","cmp","desired"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isNumber, isString, stringCamelCase, stringify, stringUpperFirst } from '@polkadot/util';\nimport { Struct } from \"../codec/Struct.js\";\nimport { withTypeString } from \"../create/encodeTypes.js\";\nimport { getTypeDef } from \"../create/getTypeDef.js\";\nimport { TypeDefInfo } from \"../types/index.js\"; // Just a placeholder for a type.unrwapOr()\n\nconst TYPE_UNWRAP = {\n  toNumber: () => -1\n}; // Alias the primitive enum with out known values\n\nconst PRIMITIVE_ALIAS = {\n  Char: 'u32',\n  // Rust char is 4-bytes\n  Str: 'Text'\n}; // These are types where we have a specific decoding/encoding override + helpers\n\nconst PRIMITIVE_PATHS = [// match {node, polkadot, ...}_runtime\n'*_runtime::Call', '*_runtime::Event', // these have a specific encoding or logic (for pallets)\n'pallet_democracy::vote::Vote', 'pallet_identity::types::Data', // these are well-known types with additional encoding\n'sp_core::crypto::AccountId32', 'sp_runtime::generic::era::Era', 'sp_runtime::multiaddress::MultiAddress', // shorten some well-known types\n'primitive_types::*', 'sp_arithmetic::per_things::*', // ink!\n'ink_env::types::*'].map(p => p.split('::')); // Mappings for types that should be converted to set via BitVec\n\nconst SETS = ['pallet_identity::types::BitFlags'].map(p => p.split('::')); // These we never use these as top-level names, they are wrappers\n\nconst WRAPPERS = ['BoundedBTreeMap', 'BoundedVec', 'Box', 'BTreeMap', 'Cow', 'Result', 'Option', 'WeakBoundedVec']; // These are reserved and/or conflicts with built-in Codec definitions\n\nconst RESERVED = ['call', 'entries', 'hash', 'keys', 'new', 'size'];\n\nfunction matchParts(first, second) {\n  return first.length === second.length && first.every((a, index) => {\n    const b = second[index].toString();\n    return a === '*' || a === b || a.includes('*') && a.includes('_') && b.includes('_') && matchParts(a.split('_'), b.split('_'));\n  });\n} // check if the path matches the PRIMITIVE_SP (with wildcards)\n\n\nfunction getPrimitivePath(path) {\n  // TODO We need to handle ink! Balance in some way\n  return path.length && PRIMITIVE_PATHS.some(p => matchParts(p, path)) ? path[path.length - 1].toString() : null;\n}\n\nfunction removeDuplicateNames(lookup, names) {\n  const rewrite = {};\n  return names.map(([lookupIndex, name, params]) => {\n    if (!name) {\n      return [lookupIndex, null];\n    } // those where the name is matching\n\n\n    const allSame = names.filter(([, oName]) => name === oName); // are there among matching names\n\n    const anyDiff = allSame.some(([oIndex,, oParams]) => lookupIndex !== oIndex && (params.length !== oParams.length || params.some((p, index) => !p.name.eq(oParams[index].name) || p.type.unwrapOr(TYPE_UNWRAP).toNumber() !== oParams[index].type.unwrapOr(TYPE_UNWRAP).toNumber()))); // everything matches, we can combine these\n\n    if (!anyDiff || !allSame[0][2].length) {\n      return [lookupIndex, name];\n    } // find the first parameter that yields differences\n\n\n    const paramIdx = allSame[0][2].findIndex(({\n      type\n    }, index) => allSame.every(([,, params]) => params[index].type.isSome) && allSame.every(([,, params], aIndex) => aIndex === 0 || !params[index].type.eq(type))); // No param found that is different\n\n    if (paramIdx === -1) {\n      return [lookupIndex, name];\n    } // see if using the param type helps\n\n\n    const adjusted = allSame.map(([oIndex, oName, oParams]) => {\n      const {\n        def,\n        path\n      } = lookup.getSiType(oParams[paramIdx].type.unwrap());\n\n      if (!def.isPrimitive && !path.length) {\n        return [oIndex, null];\n      }\n\n      return [oIndex, def.isPrimitive ? `${oName}${def.asPrimitive.toString()}` : `${oName}${path[path.length - 1].toString()}`];\n    }); // any dupes remaining?\n\n    const noDupes = adjusted.every(([i, n]) => !!n && !adjusted.some(([ai, an]) => i !== ai && n === an));\n\n    if (noDupes) {\n      // we filtered above for null names\n      adjusted.forEach(([index, name]) => {\n        rewrite[index] = name;\n      });\n    }\n\n    return noDupes ? [lookupIndex, name] : [lookupIndex, null];\n  }).filter(n => !!n[1]).map(([lookupIndex, name]) => [lookupIndex, rewrite[lookupIndex] || name]);\n}\n\nfunction extractName(types, {\n  id,\n  type: {\n    params,\n    path\n  }\n}) {\n  const lookupIndex = id.toNumber();\n\n  if (!path.length || WRAPPERS.includes(path[path.length - 1].toString())) {\n    return [lookupIndex, null, []];\n  }\n\n  const parts = path.map(p => stringUpperFirst(stringCamelCase(p))).filter((p, index) => ( // Remove ::{pallet, traits, types}::\n  index !== 1 || !['Pallet', 'Traits', 'Types'].includes(p.toString())) && ( // sp_runtime::generic::digest::Digest -> sp_runtime::generic::Digest\n  // sp_runtime::multiaddress::MultiAddress -> sp_runtime::MultiAddress\n  index === path.length - 1 || p.toLowerCase() !== path[index + 1].toLowerCase()));\n  let typeName = parts.join('');\n\n  if (parts.length === 2 && parts[parts.length - 1] === 'RawOrigin' && params.length === 2 && params[1].type.isSome) {\n    // Do magic for RawOrigin lookup\n    const instanceType = types[params[1].type.unwrap().toNumber()];\n\n    if (instanceType.type.path.length === 2) {\n      typeName = `${typeName}${instanceType.type.path[1].toString()}`;\n    }\n  }\n\n  return [lookupIndex, typeName, params];\n}\n\nfunction extractNames(lookup, types) {\n  const dedup = removeDuplicateNames(lookup, types.map(t => extractName(types, t)));\n  const [names, typesNew] = dedup.reduce(([names, types], [lookupIndex, name]) => {\n    // We set the name for this specific type\n    names[lookupIndex] = name; // we map to the actual lookupIndex\n\n    types[name] = lookup.registry.createLookupType(lookupIndex);\n    return [names, types];\n  }, [{}, {}]);\n  lookup.registry.register(typesNew);\n  return names;\n}\n\nvar _names = /*#__PURE__*/_classPrivateFieldLooseKey(\"names\");\n\nvar _typeDefs = /*#__PURE__*/_classPrivateFieldLooseKey(\"typeDefs\");\n\nvar _createSiDef = /*#__PURE__*/_classPrivateFieldLooseKey(\"createSiDef\");\n\nvar _getLookupId = /*#__PURE__*/_classPrivateFieldLooseKey(\"getLookupId\");\n\nvar _extract = /*#__PURE__*/_classPrivateFieldLooseKey(\"extract\");\n\nvar _extractArray = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractArray\");\n\nvar _extractBitSequence = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractBitSequence\");\n\nvar _extractCompact = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractCompact\");\n\nvar _extractComposite = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractComposite\");\n\nvar _extractCompositeSet = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractCompositeSet\");\n\nvar _extractFields = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractFields\");\n\nvar _extractFieldsAlias = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractFieldsAlias\");\n\nvar _extractHistoric = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractHistoric\");\n\nvar _extractPrimitive = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractPrimitive\");\n\nvar _extractPrimitivePath = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractPrimitivePath\");\n\nvar _extractSequence = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractSequence\");\n\nvar _extractTuple = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractTuple\");\n\nvar _extractVariant = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractVariant\");\n\nvar _extractVariantEnum = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractVariantEnum\");\n\nexport class GenericPortableRegistry extends Struct {\n  constructor(registry, value) {\n    super(registry, {\n      types: 'Vec<PortableType>'\n    }, value);\n    Object.defineProperty(this, _extractVariantEnum, {\n      value: _extractVariantEnum2\n    });\n    Object.defineProperty(this, _extractVariant, {\n      value: _extractVariant2\n    });\n    Object.defineProperty(this, _extractTuple, {\n      value: _extractTuple2\n    });\n    Object.defineProperty(this, _extractSequence, {\n      value: _extractSequence2\n    });\n    Object.defineProperty(this, _extractPrimitivePath, {\n      value: _extractPrimitivePath2\n    });\n    Object.defineProperty(this, _extractPrimitive, {\n      value: _extractPrimitive2\n    });\n    Object.defineProperty(this, _extractHistoric, {\n      value: _extractHistoric2\n    });\n    Object.defineProperty(this, _extractFieldsAlias, {\n      value: _extractFieldsAlias2\n    });\n    Object.defineProperty(this, _extractFields, {\n      value: _extractFields2\n    });\n    Object.defineProperty(this, _extractCompositeSet, {\n      value: _extractCompositeSet2\n    });\n    Object.defineProperty(this, _extractComposite, {\n      value: _extractComposite2\n    });\n    Object.defineProperty(this, _extractCompact, {\n      value: _extractCompact2\n    });\n    Object.defineProperty(this, _extractBitSequence, {\n      value: _extractBitSequence2\n    });\n    Object.defineProperty(this, _extractArray, {\n      value: _extractArray2\n    });\n    Object.defineProperty(this, _extract, {\n      value: _extract2\n    });\n    Object.defineProperty(this, _getLookupId, {\n      value: _getLookupId2\n    });\n    Object.defineProperty(this, _createSiDef, {\n      value: _createSiDef2\n    });\n    Object.defineProperty(this, _names, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _typeDefs, {\n      writable: true,\n      value: {}\n    });\n    _classPrivateFieldLooseBase(this, _names)[_names] = extractNames(this, this.types);\n  }\n  /**\n   * @description The types of the registry\n   */\n\n\n  get types() {\n    return this.get('types');\n  }\n  /**\n   * @description Returns the name for a specific lookup\n   */\n\n\n  getName(lookupId) {\n    return _classPrivateFieldLooseBase(this, _names)[_names][_classPrivateFieldLooseBase(this, _getLookupId)[_getLookupId](lookupId)];\n  }\n  /**\n   * @description Finds a specific type in the registry\n   */\n\n\n  getSiType(lookupId) {\n    const found = this.types[_classPrivateFieldLooseBase(this, _getLookupId)[_getLookupId](lookupId)];\n\n    assert(found, () => `PortableRegistry: Unable to find type with lookupId ${lookupId.toString()}`);\n    return found.type;\n  }\n  /**\n   * @description Lookup the type definition for the index\n   */\n\n\n  getTypeDef(lookupId) {\n    const lookupIndex = _classPrivateFieldLooseBase(this, _getLookupId)[_getLookupId](lookupId);\n\n    if (!_classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex]) {\n      const lookupName = _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex];\n\n      const empty = {\n        info: TypeDefInfo.DoNotConstruct,\n        lookupIndex,\n        lookupName,\n        type: this.registry.createLookupType(lookupIndex)\n      }; // Set named items since we will get into circular lookups along the way\n\n      if (lookupName) {\n        _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex] = empty;\n      }\n\n      const extracted = _classPrivateFieldLooseBase(this, _extract)[_extract](this.getSiType(lookupId), lookupIndex); // For non-named items, we only set this right at the end\n\n\n      if (!lookupName) {\n        _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex] = empty;\n      }\n\n      Object.keys(extracted).forEach(k => {\n        if (k !== 'lookupName' || extracted[k]) {\n          // these are safe since we are looking through the keys as set\n          _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex][k] = extracted[k];\n        }\n      }); // don't set lookupName on lower-level, we want to always direct to the type\n\n      if (extracted.info === TypeDefInfo.Plain) {\n        _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex].lookupNameRoot = _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex].lookupName;\n        delete _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex].lookupName;\n      }\n    }\n\n    return _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex];\n  }\n\n}\n\nfunction _createSiDef2(lookupId) {\n  const typeDef = this.getTypeDef(lookupId);\n  const lookupIndex = lookupId.toNumber(); // Setup for a lookup on complex types\n\n  return [TypeDefInfo.Enum, TypeDefInfo.Struct].includes(typeDef.info) && typeDef.lookupName ? {\n    docs: typeDef.docs,\n    info: TypeDefInfo.Si,\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n    type: this.registry.createLookupType(lookupId)\n  } : typeDef;\n}\n\nfunction _getLookupId2(lookupId) {\n  if (isString(lookupId)) {\n    assert(this.registry.isLookupType(lookupId), () => `PortableRegistry: Expected a lookup string type, found ${lookupId}`);\n    return parseInt(lookupId.replace('Lookup', ''), 10);\n  } else if (isNumber(lookupId)) {\n    return lookupId;\n  }\n\n  return lookupId.toNumber();\n}\n\nfunction _extract2(type, lookupIndex) {\n  const namespace = [...type.path].join('::');\n  let typeDef;\n  const primType = getPrimitivePath(type.path);\n\n  try {\n    if (primType) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractPrimitivePath)[_extractPrimitivePath](lookupIndex, primType);\n    } else if (type.def.isArray) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractArray)[_extractArray](lookupIndex, type.def.asArray);\n    } else if (type.def.isBitSequence) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractBitSequence)[_extractBitSequence](lookupIndex, type.def.asBitSequence);\n    } else if (type.def.isCompact) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractCompact)[_extractCompact](lookupIndex, type.def.asCompact);\n    } else if (type.def.isComposite) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractComposite)[_extractComposite](lookupIndex, type, type.def.asComposite);\n    } else if (type.def.isHistoricMetaCompat) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractHistoric)[_extractHistoric](lookupIndex, type.def.asHistoricMetaCompat);\n    } else if (type.def.isPrimitive) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractPrimitive)[_extractPrimitive](lookupIndex, type);\n    } else if (type.def.isSequence) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractSequence)[_extractSequence](lookupIndex, type.def.asSequence);\n    } else if (type.def.isTuple) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractTuple)[_extractTuple](lookupIndex, type.def.asTuple);\n    } else if (type.def.isVariant) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractVariant)[_extractVariant](lookupIndex, type, type.def.asVariant);\n    } else {\n      throw new Error(`No SiTypeDef handler for ${type.def.toString()}`);\n    }\n  } catch (error) {\n    throw new Error(`PortableRegistry: ${lookupIndex}${namespace ? ` (${namespace})` : ''}: Error extracting ${stringify(type)}: ${error.message}`);\n  }\n\n  return _objectSpread({\n    docs: type.docs.map(d => d.toString()),\n    namespace\n  }, typeDef);\n}\n\nfunction _extractArray2(_, {\n  len: length,\n  type\n}) {\n  assert(!length || length.toNumber() <= 256, 'Only support for [Type; <length>], where length <= 256');\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.VecFixed,\n    length: length.toNumber(),\n    sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type)\n  });\n}\n\nfunction _extractBitSequence2(_, {\n  bitOrderType,\n  bitStoreType\n}) {\n  const bitOrder = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](bitOrderType);\n\n  const bitStore = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](bitStoreType); // NOTE: Currently the BitVec type is one-way only, i.e. we only use it to decode, not\n  // re-encode stuff. As such we ignore the msb/lsb identifier given by bitOrderType, or rather\n  // we don't pass it though at all\n\n\n  assert(['bitvec::order::Lsb0', 'bitvec::order::Msb0'].includes(bitOrder.namespace || ''), () => `Unexpected bitOrder found as ${bitOrder.namespace || '<unknown>'}`);\n  assert(bitStore.info === TypeDefInfo.Plain && bitStore.type === 'u8', () => `Only u8 bitStore is currently supported, found ${bitStore.type}`);\n  return {\n    info: TypeDefInfo.Plain,\n    type: 'BitVec'\n  };\n}\n\nfunction _extractCompact2(_, {\n  type\n}) {\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Compact,\n    sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type)\n  });\n}\n\nfunction _extractComposite2(lookupIndex, {\n  params,\n  path\n}, {\n  fields\n}) {\n  const specialVariant = path[0].toString();\n\n  if (path.length === 1 && specialVariant === 'BTreeMap') {\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.BTreeMap,\n      sub: params.map(({\n        type\n      }) => _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type.unwrap()))\n    });\n  } else if (['Range', 'RangeInclusive'].includes(specialVariant)) {\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Range,\n      sub: fields.map(({\n        name,\n        type\n      }, index) => _objectSpread({\n        name: name.isSome ? name.unwrap().toString() : ['start', 'end'][index]\n      }, _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type)))\n    });\n  }\n\n  return SETS.some(p => matchParts(p, path)) ? _classPrivateFieldLooseBase(this, _extractCompositeSet)[_extractCompositeSet](lookupIndex, params, fields) : _classPrivateFieldLooseBase(this, _extractFields)[_extractFields](lookupIndex, fields);\n}\n\nfunction _extractCompositeSet2(_, params, fields) {\n  assert(params.length === 1 && fields.length === 1, 'Set handling expects param/field as single entries');\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Set,\n    length: this.registry.createType(this.registry.createLookupType(fields[0].type)).bitLength(),\n    sub: this.getSiType(params[0].type.unwrap()).def.asVariant.variants.map(({\n      index,\n      name\n    }) => ({\n      // This will be an issue > 2^53 - 1 ... don't have those (yet)\n      index: index.toNumber(),\n      info: TypeDefInfo.Plain,\n      name: name.toString(),\n      type: 'Null'\n    }))\n  });\n}\n\nfunction _extractFields2(lookupIndex, fields) {\n  const [isStruct, isTuple] = fields.reduce(([isAllNamed, isAllUnnamed], {\n    name\n  }) => [isAllNamed && name.isSome, isAllUnnamed && name.isNone], [true, true]);\n  assert(isTuple || isStruct, 'Invalid fields type detected, expected either Tuple (all unnamed) or Struct (all named)');\n\n  if (fields.length === 0) {\n    return {\n      info: TypeDefInfo.Null,\n      type: 'Null'\n    };\n  } else if (isTuple && fields.length === 1) {\n    const typeDef = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](fields[0].type);\n\n    return _objectSpread(_objectSpread({}, typeDef), lookupIndex === -1 ? {} : {\n      lookupIndex,\n      lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n      lookupNameRoot: typeDef.lookupName\n    });\n  }\n\n  const [sub, alias] = _classPrivateFieldLooseBase(this, _extractFieldsAlias)[_extractFieldsAlias](fields);\n\n  return withTypeString(this.registry, _objectSpread(_objectSpread(_objectSpread({\n    info: isTuple // Tuple check first\n    ? TypeDefInfo.Tuple : TypeDefInfo.Struct\n  }, alias.size ? {\n    alias\n  } : {}), lookupIndex === -1 ? {} : {\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex]\n  }), {}, {\n    sub\n  }));\n}\n\nfunction _extractFieldsAlias2(fields) {\n  const alias = new Map();\n  const sub = fields.map(({\n    docs,\n    name,\n    type\n  }) => {\n    const typeDef = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type);\n\n    if (name.isNone) {\n      return typeDef;\n    }\n\n    let nameField = stringCamelCase(name.unwrap());\n    let nameOrig = null;\n\n    if (nameField.includes('#')) {\n      nameOrig = nameField;\n      nameField = nameOrig.replace(/#/g, '_');\n    } else if (RESERVED.includes(nameField)) {\n      nameOrig = nameField;\n      nameField = `${nameField}_`;\n    }\n\n    if (nameOrig) {\n      alias.set(nameField, nameOrig);\n    }\n\n    return _objectSpread(_objectSpread({}, typeDef), {}, {\n      docs: docs.map(d => d.toString()),\n      name: nameField\n    });\n  });\n  return [sub, alias];\n}\n\nfunction _extractHistoric2(_, type) {\n  return _objectSpread(_objectSpread({}, getTypeDef(type)), {}, {\n    displayName: type.toString(),\n    isFromSi: true\n  });\n}\n\nfunction _extractPrimitive2(_, type) {\n  const typeStr = type.def.asPrimitive.type.toString();\n  return {\n    info: TypeDefInfo.Plain,\n    type: PRIMITIVE_ALIAS[typeStr] || typeStr.toLowerCase()\n  };\n}\n\nfunction _extractPrimitivePath2(_, type) {\n  return {\n    info: TypeDefInfo.Plain,\n    type\n  };\n}\n\nfunction _extractSequence2(lookupIndex, {\n  type\n}) {\n  const sub = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type);\n\n  if (sub.type === 'u8') {\n    return {\n      info: TypeDefInfo.Plain,\n      type: 'Bytes'\n    };\n  }\n\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Vec,\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n    sub\n  });\n}\n\nfunction _extractTuple2(lookupIndex, ids) {\n  if (ids.length === 0) {\n    return {\n      info: TypeDefInfo.Null,\n      type: 'Null'\n    };\n  } else if (ids.length === 1) {\n    return this.getTypeDef(ids[0]);\n  }\n\n  const sub = ids.map(type => _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type));\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Tuple,\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n    sub\n  });\n}\n\nfunction _extractVariant2(lookupIndex, {\n  params,\n  path\n}, {\n  variants\n}) {\n  const specialVariant = path[0].toString();\n\n  if (specialVariant === 'Option') {\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Option,\n      sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](params[0].type.unwrap())\n    });\n  } else if (specialVariant === 'Result') {\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Result,\n      sub: params.map(({\n        type\n      }, index) => _objectSpread({\n        name: ['Ok', 'Error'][index]\n      }, _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type.unwrap())))\n    });\n  } else if (variants.length === 0) {\n    return {\n      info: TypeDefInfo.Null,\n      type: 'Null'\n    };\n  }\n\n  return _classPrivateFieldLooseBase(this, _extractVariantEnum)[_extractVariantEnum](lookupIndex, variants);\n}\n\nfunction _extractVariantEnum2(lookupIndex, variants) {\n  const sub = []; // we may get entries out of order, arrange them first before creating with gaps filled\n  // NOTE: Since we mutate, use a copy of the array as an input\n\n  [...variants].sort((a, b) => a.index.cmp(b.index)).forEach(({\n    fields,\n    index,\n    name\n  }) => {\n    const desired = index.toNumber();\n\n    while (sub.length !== desired) {\n      sub.push({\n        index: sub.length,\n        info: TypeDefInfo.Null,\n        name: `Unused${sub.length}`,\n        type: 'Null'\n      });\n    }\n\n    sub.push(_objectSpread(_objectSpread({}, _classPrivateFieldLooseBase(this, _extractFields)[_extractFields](-1, fields)), {}, {\n      index: index.toNumber(),\n      name: name.toString()\n    }));\n  });\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Enum,\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n    sub\n  });\n}"]},"metadata":{},"sourceType":"module"}