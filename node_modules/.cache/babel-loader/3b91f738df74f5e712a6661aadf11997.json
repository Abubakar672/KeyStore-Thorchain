{"ast":null,"code":"// Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { catchError, combineLatest, map, of, switchMap } from 'rxjs';\nimport { isFunction } from '@polkadot/util';\nimport { memo } from \"../util/index.js\";\nimport { getInstance } from \"./getInstance.js\";\n\nfunction parse(api, [hashes, proposals, votes]) {\n  return proposals.map((proposalOpt, index) => proposalOpt && proposalOpt.isSome ? {\n    hash: api.registry.createType('Hash', hashes[index]),\n    proposal: proposalOpt.unwrap(),\n    votes: votes[index].unwrapOr(null)\n  } : null).filter(proposal => !!proposal);\n}\n\nfunction _proposalsFrom(instanceId, api, section) {\n  return memo(instanceId, hashes => {\n    var _api$query$section;\n\n    return (isFunction((_api$query$section = api.query[section]) === null || _api$query$section === void 0 ? void 0 : _api$query$section.proposals) && hashes.length ? combineLatest([of(hashes), // this should simply be api.query[section].proposalOf.multi<Option<Proposal>>(hashes),\n    // however we have had cases on Edgeware where the indices have moved around after an\n    // upgrade, which results in invalid on-chain data\n    combineLatest(hashes.map(hash => // this should simply be api.query[section].proposalOf.multi<Option<Proposal>>(hashes),\n    // however we have had cases on Edgeware where the indices have moved around after an\n    // upgrade, which results in invalid on-chain data\n    api.query[section].proposalOf(hash).pipe(catchError(() => of(null))))), api.query[section].voting.multi(hashes)]) : of([[], [], []])).pipe(map(result => parse(api, result)));\n  });\n}\n\nexport function hasProposals(instanceId, api, _section) {\n  const section = getInstance(api, _section);\n  return memo(instanceId, () => {\n    var _api$query$section2;\n\n    return of(isFunction((_api$query$section2 = api.query[section]) === null || _api$query$section2 === void 0 ? void 0 : _api$query$section2.proposals));\n  });\n}\nexport function proposalCount(instanceId, api, _section) {\n  const section = getInstance(api, _section);\n  return memo(instanceId, () => isFunction(api.query[section].proposalCount) ? api.query[section].proposalCount() : of(null));\n}\nexport function proposalHashes(instanceId, api, _section) {\n  const section = getInstance(api, _section);\n  return memo(instanceId, () => {\n    var _api$query$section3;\n\n    return isFunction((_api$query$section3 = api.query[section]) === null || _api$query$section3 === void 0 ? void 0 : _api$query$section3.proposals) ? api.query[section].proposals() : of([]);\n  });\n}\nexport function proposals(instanceId, api, _section) {\n  const section = getInstance(api, _section);\n\n  const proposalsFrom = _proposalsFrom(instanceId, api, section);\n\n  const getHashes = proposalHashes(instanceId, api, _section);\n  return memo(instanceId, () => getHashes().pipe(switchMap(proposalsFrom)));\n}\nexport function proposal(instanceId, api, _section) {\n  const section = getInstance(api, _section);\n\n  const proposalsFrom = _proposalsFrom(instanceId, api, section);\n\n  return memo(instanceId, hash => {\n    var _api$query$section4;\n\n    return isFunction((_api$query$section4 = api.query[section]) === null || _api$query$section4 === void 0 ? void 0 : _api$query$section4.proposals) ? proposalsFrom([hash]).pipe(map(([proposal]) => proposal)) : of(null);\n  });\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/api-derive/collective/proposals.js"],"names":["catchError","combineLatest","map","of","switchMap","isFunction","memo","getInstance","parse","api","hashes","proposals","votes","proposalOpt","index","isSome","hash","registry","createType","proposal","unwrap","unwrapOr","filter","_proposalsFrom","instanceId","section","_api$query$section","query","length","proposalOf","pipe","voting","multi","result","hasProposals","_section","_api$query$section2","proposalCount","proposalHashes","_api$query$section3","proposalsFrom","getHashes","_api$query$section4"],"mappings":"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","sourcesContent":["// Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { catchError, combineLatest, map, of, switchMap } from 'rxjs';\nimport { isFunction } from '@polkadot/util';\nimport { memo } from \"../util/index.js\";\nimport { getInstance } from \"./getInstance.js\";\n\nfunction parse(api, [hashes, proposals, votes]) {\n  return proposals.map((proposalOpt, index) => proposalOpt && proposalOpt.isSome ? {\n    hash: api.registry.createType('Hash', hashes[index]),\n    proposal: proposalOpt.unwrap(),\n    votes: votes[index].unwrapOr(null)\n  } : null).filter(proposal => !!proposal);\n}\n\nfunction _proposalsFrom(instanceId, api, section) {\n  return memo(instanceId, hashes => {\n    var _api$query$section;\n\n    return (isFunction((_api$query$section = api.query[section]) === null || _api$query$section === void 0 ? void 0 : _api$query$section.proposals) && hashes.length ? combineLatest([of(hashes), // this should simply be api.query[section].proposalOf.multi<Option<Proposal>>(hashes),\n    // however we have had cases on Edgeware where the indices have moved around after an\n    // upgrade, which results in invalid on-chain data\n    combineLatest(hashes.map(hash => // this should simply be api.query[section].proposalOf.multi<Option<Proposal>>(hashes),\n    // however we have had cases on Edgeware where the indices have moved around after an\n    // upgrade, which results in invalid on-chain data\n    api.query[section].proposalOf(hash).pipe(catchError(() => of(null))))), api.query[section].voting.multi(hashes)]) : of([[], [], []])).pipe(map(result => parse(api, result)));\n  });\n}\n\nexport function hasProposals(instanceId, api, _section) {\n  const section = getInstance(api, _section);\n  return memo(instanceId, () => {\n    var _api$query$section2;\n\n    return of(isFunction((_api$query$section2 = api.query[section]) === null || _api$query$section2 === void 0 ? void 0 : _api$query$section2.proposals));\n  });\n}\nexport function proposalCount(instanceId, api, _section) {\n  const section = getInstance(api, _section);\n  return memo(instanceId, () => isFunction(api.query[section].proposalCount) ? api.query[section].proposalCount() : of(null));\n}\nexport function proposalHashes(instanceId, api, _section) {\n  const section = getInstance(api, _section);\n  return memo(instanceId, () => {\n    var _api$query$section3;\n\n    return isFunction((_api$query$section3 = api.query[section]) === null || _api$query$section3 === void 0 ? void 0 : _api$query$section3.proposals) ? api.query[section].proposals() : of([]);\n  });\n}\nexport function proposals(instanceId, api, _section) {\n  const section = getInstance(api, _section);\n\n  const proposalsFrom = _proposalsFrom(instanceId, api, section);\n\n  const getHashes = proposalHashes(instanceId, api, _section);\n  return memo(instanceId, () => getHashes().pipe(switchMap(proposalsFrom)));\n}\nexport function proposal(instanceId, api, _section) {\n  const section = getInstance(api, _section);\n\n  const proposalsFrom = _proposalsFrom(instanceId, api, section);\n\n  return memo(instanceId, hash => {\n    var _api$query$section4;\n\n    return isFunction((_api$query$section4 = api.query[section]) === null || _api$query$section4 === void 0 ? void 0 : _api$query$section4.proposals) ? proposalsFrom([hash]).pipe(map(([proposal]) => proposal)) : of(null);\n  });\n}"]},"metadata":{},"sourceType":"module"}