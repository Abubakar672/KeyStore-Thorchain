{"ast":null,"code":"// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, compactFromU8a, logger, u8aToU8a } from '@polkadot/util';\nimport { AbstractArray } from \"./AbstractArray.js\";\nimport { decodeU8a, typeToConstructor } from \"./utils/index.js\";\nconst MAX_LENGTH = 64 * 1024;\nconst l = logger('Vec');\n/**\n * @name Vec\n * @description\n * This manages codec arrays. Internally it keeps track of the length (as decoded) and allows\n * construction with the passed `Type` in the constructor. It is an extension to Array, providing\n * specific encoding/decoding on top of the base type.\n */\n\nexport class Vec extends AbstractArray {\n  constructor(registry, Type, value = []) {\n    const Clazz = typeToConstructor(registry, Type);\n    super(registry, Vec.decodeVec(registry, Clazz, value));\n    this._Type = void 0;\n    this._Type = Clazz;\n  }\n  /** @internal */\n\n\n  static decodeVec(registry, Type, value) {\n    if (Array.isArray(value)) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      return value.map((entry, index) => {\n        try {\n          return entry instanceof Type ? entry : new Type(registry, entry);\n        } catch (error) {\n          l.error(`Unable to decode on index ${index}`, error.message);\n          throw error;\n        }\n      });\n    }\n\n    const u8a = u8aToU8a(value);\n    const [offset, length] = compactFromU8a(u8a);\n    assert(length.lten(MAX_LENGTH), () => `Vec length ${length.toString()} exceeds ${MAX_LENGTH}`);\n    return decodeU8a(registry, u8a.subarray(offset), new Array(length.toNumber()).fill(Type));\n  }\n\n  static with(Type) {\n    return class extends Vec {\n      constructor(registry, value) {\n        super(registry, Type, value);\n      }\n\n    };\n  }\n  /**\n   * @description The type for the items\n   */\n\n\n  get Type() {\n    return this._Type.name;\n  }\n  /**\n   * @description Finds the index of the value in the array\n   */\n\n\n  indexOf(_other) {\n    // convert type first, this removes overhead from the eq\n    const other = _other instanceof this._Type ? _other : new this._Type(this.registry, _other);\n\n    for (let i = 0; i < this.length; i++) {\n      if (other.eq(this[i])) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return `Vec<${this.registry.getClassName(this._Type) || new this._Type(this.registry).toRawType()}>`;\n  }\n\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/types/codec/Vec.js"],"names":["assert","compactFromU8a","logger","u8aToU8a","AbstractArray","decodeU8a","typeToConstructor","MAX_LENGTH","l","Vec","constructor","registry","Type","value","Clazz","decodeVec","_Type","Array","isArray","map","entry","index","error","message","u8a","offset","length","lten","toString","subarray","toNumber","fill","with","name","indexOf","_other","other","i","eq","toRawType","getClassName"],"mappings":"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","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, compactFromU8a, logger, u8aToU8a } from '@polkadot/util';\nimport { AbstractArray } from \"./AbstractArray.js\";\nimport { decodeU8a, typeToConstructor } from \"./utils/index.js\";\nconst MAX_LENGTH = 64 * 1024;\nconst l = logger('Vec');\n/**\n * @name Vec\n * @description\n * This manages codec arrays. Internally it keeps track of the length (as decoded) and allows\n * construction with the passed `Type` in the constructor. It is an extension to Array, providing\n * specific encoding/decoding on top of the base type.\n */\n\nexport class Vec extends AbstractArray {\n  constructor(registry, Type, value = []) {\n    const Clazz = typeToConstructor(registry, Type);\n    super(registry, Vec.decodeVec(registry, Clazz, value));\n    this._Type = void 0;\n    this._Type = Clazz;\n  }\n  /** @internal */\n\n\n  static decodeVec(registry, Type, value) {\n    if (Array.isArray(value)) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      return value.map((entry, index) => {\n        try {\n          return entry instanceof Type ? entry : new Type(registry, entry);\n        } catch (error) {\n          l.error(`Unable to decode on index ${index}`, error.message);\n          throw error;\n        }\n      });\n    }\n\n    const u8a = u8aToU8a(value);\n    const [offset, length] = compactFromU8a(u8a);\n    assert(length.lten(MAX_LENGTH), () => `Vec length ${length.toString()} exceeds ${MAX_LENGTH}`);\n    return decodeU8a(registry, u8a.subarray(offset), new Array(length.toNumber()).fill(Type));\n  }\n\n  static with(Type) {\n    return class extends Vec {\n      constructor(registry, value) {\n        super(registry, Type, value);\n      }\n\n    };\n  }\n  /**\n   * @description The type for the items\n   */\n\n\n  get Type() {\n    return this._Type.name;\n  }\n  /**\n   * @description Finds the index of the value in the array\n   */\n\n\n  indexOf(_other) {\n    // convert type first, this removes overhead from the eq\n    const other = _other instanceof this._Type ? _other : new this._Type(this.registry, _other);\n\n    for (let i = 0; i < this.length; i++) {\n      if (other.eq(this[i])) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return `Vec<${this.registry.getClassName(this._Type) || new this._Type(this.registry).toRawType()}>`;\n  }\n\n}"]},"metadata":{},"sourceType":"module"}