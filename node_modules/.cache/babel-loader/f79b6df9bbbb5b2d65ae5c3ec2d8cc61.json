{"ast":null,"code":"// Copyright 2017-2021 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, u8aEq, u8aToU8a } from '@polkadot/util';\nimport { secp256k1Expand } from \"./expand.js\";\nimport { secp256k1Hasher } from \"./hasher.js\";\nimport { secp256k1 } from \"./secp256k1.js\";\n/**\n * @name secp256k1Verify\n * @description Verifies the signature of `message`, using the supplied pair\n */\n\nexport function secp256k1Verify(message, signature, address, hashType = 'blake2') {\n  const isEthereum = hashType === 'keccak';\n  const u8a = u8aToU8a(signature);\n  assert(u8a.length === 65, `Expected signature with 65 bytes, ${u8a.length} found instead`);\n  const publicKey = new Uint8Array( // eslint-disable-next-line @typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-member-access\n  secp256k1.recoverPubKey(secp256k1Hasher(hashType, message), {\n    r: u8a.slice(0, 32),\n    s: u8a.slice(32, 64)\n  }, u8a[64]).encodeCompressed());\n  const signingAddress = secp256k1Hasher(hashType, isEthereum ? secp256k1Expand(publicKey) : publicKey);\n  const inputAddress = u8aToU8a(address); // for Ethereum (keccak) the last 20 bytes is the address\n\n  return isEthereum ? u8aEq(signingAddress.slice(-20), inputAddress.slice(-20)) : u8aEq(signingAddress, inputAddress);\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/util-crypto/secp256k1/verify.js"],"names":["assert","u8aEq","u8aToU8a","secp256k1Expand","secp256k1Hasher","secp256k1","secp256k1Verify","message","signature","address","hashType","isEthereum","u8a","length","publicKey","Uint8Array","recoverPubKey","r","slice","s","encodeCompressed","signingAddress","inputAddress"],"mappings":"AAAA;AACA;AACA,SAASA,MAAT,EAAiBC,KAAjB,EAAwBC,QAAxB,QAAwC,gBAAxC;AACA,SAASC,eAAT,QAAgC,aAAhC;AACA,SAASC,eAAT,QAAgC,aAAhC;AACA,SAASC,SAAT,QAA0B,gBAA1B;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,eAAT,CAAyBC,OAAzB,EAAkCC,SAAlC,EAA6CC,OAA7C,EAAsDC,QAAQ,GAAG,QAAjE,EAA2E;AAChF,QAAMC,UAAU,GAAGD,QAAQ,KAAK,QAAhC;AACA,QAAME,GAAG,GAAGV,QAAQ,CAACM,SAAD,CAApB;AACAR,EAAAA,MAAM,CAACY,GAAG,CAACC,MAAJ,KAAe,EAAhB,EAAqB,qCAAoCD,GAAG,CAACC,MAAO,gBAApE,CAAN;AACA,QAAMC,SAAS,GAAG,IAAIC,UAAJ,EAAgB;AAClCV,EAAAA,SAAS,CAACW,aAAV,CAAwBZ,eAAe,CAACM,QAAD,EAAWH,OAAX,CAAvC,EAA4D;AAC1DU,IAAAA,CAAC,EAAEL,GAAG,CAACM,KAAJ,CAAU,CAAV,EAAa,EAAb,CADuD;AAE1DC,IAAAA,CAAC,EAAEP,GAAG,CAACM,KAAJ,CAAU,EAAV,EAAc,EAAd;AAFuD,GAA5D,EAGGN,GAAG,CAAC,EAAD,CAHN,EAGYQ,gBAHZ,EADkB,CAAlB;AAKA,QAAMC,cAAc,GAAGjB,eAAe,CAACM,QAAD,EAAWC,UAAU,GAAGR,eAAe,CAACW,SAAD,CAAlB,GAAgCA,SAArD,CAAtC;AACA,QAAMQ,YAAY,GAAGpB,QAAQ,CAACO,OAAD,CAA7B,CAVgF,CAUxC;;AAExC,SAAOE,UAAU,GAAGV,KAAK,CAACoB,cAAc,CAACH,KAAf,CAAqB,CAAC,EAAtB,CAAD,EAA4BI,YAAY,CAACJ,KAAb,CAAmB,CAAC,EAApB,CAA5B,CAAR,GAA+DjB,KAAK,CAACoB,cAAD,EAAiBC,YAAjB,CAArF;AACD","sourcesContent":["// Copyright 2017-2021 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, u8aEq, u8aToU8a } from '@polkadot/util';\nimport { secp256k1Expand } from \"./expand.js\";\nimport { secp256k1Hasher } from \"./hasher.js\";\nimport { secp256k1 } from \"./secp256k1.js\";\n/**\n * @name secp256k1Verify\n * @description Verifies the signature of `message`, using the supplied pair\n */\n\nexport function secp256k1Verify(message, signature, address, hashType = 'blake2') {\n  const isEthereum = hashType === 'keccak';\n  const u8a = u8aToU8a(signature);\n  assert(u8a.length === 65, `Expected signature with 65 bytes, ${u8a.length} found instead`);\n  const publicKey = new Uint8Array( // eslint-disable-next-line @typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-member-access\n  secp256k1.recoverPubKey(secp256k1Hasher(hashType, message), {\n    r: u8a.slice(0, 32),\n    s: u8a.slice(32, 64)\n  }, u8a[64]).encodeCompressed());\n  const signingAddress = secp256k1Hasher(hashType, isEthereum ? secp256k1Expand(publicKey) : publicKey);\n  const inputAddress = u8aToU8a(address); // for Ethereum (keccak) the last 20 bytes is the address\n\n  return isEthereum ? u8aEq(signingAddress.slice(-20), inputAddress.slice(-20)) : u8aEq(signingAddress, inputAddress);\n}"]},"metadata":{},"sourceType":"module"}