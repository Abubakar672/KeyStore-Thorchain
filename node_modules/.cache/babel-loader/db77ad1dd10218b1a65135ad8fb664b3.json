{"ast":null,"code":"// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { isBigInt, isBn, isHex, isNumber, isU8a, u8aConcat, u8aToBn, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { decodeAddress } from '@polkadot/util-crypto';\nimport { Base } from \"../codec/Base.js\";\nimport { GenericAccountIndex } from \"../generic/AccountIndex.js\";\nimport { GenericEthereumAccountId } from \"./AccountId.js\"; // eslint-disable-next-line no-use-before-define\n\nexport const ACCOUNT_ID_PREFIX = new Uint8Array([0xff]);\n/** @internal */\n\nfunction decodeString(registry, value) {\n  const decoded = decodeAddress(value);\n  return decoded.length === 20 ? registry.createType('EthereumAccountId', decoded) : registry.createType('AccountIndex', u8aToBn(decoded, true));\n}\n/** @internal */\n\n\nfunction decodeU8a(registry, value) {\n  // This allows us to instantiate an address with a raw publicKey. Do this first before\n  // we checking the first byte, otherwise we may split an already-existent valid address\n  if (value.length === 20) {\n    return registry.createType('EthereumAccountId', value);\n  } else if (value[0] === 0xff) {\n    return registry.createType('EthereumAccountId', value.subarray(1));\n  }\n\n  const [offset, length] = GenericAccountIndex.readLength(value);\n  return registry.createType('AccountIndex', u8aToBn(value.subarray(offset, offset + length), true));\n}\n/**\n * @name GenericEthereumLookupSource\n * @description\n * A wrapper around an EthereumAccountId and/or AccountIndex that is encoded with a prefix.\n * Since we are dealing with underlying publicKeys (or shorter encoded addresses),\n * we extend from Base with an AccountId/AccountIndex wrapper. Basically the Address\n * is encoded as `[ <prefix-byte>, ...publicKey/...bytes ]` as per spec\n */\n\n\nexport class GenericEthereumLookupSource extends Base {\n  constructor(registry, value = new Uint8Array()) {\n    super(registry, GenericEthereumLookupSource._decodeAddress(registry, value));\n  }\n  /** @internal */\n\n\n  static _decodeAddress(registry, value) {\n    return value instanceof GenericEthereumLookupSource ? value._raw : value instanceof GenericEthereumAccountId || value instanceof GenericAccountIndex ? value : isBn(value) || isNumber(value) || isBigInt(value) ? registry.createType('AccountIndex', value) : Array.isArray(value) || isHex(value) || isU8a(value) ? decodeU8a(registry, u8aToU8a(value)) : decodeString(registry, value);\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    const rawLength = this._rawLength;\n    return rawLength + ( // for 1 byte AccountIndexes, we are not adding a specific prefix\n    rawLength > 1 ? 1 : 0);\n  }\n  /**\n   * @description The length of the raw value, either AccountIndex or AccountId\n   */\n\n\n  get _rawLength() {\n    return this._raw instanceof GenericAccountIndex ? GenericAccountIndex.calcLength(this._raw) : this._raw.encodedLength;\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n\n\n  toHex() {\n    return u8aToHex(this.toU8a());\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return 'Address';\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    const encoded = this._raw.toU8a().subarray(0, this._rawLength);\n\n    return isBare ? encoded : u8aConcat(this._raw instanceof GenericAccountIndex ? GenericAccountIndex.writeLength(encoded) : ACCOUNT_ID_PREFIX, encoded);\n  }\n\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/types/ethereum/LookupSource.js"],"names":["isBigInt","isBn","isHex","isNumber","isU8a","u8aConcat","u8aToBn","u8aToHex","u8aToU8a","decodeAddress","Base","GenericAccountIndex","GenericEthereumAccountId","ACCOUNT_ID_PREFIX","Uint8Array","decodeString","registry","value","decoded","length","createType","decodeU8a","subarray","offset","readLength","GenericEthereumLookupSource","constructor","_decodeAddress","_raw","Array","isArray","encodedLength","rawLength","_rawLength","calcLength","toHex","toU8a","toRawType","isBare","encoded","writeLength"],"mappings":"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","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { isBigInt, isBn, isHex, isNumber, isU8a, u8aConcat, u8aToBn, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { decodeAddress } from '@polkadot/util-crypto';\nimport { Base } from \"../codec/Base.js\";\nimport { GenericAccountIndex } from \"../generic/AccountIndex.js\";\nimport { GenericEthereumAccountId } from \"./AccountId.js\"; // eslint-disable-next-line no-use-before-define\n\nexport const ACCOUNT_ID_PREFIX = new Uint8Array([0xff]);\n/** @internal */\n\nfunction decodeString(registry, value) {\n  const decoded = decodeAddress(value);\n  return decoded.length === 20 ? registry.createType('EthereumAccountId', decoded) : registry.createType('AccountIndex', u8aToBn(decoded, true));\n}\n/** @internal */\n\n\nfunction decodeU8a(registry, value) {\n  // This allows us to instantiate an address with a raw publicKey. Do this first before\n  // we checking the first byte, otherwise we may split an already-existent valid address\n  if (value.length === 20) {\n    return registry.createType('EthereumAccountId', value);\n  } else if (value[0] === 0xff) {\n    return registry.createType('EthereumAccountId', value.subarray(1));\n  }\n\n  const [offset, length] = GenericAccountIndex.readLength(value);\n  return registry.createType('AccountIndex', u8aToBn(value.subarray(offset, offset + length), true));\n}\n/**\n * @name GenericEthereumLookupSource\n * @description\n * A wrapper around an EthereumAccountId and/or AccountIndex that is encoded with a prefix.\n * Since we are dealing with underlying publicKeys (or shorter encoded addresses),\n * we extend from Base with an AccountId/AccountIndex wrapper. Basically the Address\n * is encoded as `[ <prefix-byte>, ...publicKey/...bytes ]` as per spec\n */\n\n\nexport class GenericEthereumLookupSource extends Base {\n  constructor(registry, value = new Uint8Array()) {\n    super(registry, GenericEthereumLookupSource._decodeAddress(registry, value));\n  }\n  /** @internal */\n\n\n  static _decodeAddress(registry, value) {\n    return value instanceof GenericEthereumLookupSource ? value._raw : value instanceof GenericEthereumAccountId || value instanceof GenericAccountIndex ? value : isBn(value) || isNumber(value) || isBigInt(value) ? registry.createType('AccountIndex', value) : Array.isArray(value) || isHex(value) || isU8a(value) ? decodeU8a(registry, u8aToU8a(value)) : decodeString(registry, value);\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    const rawLength = this._rawLength;\n    return rawLength + ( // for 1 byte AccountIndexes, we are not adding a specific prefix\n    rawLength > 1 ? 1 : 0);\n  }\n  /**\n   * @description The length of the raw value, either AccountIndex or AccountId\n   */\n\n\n  get _rawLength() {\n    return this._raw instanceof GenericAccountIndex ? GenericAccountIndex.calcLength(this._raw) : this._raw.encodedLength;\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n\n\n  toHex() {\n    return u8aToHex(this.toU8a());\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return 'Address';\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    const encoded = this._raw.toU8a().subarray(0, this._rawLength);\n\n    return isBare ? encoded : u8aConcat(this._raw instanceof GenericAccountIndex ? GenericAccountIndex.writeLength(encoded) : ACCOUNT_ID_PREFIX, encoded);\n  }\n\n}"]},"metadata":{},"sourceType":"module"}