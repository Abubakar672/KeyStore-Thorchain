{"ast":null,"code":"// OP_0 [signatures ...]\nvar Buffer = require('safe-buffer').Buffer;\n\nvar bscript = require('../../script');\n\nvar p2mso = require('./output');\n\nvar typeforce = require('typeforce');\n\nvar OPS = require('@psf/bitcoincash-ops');\n\nfunction partialSignature(value) {\n  return value === OPS.OP_0 || bscript.isCanonicalSignature(value);\n}\n\nfunction check(script, allowIncomplete) {\n  var chunks = bscript.decompile(script);\n  if (chunks.length < 2) return false;\n  if (chunks[0] !== OPS.OP_0) return false;\n\n  if (allowIncomplete) {\n    return chunks.slice(1).every(partialSignature);\n  }\n\n  return chunks.slice(1).every(bscript.isCanonicalSignature);\n}\n\ncheck.toJSON = function () {\n  return 'multisig input';\n};\n\nvar EMPTY_BUFFER = Buffer.allocUnsafe(0);\n\nfunction encodeStack(signatures, scriptPubKey) {\n  typeforce([partialSignature], signatures);\n\n  if (scriptPubKey) {\n    var scriptData = p2mso.decode(scriptPubKey);\n\n    if (signatures.length < scriptData.m) {\n      throw new TypeError('Not enough signatures provided');\n    }\n\n    if (signatures.length > scriptData.pubKeys.length) {\n      throw new TypeError('Too many signatures provided');\n    }\n  }\n\n  return [].concat(EMPTY_BUFFER, signatures.map(function (sig) {\n    if (sig === OPS.OP_0) {\n      return EMPTY_BUFFER;\n    }\n\n    return sig;\n  }));\n}\n\nfunction encode(signatures, scriptPubKey) {\n  return bscript.compile(encodeStack(signatures, scriptPubKey));\n}\n\nfunction decodeStack(stack, allowIncomplete) {\n  typeforce(typeforce.Array, stack);\n  typeforce(check, stack, allowIncomplete);\n  return stack.slice(1);\n}\n\nfunction decode(buffer, allowIncomplete) {\n  var stack = bscript.decompile(buffer);\n  return decodeStack(stack, allowIncomplete);\n}\n\nmodule.exports = {\n  check: check,\n  decode: decode,\n  decodeStack: decodeStack,\n  encode: encode,\n  encodeStack: encodeStack\n};","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@psf/bitcoincashjs-lib/src/templates/multisig/input.js"],"names":["Buffer","require","bscript","p2mso","typeforce","OPS","partialSignature","value","OP_0","isCanonicalSignature","check","script","allowIncomplete","chunks","decompile","length","slice","every","toJSON","EMPTY_BUFFER","allocUnsafe","encodeStack","signatures","scriptPubKey","scriptData","decode","m","TypeError","pubKeys","concat","map","sig","encode","compile","decodeStack","stack","Array","buffer","module","exports"],"mappings":"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","sourcesContent":["// OP_0 [signatures ...]\n\nvar Buffer = require('safe-buffer').Buffer\nvar bscript = require('../../script')\nvar p2mso = require('./output')\nvar typeforce = require('typeforce')\nvar OPS = require('@psf/bitcoincash-ops')\n\nfunction partialSignature (value) {\n  return value === OPS.OP_0 || bscript.isCanonicalSignature(value)\n}\n\nfunction check (script, allowIncomplete) {\n  var chunks = bscript.decompile(script)\n  if (chunks.length < 2) return false\n  if (chunks[0] !== OPS.OP_0) return false\n\n  if (allowIncomplete) {\n    return chunks.slice(1).every(partialSignature)\n  }\n\n  return chunks.slice(1).every(bscript.isCanonicalSignature)\n}\ncheck.toJSON = function () { return 'multisig input' }\n\nvar EMPTY_BUFFER = Buffer.allocUnsafe(0)\n\nfunction encodeStack (signatures, scriptPubKey) {\n  typeforce([partialSignature], signatures)\n\n  if (scriptPubKey) {\n    var scriptData = p2mso.decode(scriptPubKey)\n\n    if (signatures.length < scriptData.m) {\n      throw new TypeError('Not enough signatures provided')\n    }\n\n    if (signatures.length > scriptData.pubKeys.length) {\n      throw new TypeError('Too many signatures provided')\n    }\n  }\n\n  return [].concat(EMPTY_BUFFER, signatures.map(function (sig) {\n    if (sig === OPS.OP_0) {\n      return EMPTY_BUFFER\n    }\n    return sig\n  }))\n}\n\nfunction encode (signatures, scriptPubKey) {\n  return bscript.compile(encodeStack(signatures, scriptPubKey))\n}\n\nfunction decodeStack (stack, allowIncomplete) {\n  typeforce(typeforce.Array, stack)\n  typeforce(check, stack, allowIncomplete)\n  return stack.slice(1)\n}\n\nfunction decode (buffer, allowIncomplete) {\n  var stack = bscript.decompile(buffer)\n  return decodeStack(stack, allowIncomplete)\n}\n\nmodule.exports = {\n  check: check,\n  decode: decode,\n  decodeStack: decodeStack,\n  encode: encode,\n  encodeStack: encodeStack\n}\n"]},"metadata":{},"sourceType":"script"}