{"ast":null,"code":"// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isString, u8aToU8a } from '@polkadot/util';\nimport { Raw } from \"./Raw.js\";\n/** @internal */\n\nfunction decodeU8aFixed(value, bitLength) {\n  if (Array.isArray(value) || isString(value)) {\n    return decodeU8aFixed(u8aToU8a(value), bitLength);\n  }\n\n  const byteLength = bitLength / 8;\n  const u8a = new Uint8Array(byteLength);\n\n  if (!value || !value.length) {\n    return u8a;\n  }\n\n  assert(value.length >= byteLength, () => `Expected at least ${byteLength} bytes (${bitLength} bits), found ${value.length} bytes`);\n  return value.subarray(0, byteLength);\n}\n/**\n * @name U8aFixed\n * @description\n * A U8a that manages a a sequence of bytes up to the specified bitLength. Not meant\n * to be used directly, rather is should be subclassed with the specific lengths.\n */\n\n\nexport class U8aFixed extends Raw {\n  constructor(registry, value = new Uint8Array(), bitLength = 256) {\n    super(registry, decodeU8aFixed(value, bitLength));\n  }\n\n  static with(bitLength, typeName) {\n    return class extends U8aFixed {\n      constructor(registry, value) {\n        super(registry, value, bitLength);\n      }\n\n      toRawType() {\n        return typeName || super.toRawType();\n      }\n\n    };\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return `[u8;${this.length}]`;\n  }\n\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/types/codec/U8aFixed.js"],"names":["assert","isString","u8aToU8a","Raw","decodeU8aFixed","value","bitLength","Array","isArray","byteLength","u8a","Uint8Array","length","subarray","U8aFixed","constructor","registry","with","typeName","toRawType"],"mappings":"AAAA;AACA;AACA,SAASA,MAAT,EAAiBC,QAAjB,EAA2BC,QAA3B,QAA2C,gBAA3C;AACA,SAASC,GAAT,QAAoB,UAApB;AACA;;AAEA,SAASC,cAAT,CAAwBC,KAAxB,EAA+BC,SAA/B,EAA0C;AACxC,MAAIC,KAAK,CAACC,OAAN,CAAcH,KAAd,KAAwBJ,QAAQ,CAACI,KAAD,CAApC,EAA6C;AAC3C,WAAOD,cAAc,CAACF,QAAQ,CAACG,KAAD,CAAT,EAAkBC,SAAlB,CAArB;AACD;;AAED,QAAMG,UAAU,GAAGH,SAAS,GAAG,CAA/B;AACA,QAAMI,GAAG,GAAG,IAAIC,UAAJ,CAAeF,UAAf,CAAZ;;AAEA,MAAI,CAACJ,KAAD,IAAU,CAACA,KAAK,CAACO,MAArB,EAA6B;AAC3B,WAAOF,GAAP;AACD;;AAEDV,EAAAA,MAAM,CAACK,KAAK,CAACO,MAAN,IAAgBH,UAAjB,EAA6B,MAAO,qBAAoBA,UAAW,WAAUH,SAAU,iBAAgBD,KAAK,CAACO,MAAO,QAApH,CAAN;AACA,SAAOP,KAAK,CAACQ,QAAN,CAAe,CAAf,EAAkBJ,UAAlB,CAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;;AAGA,OAAO,MAAMK,QAAN,SAAuBX,GAAvB,CAA2B;AAChCY,EAAAA,WAAW,CAACC,QAAD,EAAWX,KAAK,GAAG,IAAIM,UAAJ,EAAnB,EAAqCL,SAAS,GAAG,GAAjD,EAAsD;AAC/D,UAAMU,QAAN,EAAgBZ,cAAc,CAACC,KAAD,EAAQC,SAAR,CAA9B;AACD;;AAEU,SAAJW,IAAI,CAACX,SAAD,EAAYY,QAAZ,EAAsB;AAC/B,WAAO,cAAcJ,QAAd,CAAuB;AAC5BC,MAAAA,WAAW,CAACC,QAAD,EAAWX,KAAX,EAAkB;AAC3B,cAAMW,QAAN,EAAgBX,KAAhB,EAAuBC,SAAvB;AACD;;AAEDa,MAAAA,SAAS,GAAG;AACV,eAAOD,QAAQ,IAAI,MAAMC,SAAN,EAAnB;AACD;;AAP2B,KAA9B;AAUD;AACD;AACF;AACA;;;AAGEA,EAAAA,SAAS,GAAG;AACV,WAAQ,OAAM,KAAKP,MAAO,GAA1B;AACD;;AAxB+B","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isString, u8aToU8a } from '@polkadot/util';\nimport { Raw } from \"./Raw.js\";\n/** @internal */\n\nfunction decodeU8aFixed(value, bitLength) {\n  if (Array.isArray(value) || isString(value)) {\n    return decodeU8aFixed(u8aToU8a(value), bitLength);\n  }\n\n  const byteLength = bitLength / 8;\n  const u8a = new Uint8Array(byteLength);\n\n  if (!value || !value.length) {\n    return u8a;\n  }\n\n  assert(value.length >= byteLength, () => `Expected at least ${byteLength} bytes (${bitLength} bits), found ${value.length} bytes`);\n  return value.subarray(0, byteLength);\n}\n/**\n * @name U8aFixed\n * @description\n * A U8a that manages a a sequence of bytes up to the specified bitLength. Not meant\n * to be used directly, rather is should be subclassed with the specific lengths.\n */\n\n\nexport class U8aFixed extends Raw {\n  constructor(registry, value = new Uint8Array(), bitLength = 256) {\n    super(registry, decodeU8aFixed(value, bitLength));\n  }\n\n  static with(bitLength, typeName) {\n    return class extends U8aFixed {\n      constructor(registry, value) {\n        super(registry, value, bitLength);\n      }\n\n      toRawType() {\n        return typeName || super.toRawType();\n      }\n\n    };\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return `[u8;${this.length}]`;\n  }\n\n}"]},"metadata":{},"sourceType":"module"}