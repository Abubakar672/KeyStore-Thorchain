{"ast":null,"code":"var Buffer = require('safe-buffer').Buffer;\n\nvar base58check = require('bs58check');\n\nvar bcrypto = require('./crypto');\n\nvar createHmac = require('create-hmac');\n\nvar typeforce = require('typeforce');\n\nvar types = require('./types');\n\nvar NETWORKS = require('./networks');\n\nvar BigInteger = require('bigi');\n\nvar ECPair = require('./ecpair');\n\nvar ecurve = require('ecurve');\n\nvar curve = ecurve.getCurveByName('secp256k1');\n\nfunction HDNode(keyPair, chainCode) {\n  // CT 6/18/2020 Commented this out. It causes problems with Gatsby and other\n  // web apps that use webpack. Somehow the keyPair comes through in a way that\n  // is perfectly valid, but failes the type check.\n  // typeforce(types.tuple('ECPair', types.Buffer256bit), arguments)\n  if (!keyPair.compressed) throw new TypeError('BIP32 only allows compressed keyPairs');\n  this.keyPair = keyPair;\n  this.chainCode = chainCode;\n  this.depth = 0;\n  this.index = 0;\n  this.parentFingerprint = 0x00000000;\n}\n\nHDNode.HIGHEST_BIT = 0x80000000;\nHDNode.LENGTH = 78;\nHDNode.MASTER_SECRET = Buffer.from('Bitcoin seed', 'utf8');\n\nHDNode.fromSeedBuffer = function (seed, network) {\n  typeforce(types.tuple(types.Buffer, types.maybe(types.Network)), arguments);\n  if (seed.length < 16) throw new TypeError('Seed should be at least 128 bits');\n  if (seed.length > 64) throw new TypeError('Seed should be at most 512 bits');\n  var I = createHmac('sha512', HDNode.MASTER_SECRET).update(seed).digest();\n  var IL = I.slice(0, 32);\n  var IR = I.slice(32); // In case IL is 0 or >= n, the master key is invalid\n  // This is handled by the ECPair constructor\n\n  var pIL = BigInteger.fromBuffer(IL);\n  var keyPair = new ECPair(pIL, null, {\n    network: network\n  });\n  return new HDNode(keyPair, IR);\n};\n\nHDNode.fromSeedHex = function (hex, network) {\n  return HDNode.fromSeedBuffer(Buffer.from(hex, 'hex'), network);\n};\n\nHDNode.fromBase58 = function (string, networks) {\n  var buffer = base58check.decode(string);\n  if (buffer.length !== 78) throw new Error('Invalid buffer length'); // 4 bytes: version bytes\n\n  var version = buffer.readUInt32BE(0);\n  var network; // list of networks?\n\n  if (Array.isArray(networks)) {\n    network = networks.filter(function (x) {\n      return version === x.bip32.private || version === x.bip32.public;\n    }).pop();\n    if (!network) throw new Error('Unknown network version'); // otherwise, assume a network object (or default to bitcoin)\n  } else {\n    network = networks || NETWORKS.bitcoin;\n  }\n\n  if (version !== network.bip32.private && version !== network.bip32.public) throw new Error('Invalid network version'); // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...\n\n  var depth = buffer[4]; // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n\n  var parentFingerprint = buffer.readUInt32BE(5);\n\n  if (depth === 0) {\n    if (parentFingerprint !== 0x00000000) throw new Error('Invalid parent fingerprint');\n  } // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n  // This is encoded in MSB order. (0x00000000 if master key)\n\n\n  var index = buffer.readUInt32BE(9);\n  if (depth === 0 && index !== 0) throw new Error('Invalid index'); // 32 bytes: the chain code\n\n  var chainCode = buffer.slice(13, 45);\n  var keyPair; // 33 bytes: private key data (0x00 + k)\n\n  if (version === network.bip32.private) {\n    if (buffer.readUInt8(45) !== 0x00) throw new Error('Invalid private key');\n    var d = BigInteger.fromBuffer(buffer.slice(46, 78));\n    keyPair = new ECPair(d, null, {\n      network: network\n    }); // 33 bytes: public key data (0x02 + X or 0x03 + X)\n  } else {\n    var Q = ecurve.Point.decodeFrom(curve, buffer.slice(45, 78)); // Q.compressed is assumed, if somehow this assumption is broken, `new HDNode` will throw\n    // Verify that the X coordinate in the public point corresponds to a point on the curve.\n    // If not, the extended public key is invalid.\n\n    curve.validate(Q);\n    keyPair = new ECPair(null, Q, {\n      network: network\n    });\n  }\n\n  var hd = new HDNode(keyPair, chainCode);\n  hd.depth = depth;\n  hd.index = index;\n  hd.parentFingerprint = parentFingerprint;\n  return hd;\n};\n\nHDNode.prototype.getAddress = function () {\n  return this.keyPair.getAddress();\n};\n\nHDNode.prototype.getIdentifier = function () {\n  return bcrypto.hash160(this.keyPair.getPublicKeyBuffer());\n};\n\nHDNode.prototype.getFingerprint = function () {\n  return this.getIdentifier().slice(0, 4);\n};\n\nHDNode.prototype.getNetwork = function () {\n  return this.keyPair.getNetwork();\n};\n\nHDNode.prototype.getPublicKeyBuffer = function () {\n  return this.keyPair.getPublicKeyBuffer();\n};\n\nHDNode.prototype.neutered = function () {\n  var neuteredKeyPair = new ECPair(null, this.keyPair.Q, {\n    network: this.keyPair.network\n  });\n  var neutered = new HDNode(neuteredKeyPair, this.chainCode);\n  neutered.depth = this.depth;\n  neutered.index = this.index;\n  neutered.parentFingerprint = this.parentFingerprint;\n  return neutered;\n};\n\nHDNode.prototype.sign = function (hash) {\n  return this.keyPair.sign(hash);\n};\n\nHDNode.prototype.verify = function (hash, signature) {\n  return this.keyPair.verify(hash, signature);\n};\n\nHDNode.prototype.toBase58 = function (__isPrivate) {\n  if (__isPrivate !== undefined) throw new TypeError('Unsupported argument in 2.0.0'); // Version\n\n  var network = this.keyPair.network;\n  var version = !this.isNeutered() ? network.bip32.private : network.bip32.public;\n  var buffer = Buffer.allocUnsafe(78); // 4 bytes: version bytes\n\n  buffer.writeUInt32BE(version, 0); // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....\n\n  buffer.writeUInt8(this.depth, 4); // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n\n  buffer.writeUInt32BE(this.parentFingerprint, 5); // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n  // This is encoded in big endian. (0x00000000 if master key)\n\n  buffer.writeUInt32BE(this.index, 9); // 32 bytes: the chain code\n\n  this.chainCode.copy(buffer, 13); // 33 bytes: the public key or private key data\n\n  if (!this.isNeutered()) {\n    // 0x00 + k for private keys\n    buffer.writeUInt8(0, 45);\n    this.keyPair.d.toBuffer(32).copy(buffer, 46); // 33 bytes: the public key\n  } else {\n    // X9.62 encoding for public keys\n    this.keyPair.getPublicKeyBuffer().copy(buffer, 45);\n  }\n\n  return base58check.encode(buffer);\n}; // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions\n\n\nHDNode.prototype.derive = function (index) {\n  typeforce(types.UInt32, index);\n  var isHardened = index >= HDNode.HIGHEST_BIT;\n  var data = Buffer.allocUnsafe(37); // Hardened child\n\n  if (isHardened) {\n    if (this.isNeutered()) throw new TypeError('Could not derive hardened child key'); // data = 0x00 || ser256(kpar) || ser32(index)\n\n    data[0] = 0x00;\n    this.keyPair.d.toBuffer(32).copy(data, 1);\n    data.writeUInt32BE(index, 33); // Normal child\n  } else {\n    // data = serP(point(kpar)) || ser32(index)\n    //      = serP(Kpar) || ser32(index)\n    this.keyPair.getPublicKeyBuffer().copy(data, 0);\n    data.writeUInt32BE(index, 33);\n  }\n\n  var I = createHmac('sha512', this.chainCode).update(data).digest();\n  var IL = I.slice(0, 32);\n  var IR = I.slice(32);\n  var pIL = BigInteger.fromBuffer(IL); // In case parse256(IL) >= n, proceed with the next value for i\n\n  if (pIL.compareTo(curve.n) >= 0) {\n    return this.derive(index + 1);\n  } // Private parent key -> private child key\n\n\n  var derivedKeyPair;\n\n  if (!this.isNeutered()) {\n    // ki = parse256(IL) + kpar (mod n)\n    var ki = pIL.add(this.keyPair.d).mod(curve.n); // In case ki == 0, proceed with the next value for i\n\n    if (ki.signum() === 0) {\n      return this.derive(index + 1);\n    }\n\n    derivedKeyPair = new ECPair(ki, null, {\n      network: this.keyPair.network\n    }); // Public parent key -> public child key\n  } else {\n    // Ki = point(parse256(IL)) + Kpar\n    //    = G*IL + Kpar\n    var Ki = curve.G.multiply(pIL).add(this.keyPair.Q); // In case Ki is the point at infinity, proceed with the next value for i\n\n    if (curve.isInfinity(Ki)) {\n      return this.derive(index + 1);\n    }\n\n    derivedKeyPair = new ECPair(null, Ki, {\n      network: this.keyPair.network\n    });\n  }\n\n  var hd = new HDNode(derivedKeyPair, IR);\n  hd.depth = this.depth + 1;\n  hd.index = index;\n  hd.parentFingerprint = this.getFingerprint().readUInt32BE(0);\n  return hd;\n};\n\nHDNode.prototype.deriveHardened = function (index) {\n  typeforce(types.UInt31, index); // Only derives hardened private keys by default\n\n  return this.derive(index + HDNode.HIGHEST_BIT);\n}; // Private === not neutered\n// Public === neutered\n\n\nHDNode.prototype.isNeutered = function () {\n  return !this.keyPair.d;\n};\n\nHDNode.prototype.derivePath = function (path) {\n  typeforce(types.BIP32Path, path);\n  var splitPath = path.split('/');\n\n  if (splitPath[0] === 'm') {\n    if (this.parentFingerprint) {\n      throw new Error('Not a master node');\n    }\n\n    splitPath = splitPath.slice(1);\n  }\n\n  return splitPath.reduce(function (prevHd, indexStr) {\n    var index;\n\n    if (indexStr.slice(-1) === \"'\") {\n      index = parseInt(indexStr.slice(0, -1), 10);\n      return prevHd.deriveHardened(index);\n    } else {\n      index = parseInt(indexStr, 10);\n      return prevHd.derive(index);\n    }\n  }, this);\n};\n\nmodule.exports = HDNode;","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@psf/bitcoincashjs-lib/src/hdnode.js"],"names":["Buffer","require","base58check","bcrypto","createHmac","typeforce","types","NETWORKS","BigInteger","ECPair","ecurve","curve","getCurveByName","HDNode","keyPair","chainCode","compressed","TypeError","depth","index","parentFingerprint","HIGHEST_BIT","LENGTH","MASTER_SECRET","from","fromSeedBuffer","seed","network","tuple","maybe","Network","arguments","length","I","update","digest","IL","slice","IR","pIL","fromBuffer","fromSeedHex","hex","fromBase58","string","networks","buffer","decode","Error","version","readUInt32BE","Array","isArray","filter","x","bip32","private","public","pop","bitcoin","readUInt8","d","Q","Point","decodeFrom","validate","hd","prototype","getAddress","getIdentifier","hash160","getPublicKeyBuffer","getFingerprint","getNetwork","neutered","neuteredKeyPair","sign","hash","verify","signature","toBase58","__isPrivate","undefined","isNeutered","allocUnsafe","writeUInt32BE","writeUInt8","copy","toBuffer","encode","derive","UInt32","isHardened","data","compareTo","n","derivedKeyPair","ki","add","mod","signum","Ki","G","multiply","isInfinity","deriveHardened","UInt31","derivePath","path","BIP32Path","splitPath","split","reduce","prevHd","indexStr","parseInt","module","exports"],"mappings":"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","sourcesContent":["var Buffer = require('safe-buffer').Buffer\nvar base58check = require('bs58check')\nvar bcrypto = require('./crypto')\nvar createHmac = require('create-hmac')\nvar typeforce = require('typeforce')\nvar types = require('./types')\nvar NETWORKS = require('./networks')\n\nvar BigInteger = require('bigi')\nvar ECPair = require('./ecpair')\n\nvar ecurve = require('ecurve')\nvar curve = ecurve.getCurveByName('secp256k1')\n\nfunction HDNode (keyPair, chainCode) {\n  // CT 6/18/2020 Commented this out. It causes problems with Gatsby and other\n  // web apps that use webpack. Somehow the keyPair comes through in a way that\n  // is perfectly valid, but failes the type check.\n  // typeforce(types.tuple('ECPair', types.Buffer256bit), arguments)\n\n  if (!keyPair.compressed) throw new TypeError('BIP32 only allows compressed keyPairs')\n\n  this.keyPair = keyPair\n  this.chainCode = chainCode\n  this.depth = 0\n  this.index = 0\n  this.parentFingerprint = 0x00000000\n}\n\nHDNode.HIGHEST_BIT = 0x80000000\nHDNode.LENGTH = 78\nHDNode.MASTER_SECRET = Buffer.from('Bitcoin seed', 'utf8')\n\nHDNode.fromSeedBuffer = function (seed, network) {\n  typeforce(types.tuple(types.Buffer, types.maybe(types.Network)), arguments)\n\n  if (seed.length < 16) throw new TypeError('Seed should be at least 128 bits')\n  if (seed.length > 64) throw new TypeError('Seed should be at most 512 bits')\n\n  var I = createHmac('sha512', HDNode.MASTER_SECRET).update(seed).digest()\n  var IL = I.slice(0, 32)\n  var IR = I.slice(32)\n\n  // In case IL is 0 or >= n, the master key is invalid\n  // This is handled by the ECPair constructor\n  var pIL = BigInteger.fromBuffer(IL)\n  var keyPair = new ECPair(pIL, null, {\n    network: network\n  })\n\n  return new HDNode(keyPair, IR)\n}\n\nHDNode.fromSeedHex = function (hex, network) {\n  return HDNode.fromSeedBuffer(Buffer.from(hex, 'hex'), network)\n}\n\nHDNode.fromBase58 = function (string, networks) {\n  var buffer = base58check.decode(string)\n  if (buffer.length !== 78) throw new Error('Invalid buffer length')\n\n  // 4 bytes: version bytes\n  var version = buffer.readUInt32BE(0)\n  var network\n\n  // list of networks?\n  if (Array.isArray(networks)) {\n    network = networks.filter(function (x) {\n      return version === x.bip32.private ||\n             version === x.bip32.public\n    }).pop()\n\n    if (!network) throw new Error('Unknown network version')\n\n  // otherwise, assume a network object (or default to bitcoin)\n  } else {\n    network = networks || NETWORKS.bitcoin\n  }\n\n  if (version !== network.bip32.private &&\n    version !== network.bip32.public) throw new Error('Invalid network version')\n\n  // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...\n  var depth = buffer[4]\n\n  // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n  var parentFingerprint = buffer.readUInt32BE(5)\n  if (depth === 0) {\n    if (parentFingerprint !== 0x00000000) throw new Error('Invalid parent fingerprint')\n  }\n\n  // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n  // This is encoded in MSB order. (0x00000000 if master key)\n  var index = buffer.readUInt32BE(9)\n  if (depth === 0 && index !== 0) throw new Error('Invalid index')\n\n  // 32 bytes: the chain code\n  var chainCode = buffer.slice(13, 45)\n  var keyPair\n\n  // 33 bytes: private key data (0x00 + k)\n  if (version === network.bip32.private) {\n    if (buffer.readUInt8(45) !== 0x00) throw new Error('Invalid private key')\n\n    var d = BigInteger.fromBuffer(buffer.slice(46, 78))\n    keyPair = new ECPair(d, null, { network: network })\n\n  // 33 bytes: public key data (0x02 + X or 0x03 + X)\n  } else {\n    var Q = ecurve.Point.decodeFrom(curve, buffer.slice(45, 78))\n    // Q.compressed is assumed, if somehow this assumption is broken, `new HDNode` will throw\n\n    // Verify that the X coordinate in the public point corresponds to a point on the curve.\n    // If not, the extended public key is invalid.\n    curve.validate(Q)\n\n    keyPair = new ECPair(null, Q, { network: network })\n  }\n\n  var hd = new HDNode(keyPair, chainCode)\n  hd.depth = depth\n  hd.index = index\n  hd.parentFingerprint = parentFingerprint\n\n  return hd\n}\n\nHDNode.prototype.getAddress = function () {\n  return this.keyPair.getAddress()\n}\n\nHDNode.prototype.getIdentifier = function () {\n  return bcrypto.hash160(this.keyPair.getPublicKeyBuffer())\n}\n\nHDNode.prototype.getFingerprint = function () {\n  return this.getIdentifier().slice(0, 4)\n}\n\nHDNode.prototype.getNetwork = function () {\n  return this.keyPair.getNetwork()\n}\n\nHDNode.prototype.getPublicKeyBuffer = function () {\n  return this.keyPair.getPublicKeyBuffer()\n}\n\nHDNode.prototype.neutered = function () {\n  var neuteredKeyPair = new ECPair(null, this.keyPair.Q, {\n    network: this.keyPair.network\n  })\n\n  var neutered = new HDNode(neuteredKeyPair, this.chainCode)\n  neutered.depth = this.depth\n  neutered.index = this.index\n  neutered.parentFingerprint = this.parentFingerprint\n\n  return neutered\n}\n\nHDNode.prototype.sign = function (hash) {\n  return this.keyPair.sign(hash)\n}\n\nHDNode.prototype.verify = function (hash, signature) {\n  return this.keyPair.verify(hash, signature)\n}\n\nHDNode.prototype.toBase58 = function (__isPrivate) {\n  if (__isPrivate !== undefined) throw new TypeError('Unsupported argument in 2.0.0')\n\n  // Version\n  var network = this.keyPair.network\n  var version = (!this.isNeutered()) ? network.bip32.private : network.bip32.public\n  var buffer = Buffer.allocUnsafe(78)\n\n  // 4 bytes: version bytes\n  buffer.writeUInt32BE(version, 0)\n\n  // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....\n  buffer.writeUInt8(this.depth, 4)\n\n  // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n  buffer.writeUInt32BE(this.parentFingerprint, 5)\n\n  // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n  // This is encoded in big endian. (0x00000000 if master key)\n  buffer.writeUInt32BE(this.index, 9)\n\n  // 32 bytes: the chain code\n  this.chainCode.copy(buffer, 13)\n\n  // 33 bytes: the public key or private key data\n  if (!this.isNeutered()) {\n    // 0x00 + k for private keys\n    buffer.writeUInt8(0, 45)\n    this.keyPair.d.toBuffer(32).copy(buffer, 46)\n\n  // 33 bytes: the public key\n  } else {\n    // X9.62 encoding for public keys\n    this.keyPair.getPublicKeyBuffer().copy(buffer, 45)\n  }\n\n  return base58check.encode(buffer)\n}\n\n// https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions\nHDNode.prototype.derive = function (index) {\n  typeforce(types.UInt32, index)\n\n  var isHardened = index >= HDNode.HIGHEST_BIT\n  var data = Buffer.allocUnsafe(37)\n\n  // Hardened child\n  if (isHardened) {\n    if (this.isNeutered()) throw new TypeError('Could not derive hardened child key')\n\n    // data = 0x00 || ser256(kpar) || ser32(index)\n    data[0] = 0x00\n    this.keyPair.d.toBuffer(32).copy(data, 1)\n    data.writeUInt32BE(index, 33)\n\n  // Normal child\n  } else {\n    // data = serP(point(kpar)) || ser32(index)\n    //      = serP(Kpar) || ser32(index)\n    this.keyPair.getPublicKeyBuffer().copy(data, 0)\n    data.writeUInt32BE(index, 33)\n  }\n\n  var I = createHmac('sha512', this.chainCode).update(data).digest()\n  var IL = I.slice(0, 32)\n  var IR = I.slice(32)\n\n  var pIL = BigInteger.fromBuffer(IL)\n\n  // In case parse256(IL) >= n, proceed with the next value for i\n  if (pIL.compareTo(curve.n) >= 0) {\n    return this.derive(index + 1)\n  }\n\n  // Private parent key -> private child key\n  var derivedKeyPair\n  if (!this.isNeutered()) {\n    // ki = parse256(IL) + kpar (mod n)\n    var ki = pIL.add(this.keyPair.d).mod(curve.n)\n\n    // In case ki == 0, proceed with the next value for i\n    if (ki.signum() === 0) {\n      return this.derive(index + 1)\n    }\n\n    derivedKeyPair = new ECPair(ki, null, {\n      network: this.keyPair.network\n    })\n\n  // Public parent key -> public child key\n  } else {\n    // Ki = point(parse256(IL)) + Kpar\n    //    = G*IL + Kpar\n    var Ki = curve.G.multiply(pIL).add(this.keyPair.Q)\n\n    // In case Ki is the point at infinity, proceed with the next value for i\n    if (curve.isInfinity(Ki)) {\n      return this.derive(index + 1)\n    }\n\n    derivedKeyPair = new ECPair(null, Ki, {\n      network: this.keyPair.network\n    })\n  }\n\n  var hd = new HDNode(derivedKeyPair, IR)\n  hd.depth = this.depth + 1\n  hd.index = index\n  hd.parentFingerprint = this.getFingerprint().readUInt32BE(0)\n\n  return hd\n}\n\nHDNode.prototype.deriveHardened = function (index) {\n  typeforce(types.UInt31, index)\n\n  // Only derives hardened private keys by default\n  return this.derive(index + HDNode.HIGHEST_BIT)\n}\n\n// Private === not neutered\n// Public === neutered\nHDNode.prototype.isNeutered = function () {\n  return !(this.keyPair.d)\n}\n\nHDNode.prototype.derivePath = function (path) {\n  typeforce(types.BIP32Path, path)\n\n  var splitPath = path.split('/')\n  if (splitPath[0] === 'm') {\n    if (this.parentFingerprint) {\n      throw new Error('Not a master node')\n    }\n\n    splitPath = splitPath.slice(1)\n  }\n\n  return splitPath.reduce(function (prevHd, indexStr) {\n    var index\n    if (indexStr.slice(-1) === \"'\") {\n      index = parseInt(indexStr.slice(0, -1), 10)\n      return prevHd.deriveHardened(index)\n    } else {\n      index = parseInt(indexStr, 10)\n      return prevHd.derive(index)\n    }\n  }, this)\n}\n\nmodule.exports = HDNode\n"]},"metadata":{},"sourceType":"script"}