{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar providers = require('@ethersproject/providers');\n\nvar xchainClient = require('@xchainjs/xchain-client');\n\nvar xchainUtil = require('@xchainjs/xchain-util');\n\nvar ethers = require('ethers');\n\nvar utils = require('ethers/lib/utils');\n\nvar axios = require('axios');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar axios__default = /*#__PURE__*/_interopDefaultLegacy(axios);\n\n(function (EthNetwork) {\n  EthNetwork[\"Test\"] = \"ropsten\";\n  EthNetwork[\"Main\"] = \"homestead\";\n})(exports.EthNetwork || (exports.EthNetwork = {}));\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nfunction __generator(thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\n\nfunction __spreadArray(to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n}\n\nvar erc20ABI = [{\n  inputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"constructor\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"spender\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"value\",\n    type: \"uint256\"\n  }],\n  name: \"Approval\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"from\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"value\",\n    type: \"uint256\"\n  }],\n  name: \"Transfer\",\n  type: \"event\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  name: \"allowance\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"spender\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"value\",\n    type: \"uint256\"\n  }],\n  name: \"approve\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"success\",\n    type: \"bool\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  name: \"balanceOf\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"decimals\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"name\",\n  outputs: [{\n    internalType: \"string\",\n    name: \"\",\n    type: \"string\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"symbol\",\n  outputs: [{\n    internalType: \"string\",\n    name: \"\",\n    type: \"string\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"totalSupply\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"value\",\n    type: \"uint256\"\n  }],\n  name: \"transfer\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"success\",\n    type: \"bool\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"from\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"value\",\n    type: \"uint256\"\n  }],\n  name: \"transferFrom\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"success\",\n    type: \"bool\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}];\nvar ETH_DECIMAL = 18; // from https://github.com/MetaMask/metamask-extension/blob/ee205b893fe61dc4736efc576e0663189a9d23da/ui/app/pages/send/send.constants.js#L39\n// and based on recommendations of https://ethgasstation.info/blog/gas-limit/\n\nvar SIMPLE_GAS_COST = ethers.BigNumber.from(21000);\nvar BASE_TOKEN_GAS_COST = ethers.BigNumber.from(100000); // default gas price in gwei\n\nvar DEFAULT_GAS_PRICE = 50;\nvar ETHAddress = '0x0000000000000000000000000000000000000000';\nvar MAX_APPROVAL = ethers.BigNumber.from(2).pow(256).sub(1);\n/**\r\n * Network -> EthNetwork\r\n *\r\n * @param {Network} network\r\n * @returns {EthNetwork}\r\n */\n\nvar xchainNetworkToEths = function (network) {\n  switch (network) {\n    case xchainClient.Network.Mainnet:\n      return exports.EthNetwork.Main;\n\n    case xchainClient.Network.Testnet:\n      return exports.EthNetwork.Test;\n  }\n};\n/**\r\n * Validate the given address.\r\n *\r\n * @param {Address} address\r\n * @returns {boolean} `true` or `false`\r\n */\n\n\nvar validateAddress = function (address) {\n  try {\n    ethers.ethers.utils.getAddress(address);\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n/**\r\n * Get token address from asset.\r\n *\r\n * @param {Asset} asset\r\n * @returns {string|null} The token address.\r\n */\n\n\nvar getTokenAddress = function (asset) {\n  try {\n    // strip 0X only - 0x is still valid\n    return ethers.ethers.utils.getAddress(asset.symbol.slice(asset.ticker.length + 1).replace(/^0X/, ''));\n  } catch (err) {\n    return null;\n  }\n};\n/**\r\n * Check if the symbol is valid.\r\n *\r\n * @param {string|null|undefined} symbol\r\n * @returns {boolean} `true` or `false`.\r\n */\n\n\nvar validateSymbol = function (symbol) {\n  return symbol ? symbol.length >= 3 : false;\n};\n/**\r\n * Get transactions from token tx\r\n *\r\n * @param {TokenTransactionInfo} tx\r\n * @returns {Tx|null} The parsed transaction.\r\n */\n\n\nvar getTxFromTokenTransaction = function (tx) {\n  var decimals = parseInt(tx.tokenDecimal) || ETH_DECIMAL;\n  var symbol = tx.tokenSymbol;\n  var address = tx.contractAddress;\n\n  if (validateSymbol(symbol) && validateAddress(address)) {\n    var tokenAsset = xchainUtil.assetFromString(xchainUtil.Chain.Ethereum + \".\" + symbol + \"-\" + address);\n\n    if (tokenAsset) {\n      return {\n        asset: tokenAsset,\n        from: [{\n          from: tx.from,\n          amount: xchainUtil.baseAmount(tx.value, decimals)\n        }],\n        to: [{\n          to: tx.to,\n          amount: xchainUtil.baseAmount(tx.value, decimals)\n        }],\n        date: new Date(parseInt(tx.timeStamp) * 1000),\n        type: xchainClient.TxType.Transfer,\n        hash: tx.hash\n      };\n    }\n  }\n\n  return null;\n};\n/**\r\n * Get transactions from ETH transaction\r\n *\r\n * @param {ETHTransactionInfo} tx\r\n * @returns {Tx} The parsed transaction.\r\n */\n\n\nvar getTxFromEthTransaction = function (tx) {\n  return {\n    asset: xchainUtil.AssetETH,\n    from: [{\n      from: tx.from,\n      amount: xchainUtil.baseAmount(tx.value, ETH_DECIMAL)\n    }],\n    to: [{\n      to: tx.to,\n      amount: xchainUtil.baseAmount(tx.value, ETH_DECIMAL)\n    }],\n    date: new Date(parseInt(tx.timeStamp) * 1000),\n    type: xchainClient.TxType.Transfer,\n    hash: tx.hash\n  };\n};\n/**\r\n * Get transactions from operation\r\n *\r\n * @param {TransactionOperation} operation\r\n * @returns {Tx|null} The parsed transaction.\r\n */\n\n\nvar getTxFromEthplorerTokenOperation = function (operation) {\n  var decimals = parseInt(operation.tokenInfo.decimals) || ETH_DECIMAL;\n  var _a = operation.tokenInfo,\n      symbol = _a.symbol,\n      address = _a.address;\n\n  if (validateSymbol(symbol) && validateAddress(address)) {\n    var tokenAsset = xchainUtil.assetFromString(xchainUtil.Chain.Ethereum + \".\" + symbol + \"-\" + address);\n\n    if (tokenAsset) {\n      return {\n        asset: tokenAsset,\n        from: [{\n          from: operation.from,\n          amount: xchainUtil.baseAmount(operation.value, decimals)\n        }],\n        to: [{\n          to: operation.to,\n          amount: xchainUtil.baseAmount(operation.value, decimals)\n        }],\n        date: new Date(operation.timestamp * 1000),\n        type: operation.type === 'transfer' ? xchainClient.TxType.Transfer : xchainClient.TxType.Unknown,\n        hash: operation.transactionHash\n      };\n    }\n  }\n\n  return null;\n};\n/**\r\n * Get transactions from ETH transaction\r\n *\r\n * @param {TransactionInfo} txInfo\r\n * @returns {Tx} The parsed transaction.\r\n */\n\n\nvar getTxFromEthplorerEthTransaction = function (txInfo) {\n  return {\n    asset: xchainUtil.AssetETH,\n    from: [{\n      from: txInfo.from,\n      amount: xchainUtil.assetToBase(xchainUtil.assetAmount(txInfo.value, ETH_DECIMAL))\n    }],\n    to: [{\n      to: txInfo.to,\n      amount: xchainUtil.assetToBase(xchainUtil.assetAmount(txInfo.value, ETH_DECIMAL))\n    }],\n    date: new Date(txInfo.timestamp * 1000),\n    type: xchainClient.TxType.Transfer,\n    hash: txInfo.hash\n  };\n};\n/**\r\n * Calculate fees by multiplying .\r\n *\r\n * @returns {Fees} The default gas price.\r\n */\n\n\nvar getFee = function (_a) {\n  var gasPrice = _a.gasPrice,\n      gasLimit = _a.gasLimit;\n  return xchainUtil.baseAmount(gasPrice.amount().multipliedBy(gasLimit.toString()), ETH_DECIMAL);\n};\n\nvar estimateDefaultFeesWithGasPricesAndLimits = function (asset) {\n  var gasPrices = {\n    average: xchainUtil.baseAmount(utils.parseUnits(DEFAULT_GAS_PRICE.toString(), 'gwei').toString(), ETH_DECIMAL),\n    fast: xchainUtil.baseAmount(utils.parseUnits((DEFAULT_GAS_PRICE * 2).toString(), 'gwei').toString(), ETH_DECIMAL),\n    fastest: xchainUtil.baseAmount(utils.parseUnits((DEFAULT_GAS_PRICE * 3).toString(), 'gwei').toString(), ETH_DECIMAL)\n  };\n  var fastGP = gasPrices.fast,\n      fastestGP = gasPrices.fastest,\n      averageGP = gasPrices.average;\n  var assetAddress;\n\n  if (asset && xchainUtil.assetToString(asset) !== xchainUtil.assetToString(xchainUtil.AssetETH)) {\n    assetAddress = getTokenAddress(asset);\n  }\n\n  var gasLimit;\n\n  if (assetAddress && assetAddress !== ETHAddress) {\n    gasLimit = ethers.BigNumber.from(BASE_TOKEN_GAS_COST);\n  } else {\n    gasLimit = ethers.BigNumber.from(SIMPLE_GAS_COST);\n  }\n\n  return {\n    gasPrices: gasPrices,\n    gasLimit: gasLimit,\n    fees: {\n      type: xchainClient.FeeType.PerByte,\n      average: getFee({\n        gasPrice: averageGP,\n        gasLimit: gasLimit\n      }),\n      fast: getFee({\n        gasPrice: fastGP,\n        gasLimit: gasLimit\n      }),\n      fastest: getFee({\n        gasPrice: fastestGP,\n        gasLimit: gasLimit\n      })\n    }\n  };\n};\n/**\r\n * Get the default fees.\r\n *\r\n * @returns {Fees} The default gas price.\r\n */\n\n\nvar getDefaultFees = function (asset) {\n  var fees = estimateDefaultFeesWithGasPricesAndLimits(asset).fees;\n  return fees;\n};\n/**\r\n * Get the default gas price.\r\n *\r\n * @returns {Fees} The default gas prices.\r\n */\n\n\nvar getDefaultGasPrices = function (asset) {\n  var gasPrices = estimateDefaultFeesWithGasPricesAndLimits(asset).gasPrices;\n  return gasPrices;\n};\n/**\r\n * Get address prefix based on the network.\r\n *\r\n * @returns {string} The address prefix based on the network.\r\n *\r\n **/\n\n\nvar getPrefix = function () {\n  return '0x';\n};\n/**\r\n * Filter self txs\r\n *\r\n * @returns {T[]}\r\n *\r\n **/\n\n\nvar filterSelfTxs = function (txs) {\n  var filterTxs = txs.filter(function (tx) {\n    return tx.from !== tx.to;\n  });\n  var selfTxs = txs.filter(function (tx) {\n    return tx.from === tx.to;\n  });\n\n  var _loop_1 = function () {\n    var selfTx = selfTxs[0];\n    filterTxs.push(selfTx);\n    selfTxs = selfTxs.filter(function (tx) {\n      return tx.hash !== selfTx.hash;\n    });\n  };\n\n  while (selfTxs.length) {\n    _loop_1();\n  }\n\n  return filterTxs;\n};\n/**\r\n * Get Decimals\r\n *\r\n * @param {Asset} asset\r\n * @returns {Number} the decimal of a given asset\r\n *\r\n * @throws {\"Invalid asset\"} Thrown if the given asset is invalid\r\n */\n\n\nvar getDecimal = function (asset, provider) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var assetAddress, contract, decimal;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          if (xchainUtil.assetToString(asset) === xchainUtil.assetToString(xchainUtil.AssetETH)) return [2\n          /*return*/\n          , ETH_DECIMAL];\n          assetAddress = getTokenAddress(asset);\n          if (!assetAddress) throw new Error(\"Invalid asset \" + xchainUtil.assetToString(asset));\n          contract = new ethers.ethers.Contract(assetAddress, erc20ABI, provider);\n          return [4\n          /*yield*/\n          , contract.decimals()];\n\n        case 1:\n          decimal = _a.sent();\n          return [2\n          /*return*/\n          , ethers.ethers.BigNumber.from(decimal).toNumber()];\n      }\n    });\n  });\n};\n/**\r\n * Get Token Balances\r\n *\r\n * @param {TokenBalance[]} tokenBalances\r\n * @returns {Balance[]} the parsed balances\r\n *\r\n */\n\n\nvar getTokenBalances = function (tokenBalances) {\n  return tokenBalances.reduce(function (acc, cur) {\n    var _a;\n\n    var _b = cur.tokenInfo,\n        symbol = _b.symbol,\n        tokenAddress = _b.address;\n\n    if (validateSymbol(symbol) && validateAddress(tokenAddress) && ((_a = cur === null || cur === void 0 ? void 0 : cur.tokenInfo) === null || _a === void 0 ? void 0 : _a.decimals) !== undefined) {\n      var decimals = parseInt(cur.tokenInfo.decimals, 10);\n      var tokenAsset = xchainUtil.assetFromString(xchainUtil.Chain.Ethereum + \".\" + symbol + \"-\" + ethers.ethers.utils.getAddress(tokenAddress));\n\n      if (tokenAsset) {\n        return __spreadArray(__spreadArray([], acc), [{\n          asset: tokenAsset,\n          amount: xchainUtil.baseAmount(cur.balance, decimals)\n        }]);\n      }\n    }\n\n    return acc;\n  }, []);\n};\n\nvar getApiKeyQueryParameter = function (apiKey) {\n  return !!apiKey ? \"&apiKey=\" + apiKey : '';\n};\n/**\r\n * SafeGasPrice, ProposeGasPrice And FastGasPrice returned in string-Gwei\r\n *\r\n * @see https://etherscan.io/apis#gastracker\r\n *\r\n * @param {string} baseUrl The etherscan node url.\r\n * @param {string} apiKey The etherscan API key. (optional)\r\n * @returns {GasOracleResponse} LastBlock, SafeGasPrice, ProposeGasPrice, FastGasPrice\r\n */\n\n\nvar getGasOracle = function (baseUrl, apiKey) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var url;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          url = baseUrl + '/api?module=gastracker&action=gasoracle';\n          return [4\n          /*yield*/\n          , axios__default['default'].get(url + getApiKeyQueryParameter(apiKey))];\n\n        case 1:\n          return [2\n          /*return*/\n          , _a.sent().data.result];\n      }\n    });\n  });\n};\n/**\r\n * Get token balance\r\n *\r\n * @see https://etherscan.io/apis#tokens\r\n *\r\n * @param {string} baseUrl The etherscan node url.\r\n * @param {string} address The address.\r\n * @param {string} assetAddress The token contract address.\r\n * @param {string} apiKey The etherscan API key. (optional)\r\n * @returns {BigNumberish} The token balance\r\n */\n\n\nvar getTokenBalance = function (_a) {\n  var baseUrl = _a.baseUrl,\n      address = _a.address,\n      assetAddress = _a.assetAddress,\n      apiKey = _a.apiKey;\n  return __awaiter(void 0, void 0, void 0, function () {\n    var url;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          url = baseUrl + (\"/api?module=account&action=tokenbalance&contractaddress=\" + assetAddress + \"&address=\" + address);\n          return [4\n          /*yield*/\n          , axios__default['default'].get(url + getApiKeyQueryParameter(apiKey))];\n\n        case 1:\n          return [2\n          /*return*/\n          , _b.sent().data.result];\n      }\n    });\n  });\n};\n/**\r\n * Get ETH transaction history\r\n *\r\n * @see https://etherscan.io/apis#accounts\r\n *\r\n * @param {string} baseUrl The etherscan node url.\r\n * @param {string} address The address.\r\n * @param {TransactionHistoryParam} params The search options.\r\n * @param {string} apiKey The etherscan API key. (optional)\r\n * @returns {ETHTransactionInfo[]} The ETH transaction history\r\n */\n\n\nvar getETHTransactionHistory = function (_a) {\n  var baseUrl = _a.baseUrl,\n      address = _a.address,\n      page = _a.page,\n      offset = _a.offset,\n      startblock = _a.startblock,\n      endblock = _a.endblock,\n      apiKey = _a.apiKey;\n  return __awaiter(void 0, void 0, void 0, function () {\n    var url, result;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          url = baseUrl + \"/api?module=account&action=txlist&sort=desc\" + getApiKeyQueryParameter(apiKey);\n          if (address) url += \"&address=\" + address;\n          if (offset) url += \"&offset=\" + offset;\n          if (page) url += \"&page=\" + page;\n          if (startblock) url += \"&startblock=\" + startblock;\n          if (endblock) url += \"&endblock=\" + endblock;\n          return [4\n          /*yield*/\n          , axios__default['default'].get(url)];\n\n        case 1:\n          result = _b.sent().data.result;\n          if (JSON.stringify(result).includes('Invalid API Key')) throw new Error('Invalid API Key');\n          if (typeof result !== 'object') throw new Error(result);\n          return [2\n          /*return*/\n          , filterSelfTxs(result).filter(function (tx) {\n            return !xchainUtil.bnOrZero(tx.value).isZero();\n          }).map(getTxFromEthTransaction)];\n      }\n    });\n  });\n};\n/**\r\n * Get token transaction history\r\n *\r\n * @see https://etherscan.io/apis#accounts\r\n *\r\n * @param {string} baseUrl The etherscan node url.\r\n * @param {string} address The address.\r\n * @param {TransactionHistoryParam} params The search options.\r\n * @param {string} apiKey The etherscan API key. (optional)\r\n * @returns {Tx[]} The token transaction history\r\n */\n\n\nvar getTokenTransactionHistory = function (_a) {\n  var baseUrl = _a.baseUrl,\n      address = _a.address,\n      assetAddress = _a.assetAddress,\n      page = _a.page,\n      offset = _a.offset,\n      startblock = _a.startblock,\n      endblock = _a.endblock,\n      apiKey = _a.apiKey;\n  return __awaiter(void 0, void 0, void 0, function () {\n    var url, result;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          url = baseUrl + \"/api?module=account&action=tokentx&sort=desc\" + getApiKeyQueryParameter(apiKey);\n          if (address) url += \"&address=\" + address;\n          if (assetAddress) url += \"&contractaddress=\" + assetAddress;\n          if (offset) url += \"&offset=\" + offset;\n          if (page) url += \"&page=\" + page;\n          if (startblock) url += \"&startblock=\" + startblock;\n          if (endblock) url += \"&endblock=\" + endblock;\n          return [4\n          /*yield*/\n          , axios__default['default'].get(url)];\n\n        case 1:\n          result = _b.sent().data.result;\n          if (JSON.stringify(result).includes('Invalid API Key')) throw new Error('Invalid API Key');\n          return [2\n          /*return*/\n          , filterSelfTxs(result).filter(function (tx) {\n            return !xchainUtil.bnOrZero(tx.value).isZero();\n          }).reduce(function (acc, cur) {\n            var tx = getTxFromTokenTransaction(cur);\n            return tx ? __spreadArray(__spreadArray([], acc), [tx]) : acc;\n          }, [])];\n      }\n    });\n  });\n};\n/**\r\n * Get address information.\r\n *\r\n * @see https://github.com/EverexIO/Ethplorer/wiki/Ethplorer-API#get-address-info\r\n *\r\n * @param {string} baseUrl The ethplorer api url.\r\n * @param {string} address\r\n * @param {string} apiKey The ethplorer API key. (optional)\r\n * @returns {AddressInfo} The address information.\r\n */\n\n\nvar getAddress = function (baseUrl, address, apiKey) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var response;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , axios__default['default'].get(baseUrl + \"/getAddressInfo/\" + address, {\n            params: {\n              apiKey: apiKey || 'freekey'\n            }\n          })];\n\n        case 1:\n          response = _a.sent();\n          return [2\n          /*return*/\n          , response.data];\n      }\n    });\n  });\n};\n/**\r\n * Get transaction by hash.\r\n *\r\n * @see https://github.com/EverexIO/Ethplorer/wiki/Ethplorer-API#get-transaction-info\r\n *\r\n * @param {string} baseUrl The ethplorer api url.\r\n * @param {string} hash The transaction hash.\r\n * @param {string} apiKey The ethplorer API key. (optional)\r\n * @returns {Transactions} The transaction result.\r\n */\n\n\nvar getTxInfo = function (baseUrl, hash, apiKey) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var response;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , axios__default['default'].get(baseUrl + \"/getTxInfo/\" + hash, {\n            params: {\n              apiKey: apiKey || 'freekey'\n            }\n          })];\n\n        case 1:\n          response = _a.sent();\n          return [2\n          /*return*/\n          , response.data];\n      }\n    });\n  });\n};\n/**\r\n * Custom Ethereum client\r\n */\n\n\nvar Client =\n/** @class */\nfunction (_super) {\n  __extends(Client, _super);\n  /**\r\n   * Constructor\r\n   * @param {EthereumClientParams} params\r\n   */\n\n\n  function Client(_a) {\n    var _b;\n\n    var _c = _a.network,\n        network = _c === void 0 ? xchainClient.Network.Testnet : _c,\n        _d = _a.ethplorerUrl,\n        ethplorerUrl = _d === void 0 ? 'https://api.ethplorer.io' : _d,\n        _e = _a.ethplorerApiKey,\n        ethplorerApiKey = _e === void 0 ? 'freekey' : _e,\n        explorerUrl = _a.explorerUrl,\n        _f = _a.phrase,\n        phrase = _f === void 0 ? '' : _f,\n        _g = _a.rootDerivationPaths,\n        rootDerivationPaths = _g === void 0 ? (_b = {}, _b[xchainClient.Network.Mainnet] = \"m/44'/60'/0'/0/\", _b[xchainClient.Network.Testnet] = \"m/44'/60'/0'/0/\", _b) : _g,\n        etherscanApiKey = _a.etherscanApiKey,\n        infuraCreds = _a.infuraCreds;\n\n    var _this = _super.call(this, xchainUtil.Chain.Ethereum, {\n      network: network,\n      rootDerivationPaths: rootDerivationPaths\n    }) || this;\n\n    _this.providers = new Map();\n    _this.ethNetwork = xchainNetworkToEths(network);\n    _this.rootDerivationPaths = rootDerivationPaths;\n    _this.infuraCreds = infuraCreds;\n    _this.etherscanApiKey = etherscanApiKey;\n    _this.ethplorerUrl = ethplorerUrl;\n    _this.ethplorerApiKey = ethplorerApiKey;\n    _this.explorerUrl = explorerUrl || _this.getDefaultExplorerURL();\n\n    _this.setupProviders();\n\n    _this.setPhrase(phrase);\n\n    return _this;\n  }\n  /**\r\n   * Purge client.\r\n   *\r\n   * @returns {void}\r\n   */\n\n\n  Client.prototype.purgeClient = function () {\n    _super.prototype.purgeClient.call(this);\n\n    this.hdNode = utils.HDNode.fromMnemonic('');\n  };\n  /**\r\n   * Set/Update the explorer url.\r\n   *\r\n   * @param {string} url The explorer url.\r\n   * @returns {void}\r\n   */\n\n\n  Client.prototype.setExplorerURL = function (url) {\n    this.explorerUrl = url;\n  };\n  /**\r\n   * Get the current address.\r\n   *\r\n   * @param {number} walletIndex (optional) HD wallet index\r\n   * @returns {Address} The current address.\r\n   *\r\n   * @throws {\"Phrase must be provided\"}\r\n   * Thrown if phrase has not been set before. A phrase is needed to create a wallet and to derive an address from it.\r\n   */\n\n\n  Client.prototype.getAddress = function (walletIndex) {\n    if (walletIndex === void 0) {\n      walletIndex = 0;\n    }\n\n    if (walletIndex < 0) {\n      throw new Error('index must be greater than zero');\n    }\n\n    return this.hdNode.derivePath(this.getFullDerivationPath(walletIndex)).address.toLowerCase();\n  };\n  /**\r\n   * Get etherjs wallet interface.\r\n   *\r\n   * @param {number} walletIndex (optional) HD wallet index\r\n   * @returns {Wallet} The current etherjs wallet interface.\r\n   *\r\n   * @throws {\"Phrase must be provided\"}\r\n   * Thrown if phrase has not been set before. A phrase is needed to create a wallet and to derive an address from it.\r\n   */\n\n\n  Client.prototype.getWallet = function (walletIndex) {\n    if (walletIndex === void 0) {\n      walletIndex = 0;\n    }\n\n    return new ethers.Wallet(this.hdNode.derivePath(this.getFullDerivationPath(walletIndex))).connect(this.getProvider());\n  };\n\n  Client.prototype.setupProviders = function () {\n    if (this.infuraCreds) {\n      // Infura provider takes either a string of project id\n      // or an object of id and secret\n      var testnetProvider = this.infuraCreds.projectSecret ? new ethers.ethers.providers.InfuraProvider(exports.EthNetwork.Test, this.infuraCreds) : new ethers.ethers.providers.InfuraProvider(exports.EthNetwork.Test, this.infuraCreds.projectId);\n      var mainnetProvider = this.infuraCreds.projectSecret ? new ethers.ethers.providers.InfuraProvider(exports.EthNetwork.Main, this.infuraCreds) : new ethers.ethers.providers.InfuraProvider(exports.EthNetwork.Main, this.infuraCreds.projectId);\n      this.providers.set(xchainClient.Network.Testnet, testnetProvider);\n      this.providers.set(xchainClient.Network.Mainnet, mainnetProvider);\n    } else {\n      this.providers.set(xchainClient.Network.Testnet, providers.getDefaultProvider(exports.EthNetwork.Test));\n      this.providers.set(xchainClient.Network.Mainnet, providers.getDefaultProvider(exports.EthNetwork.Main));\n    }\n  };\n  /**\r\n   * Get etherjs Provider interface.\r\n   *\r\n   * @returns {Provider} The current etherjs Provider interface.\r\n   */\n\n\n  Client.prototype.getProvider = function () {\n    return this.providers.get(this.network) || providers.getDefaultProvider(this.network);\n  };\n  /**\r\n   * Get etherjs EtherscanProvider interface.\r\n   *\r\n   * @returns {EtherscanProvider} The current etherjs EtherscanProvider interface.\r\n   */\n\n\n  Client.prototype.getEtherscanProvider = function () {\n    return new providers.EtherscanProvider(this.ethNetwork, this.etherscanApiKey);\n  };\n  /**\r\n   * Get the explorer url.\r\n   *\r\n   * @returns {string} The explorer url for ethereum based on the current network.\r\n   */\n\n\n  Client.prototype.getExplorerUrl = function () {\n    return this.getExplorerUrlByNetwork(this.getNetwork());\n  };\n  /**\r\n   * Get the explorer url.\r\n   *\r\n   * @returns {ExplorerUrl} The explorer url (both mainnet and testnet) for ethereum.\r\n   */\n\n\n  Client.prototype.getDefaultExplorerURL = function () {\n    var _a;\n\n    return _a = {}, _a[xchainClient.Network.Testnet] = 'https://ropsten.etherscan.io', _a[xchainClient.Network.Mainnet] = 'https://etherscan.io', _a;\n  };\n  /**\r\n   * Get the explorer url.\r\n   *\r\n   * @param {Network} network\r\n   * @returns {string} The explorer url for ethereum based on the network.\r\n   */\n\n\n  Client.prototype.getExplorerUrlByNetwork = function (network) {\n    return this.explorerUrl[network];\n  };\n  /**\r\n   * Get the explorer url for the given address.\r\n   *\r\n   * @param {Address} address\r\n   * @returns {string} The explorer url for the given address.\r\n   */\n\n\n  Client.prototype.getExplorerAddressUrl = function (address) {\n    return this.getExplorerUrl() + \"/address/\" + address;\n  };\n  /**\r\n   * Get the explorer url for the given transaction id.\r\n   *\r\n   * @param {string} txID\r\n   * @returns {string} The explorer url for the given transaction id.\r\n   */\n\n\n  Client.prototype.getExplorerTxUrl = function (txID) {\n    return this.getExplorerUrl() + \"/tx/\" + txID;\n  };\n  /**\r\n   * Set/update the current network.\r\n   *\r\n   * @param {Network} network\r\n   * @returns {void}\r\n   *\r\n   * @throws {\"Network must be provided\"}\r\n   * Thrown if network has not been set before.\r\n   */\n\n\n  Client.prototype.setNetwork = function (network) {\n    _super.prototype.setNetwork.call(this, network);\n\n    this.ethNetwork = xchainNetworkToEths(network);\n  };\n  /**\r\n   * Set/update a new phrase (Eg. If user wants to change wallet)\r\n   *\r\n   * @param {string} phrase A new phrase.\r\n   * @param {number} walletIndex (optional) HD wallet index\r\n   * @returns {Address} The address from the given phrase\r\n   *\r\n   * @throws {\"Invalid phrase\"}\r\n   * Thrown if the given phase is invalid.\r\n   */\n\n\n  Client.prototype.setPhrase = function (phrase, walletIndex) {\n    if (walletIndex === void 0) {\n      walletIndex = 0;\n    }\n\n    this.hdNode = utils.HDNode.fromMnemonic(phrase);\n    return _super.prototype.setPhrase.call(this, phrase, walletIndex);\n  };\n  /**\r\n   * Validate the given address.\r\n   *\r\n   * @param {Address} address\r\n   * @returns {boolean} `true` or `false`\r\n   */\n\n\n  Client.prototype.validateAddress = function (address) {\n    return validateAddress(address);\n  };\n  /**\r\n   * Get the ETH balance of a given address.\r\n   *\r\n   * @param {Address} address By default, it will return the balance of the current wallet. (optional)\r\n   * @returns {Balance[]} The all balance of the address.\r\n   *\r\n   * @throws {\"Invalid asset\"} throws when the give asset is an invalid one\r\n   */\n\n\n  Client.prototype.getBalance = function (address, assets) {\n    return __awaiter(this, void 0, void 0, function () {\n      var ethAddress, ethBalance, ethBalanceAmount, _a, account, balances, newAssets, balances, i, asset, etherscan, assetAddress, balance, decimals, _b, _c;\n\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            ethAddress = address || this.getAddress();\n            return [4\n            /*yield*/\n            , this.getProvider().getBalance(ethAddress)];\n\n          case 1:\n            ethBalance = _d.sent();\n            ethBalanceAmount = xchainUtil.baseAmount(ethBalance.toString(), ETH_DECIMAL);\n            _a = this.getNetwork();\n\n            switch (_a) {\n              case xchainClient.Network.Mainnet:\n                return [3\n                /*break*/\n                , 2];\n\n              case xchainClient.Network.Testnet:\n                return [3\n                /*break*/\n                , 4];\n            }\n\n            return [3\n            /*break*/\n            , 13];\n\n          case 2:\n            return [4\n            /*yield*/\n            , getAddress(this.ethplorerUrl, address, this.ethplorerApiKey)];\n\n          case 3:\n            account = _d.sent();\n            balances = [{\n              asset: xchainUtil.AssetETH,\n              amount: ethBalanceAmount\n            }];\n\n            if (account.tokens) {\n              balances.push.apply(balances, getTokenBalances(account.tokens));\n            }\n\n            return [2\n            /*return*/\n            , balances];\n\n          case 4:\n            newAssets = assets || [xchainUtil.AssetETH];\n            balances = [];\n            i = 0;\n            _d.label = 5;\n\n          case 5:\n            if (!(i < newAssets.length)) return [3\n            /*break*/\n            , 12];\n            asset = newAssets[i];\n            etherscan = this.getEtherscanProvider();\n            if (!(xchainUtil.assetToString(asset) !== xchainUtil.assetToString(xchainUtil.AssetETH))) return [3\n            /*break*/\n            , 8];\n            assetAddress = getTokenAddress(asset);\n\n            if (!assetAddress) {\n              throw new Error(\"Invalid asset \" + asset);\n            }\n\n            return [4\n            /*yield*/\n            , getTokenBalance({\n              baseUrl: etherscan.baseUrl,\n              address: address,\n              assetAddress: assetAddress,\n              apiKey: etherscan.apiKey\n            })];\n\n          case 6:\n            balance = _d.sent();\n            _c = (_b = ethers.BigNumber).from;\n            return [4\n            /*yield*/\n            , this.call({\n              contractAddress: assetAddress,\n              abi: erc20ABI,\n              funcName: 'decimals'\n            })];\n\n          case 7:\n            decimals = _c.apply(_b, [_d.sent()]).toNumber() || ETH_DECIMAL;\n\n            if (!Number.isNaN(decimals)) {\n              balances.push({\n                asset: asset,\n                amount: xchainUtil.baseAmount(balance.toString(), decimals)\n              });\n            }\n\n            return [3\n            /*break*/\n            , 9];\n\n          case 8:\n            balances.push({\n              asset: xchainUtil.AssetETH,\n              amount: ethBalanceAmount\n            });\n            _d.label = 9;\n\n          case 9:\n            // Due to etherscan api call limitation, put some delay before another call\n            // Free Etherscan api key limit: 5 calls per second\n            // So 0.3s delay is reasonable for now\n            return [4\n            /*yield*/\n            , xchainUtil.delay(300)];\n\n          case 10:\n            // Due to etherscan api call limitation, put some delay before another call\n            // Free Etherscan api key limit: 5 calls per second\n            // So 0.3s delay is reasonable for now\n            _d.sent();\n\n            _d.label = 11;\n\n          case 11:\n            i++;\n            return [3\n            /*break*/\n            , 5];\n\n          case 12:\n            return [2\n            /*return*/\n            , balances];\n\n          case 13:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Get transaction history of a given address with pagination options.\r\n   * By default it will return the transaction history of the current wallet.\r\n   *\r\n   * @param {TxHistoryParams} params The options to get transaction history. (optional)\r\n   * @returns {TxsPage} The transaction history.\r\n   */\n\n\n  Client.prototype.getTransactions = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var offset, limit, assetAddress, maxCount, transations, etherscan;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            offset = (params === null || params === void 0 ? void 0 : params.offset) || 0;\n            limit = (params === null || params === void 0 ? void 0 : params.limit) || 10;\n            assetAddress = params === null || params === void 0 ? void 0 : params.asset;\n            maxCount = 10000;\n            etherscan = this.getEtherscanProvider();\n            if (!assetAddress) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , getTokenTransactionHistory({\n              baseUrl: etherscan.baseUrl,\n              address: params === null || params === void 0 ? void 0 : params.address,\n              assetAddress: assetAddress,\n              page: 0,\n              offset: maxCount,\n              apiKey: etherscan.apiKey\n            })];\n\n          case 1:\n            transations = _a.sent();\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            return [4\n            /*yield*/\n            , getETHTransactionHistory({\n              baseUrl: etherscan.baseUrl,\n              address: params === null || params === void 0 ? void 0 : params.address,\n              page: 0,\n              offset: maxCount,\n              apiKey: etherscan.apiKey\n            })];\n\n          case 3:\n            transations = _a.sent();\n            _a.label = 4;\n\n          case 4:\n            return [2\n            /*return*/\n            , {\n              total: transations.length,\n              txs: transations.filter(function (_, index) {\n                return index >= offset && index < offset + limit;\n              })\n            }];\n        }\n      });\n    });\n  };\n  /**\r\n   * Get the transaction details of a given transaction id.\r\n   *\r\n   * @param {string} txId The transaction id.\r\n   * @param {string} assetAddress The asset address. (optional)\r\n   * @returns {Tx} The transaction details of the given transaction id.\r\n   *\r\n   * @throws {\"Need to provide valid txId\"}\r\n   * Thrown if the given txId is invalid.\r\n   */\n\n\n  Client.prototype.getTransactionData = function (txId, assetAddress) {\n    var _a, _b, _c;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var _d, txInfo, tx, tx, etherscan, txInfo;\n\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            _d = this.getNetwork();\n\n            switch (_d) {\n              case xchainClient.Network.Mainnet:\n                return [3\n                /*break*/\n                , 1];\n\n              case xchainClient.Network.Testnet:\n                return [3\n                /*break*/\n                , 3];\n            }\n\n            return [3\n            /*break*/\n            , 9];\n\n          case 1:\n            return [4\n            /*yield*/\n            , getTxInfo(this.ethplorerUrl, txId, this.ethplorerApiKey)];\n\n          case 2:\n            txInfo = _e.sent();\n            if (!((_a = txInfo.operations) === null || _a === void 0 ? void 0 : _a.length)) return [2\n            /*return*/\n            , getTxFromEthplorerEthTransaction(txInfo)];\n            tx = getTxFromEthplorerTokenOperation(txInfo.operations[0]);\n            if (!tx) throw new Error('Could not parse transaction data');\n            return [2\n            /*return*/\n            , tx];\n\n          case 3:\n            tx = void 0;\n            etherscan = this.getEtherscanProvider();\n            return [4\n            /*yield*/\n            , etherscan.getTransaction(txId)];\n\n          case 4:\n            txInfo = _e.sent();\n            if (!txInfo) return [3\n            /*break*/\n            , 8];\n            if (!assetAddress) return [3\n            /*break*/\n            , 6];\n            return [4\n            /*yield*/\n            , getTokenTransactionHistory({\n              baseUrl: etherscan.baseUrl,\n              assetAddress: assetAddress,\n              startblock: txInfo.blockNumber,\n              endblock: txInfo.blockNumber,\n              apiKey: etherscan.apiKey\n            })];\n\n          case 5:\n            tx = (_b = _e.sent().filter(function (info) {\n              return info.hash === txId;\n            })[0]) !== null && _b !== void 0 ? _b : null;\n            return [3\n            /*break*/\n            , 8];\n\n          case 6:\n            return [4\n            /*yield*/\n            , getETHTransactionHistory({\n              baseUrl: etherscan.baseUrl,\n              startblock: txInfo.blockNumber,\n              endblock: txInfo.blockNumber,\n              apiKey: etherscan.apiKey,\n              address: txInfo.from\n            })];\n\n          case 7:\n            tx = (_c = _e.sent().filter(function (info) {\n              return info.hash === txId;\n            })[0]) !== null && _c !== void 0 ? _c : null;\n            _e.label = 8;\n\n          case 8:\n            if (!tx) throw new Error('Could not get transaction history');\n            return [2\n            /*return*/\n            , tx];\n\n          case 9:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Call a contract function.\r\n   * @template T The result interface.\r\n   * @param {number} walletIndex (optional) HD wallet index\r\n   * @param {Address} contractAddress The contract address.\r\n   * @param {ContractInterface} abi The contract ABI json.\r\n   * @param {string} funcName The function to be called.\r\n   * @param {any[]} funcParams The parameters of the function.\r\n   * @returns {T} The result of the contract function call.\r\n   *\r\n   * @throws {\"contractAddress must be provided\"}\r\n   * Thrown if the given contract address is empty.\r\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  Client.prototype.call = function (_a) {\n    var _b = _a.walletIndex,\n        walletIndex = _b === void 0 ? 0 : _b,\n        contractAddress = _a.contractAddress,\n        abi = _a.abi,\n        funcName = _a.funcName,\n        _c = _a.funcParams,\n        funcParams = _c === void 0 ? [] : _c;\n    return __awaiter(this, void 0, void 0, function () {\n      var contract;\n      return __generator(this, function (_d) {\n        if (!contractAddress) throw new Error('contractAddress must be provided');\n        contract = new ethers.ethers.Contract(contractAddress, abi, this.getProvider()).connect(this.getWallet(walletIndex));\n        return [2\n        /*return*/\n        , contract[funcName].apply(contract, funcParams)];\n      });\n    });\n  };\n  /**\r\n   * Call a contract function.\r\n   * @param {Address} contractAddress The contract address.\r\n   * @param {ContractInterface} abi The contract ABI json.\r\n   * @param {string} funcName The function to be called.\r\n   * @param {any[]} funcParams The parameters of the function.\r\n   * @param {number} walletIndex (optional) HD wallet index\r\n   * @returns {BigNumber} The result of the contract function call.\r\n   *\r\n   * @throws {\"contractAddress must be provided\"}\r\n   * Thrown if the given contract address is empty.\r\n   */\n\n\n  Client.prototype.estimateCall = function (_a) {\n    var contractAddress = _a.contractAddress,\n        abi = _a.abi,\n        funcName = _a.funcName,\n        _b = _a.funcParams,\n        funcParams = _b === void 0 ? [] : _b,\n        _c = _a.walletIndex,\n        walletIndex = _c === void 0 ? 0 : _c;\n    return __awaiter(this, void 0, void 0, function () {\n      var contract;\n\n      var _d;\n\n      return __generator(this, function (_e) {\n        if (!contractAddress) throw new Error('contractAddress must be provided');\n        contract = new ethers.ethers.Contract(contractAddress, abi, this.getProvider()).connect(this.getWallet(walletIndex));\n        return [2\n        /*return*/\n        , (_d = contract.estimateGas)[funcName].apply(_d, funcParams)];\n      });\n    });\n  };\n  /**\r\n   * Check allowance.\r\n   *\r\n   * @param {Address} contractAddress The spender address.\r\n   * @param {Address} spenderAddress The spender address.\r\n   * @param {BaseAmount} amount The amount to check if it's allowed to spend or not (optional).\r\n   * @param {number} walletIndex (optional) HD wallet index\r\n   * @returns {boolean} `true` or `false`.\r\n   */\n\n\n  Client.prototype.isApproved = function (_a) {\n    var _b;\n\n    var contractAddress = _a.contractAddress,\n        spenderAddress = _a.spenderAddress,\n        amount = _a.amount,\n        _c = _a.walletIndex,\n        walletIndex = _c === void 0 ? 0 : _c;\n    return __awaiter(this, void 0, void 0, function () {\n      var txAmount, owner, allowance;\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            txAmount = ethers.BigNumber.from((_b = amount === null || amount === void 0 ? void 0 : amount.amount().toFixed()) !== null && _b !== void 0 ? _b : 1);\n            owner = this.getAddress(walletIndex);\n            return [4\n            /*yield*/\n            , this.call({\n              contractAddress: contractAddress,\n              abi: erc20ABI,\n              funcName: 'allowance',\n              funcParams: [owner, spenderAddress]\n            })];\n\n          case 1:\n            allowance = _d.sent();\n            return [2\n            /*return*/\n            , txAmount.lte(allowance)];\n        }\n      });\n    });\n  };\n  /**\r\n   * Check allowance.\r\n   *\r\n   * @param {Address} contractAddress The contract address.\r\n   * @param {Address} spenderAddress The spender address.\r\n   * @param {feeOptionKey} FeeOption Fee option (optional)\r\n   * @param {BaseAmount} amount The amount of token. By default, it will be unlimited token allowance. (optional)\r\n   * @param {number} walletIndex (optional) HD wallet index\r\n   *\r\n   * @returns {TransactionResponse} The transaction result.\r\n   */\n\n\n  Client.prototype.approve = function (_a) {\n    var contractAddress = _a.contractAddress,\n        spenderAddress = _a.spenderAddress,\n        _b = _a.feeOptionKey,\n        feeOption = _b === void 0 ? xchainClient.FeeOption.Fastest : _b,\n        amount = _a.amount,\n        _c = _a.walletIndex,\n        walletIndex = _c === void 0 ? 0 : _c,\n        gasLimitFallback = _a.gasLimitFallback;\n    return __awaiter(this, void 0, void 0, function () {\n      var gasPrice, _d, _e, gasLimit, txAmount;\n\n      return __generator(this, function (_f) {\n        switch (_f.label) {\n          case 0:\n            _e = (_d = ethers.BigNumber).from;\n            return [4\n            /*yield*/\n            , this.estimateGasPrices().then(function (prices) {\n              return prices[feeOption];\n            }).catch(function () {\n              return getDefaultGasPrices()[feeOption];\n            })];\n\n          case 1:\n            gasPrice = _e.apply(_d, [_f.sent().amount().toFixed()]);\n            return [4\n            /*yield*/\n            , this.estimateApprove({\n              walletIndex: walletIndex,\n              spenderAddress: spenderAddress,\n              contractAddress: contractAddress,\n              amount: amount\n            }).catch(function () {\n              return ethers.BigNumber.from(gasLimitFallback);\n            })];\n\n          case 2:\n            gasLimit = _f.sent();\n            txAmount = amount ? ethers.BigNumber.from(amount.amount().toFixed()) : MAX_APPROVAL;\n            return [4\n            /*yield*/\n            , this.call({\n              walletIndex: walletIndex,\n              contractAddress: contractAddress,\n              abi: erc20ABI,\n              funcName: 'approve',\n              funcParams: [spenderAddress, txAmount, {\n                from: this.getAddress(walletIndex),\n                gasPrice: gasPrice,\n                gasLimit: gasLimit\n              }]\n            })];\n\n          case 3:\n            return [2\n            /*return*/\n            , _f.sent()];\n        }\n      });\n    });\n  };\n  /**\r\n   * Estimate gas limit of approve.\r\n   *\r\n   * @param {Address} contractAddress The contract address.\r\n   * @param {Address} spenderAddress The spender address.\r\n   * @param {number} walletIndex (optional) HD wallet index\r\n   * @param {BaseAmount} amount The amount of token. By default, it will be unlimited token allowance. (optional)\r\n   * @returns {BigNumber} The estimated gas limit.\r\n   */\n\n\n  Client.prototype.estimateApprove = function (_a) {\n    var contractAddress = _a.contractAddress,\n        spenderAddress = _a.spenderAddress,\n        _b = _a.walletIndex,\n        walletIndex = _b === void 0 ? 0 : _b,\n        amount = _a.amount;\n    return __awaiter(this, void 0, void 0, function () {\n      var txAmount, gasLimit;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            txAmount = amount ? ethers.BigNumber.from(amount.amount().toFixed()) : MAX_APPROVAL;\n            return [4\n            /*yield*/\n            , this.estimateCall({\n              walletIndex: walletIndex,\n              contractAddress: contractAddress,\n              abi: erc20ABI,\n              funcName: 'approve',\n              funcParams: [spenderAddress, txAmount, {\n                from: this.getAddress(walletIndex)\n              }]\n            })];\n\n          case 1:\n            gasLimit = _c.sent();\n            return [2\n            /*return*/\n            , gasLimit];\n        }\n      });\n    });\n  };\n  /**\r\n   * Transfer ETH.\r\n   *\r\n   * @param {TxParams} params The transfer options.\r\n   * @param {feeOptionKey} FeeOption Fee option (optional)\r\n   * @param {gasPrice} BaseAmount Gas price (optional)\r\n   * @param {gasLimit} BigNumber Gas limit (optional)\r\n   *\r\n   * A given `feeOptionKey` wins over `gasPrice` and `gasLimit`\r\n   *\r\n   * @returns {TxHash} The transaction hash.\r\n   */\n\n\n  Client.prototype.transfer = function (_a) {\n    var _b = _a.walletIndex,\n        walletIndex = _b === void 0 ? 0 : _b,\n        asset = _a.asset,\n        memo = _a.memo,\n        amount = _a.amount,\n        recipient = _a.recipient,\n        feeOption = _a.feeOptionKey,\n        gasPrice = _a.gasPrice,\n        gasLimit = _a.gasLimit;\n    return __awaiter(this, void 0, void 0, function () {\n      var txAmount, assetAddress, isETHAddress, defaultGasLimit, overrides, gasPrice_1, gasLimit_1, txResult, transactionRequest;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            txAmount = ethers.BigNumber.from(amount.amount().toFixed());\n\n            if (asset && xchainUtil.assetToString(asset) !== xchainUtil.assetToString(xchainUtil.AssetETH)) {\n              assetAddress = getTokenAddress(asset);\n            }\n\n            isETHAddress = assetAddress === ETHAddress;\n            defaultGasLimit = isETHAddress ? SIMPLE_GAS_COST : BASE_TOKEN_GAS_COST;\n            overrides = {\n              gasLimit: gasLimit || defaultGasLimit,\n              gasPrice: gasPrice && ethers.BigNumber.from(gasPrice.amount().toFixed())\n            };\n            if (!feeOption) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , this.estimateGasPrices().then(function (prices) {\n              return prices[feeOption];\n            }).catch(function () {\n              return getDefaultGasPrices()[feeOption];\n            })];\n\n          case 1:\n            gasPrice_1 = _c.sent();\n            return [4\n            /*yield*/\n            , this.estimateGasLimit({\n              asset: asset,\n              recipient: recipient,\n              amount: amount,\n              memo: memo\n            }).catch(function () {\n              return defaultGasLimit;\n            })];\n\n          case 2:\n            gasLimit_1 = _c.sent();\n            overrides = {\n              gasLimit: gasLimit_1,\n              gasPrice: ethers.BigNumber.from(gasPrice_1.amount().toFixed())\n            };\n            _c.label = 3;\n\n          case 3:\n            if (!(assetAddress && !isETHAddress)) return [3\n            /*break*/\n            , 5];\n            return [4\n            /*yield*/\n            , this.call({\n              walletIndex: walletIndex,\n              contractAddress: assetAddress,\n              abi: erc20ABI,\n              funcName: 'transfer',\n              funcParams: [recipient, txAmount, Object.assign({}, overrides)]\n            })];\n\n          case 4:\n            // Transfer ERC20\n            txResult = _c.sent();\n            return [3\n            /*break*/\n            , 7];\n\n          case 5:\n            transactionRequest = Object.assign({\n              to: recipient,\n              value: txAmount\n            }, __assign(__assign({}, overrides), {\n              data: memo ? utils.toUtf8Bytes(memo) : undefined\n            }));\n            return [4\n            /*yield*/\n            , this.getWallet().sendTransaction(transactionRequest)];\n\n          case 6:\n            txResult = _c.sent();\n            _c.label = 7;\n\n          case 7:\n            return [2\n            /*return*/\n            , txResult.hash];\n        }\n      });\n    });\n  };\n  /**\r\n   * Estimate gas price.\r\n   * @see https://etherscan.io/apis#gastracker\r\n   *\r\n   * @returns {GasPrices} The gas prices (average, fast, fastest) in `Wei` (`BaseAmount`)\r\n   */\n\n\n  Client.prototype.estimateGasPrices = function () {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var ratesInGwei, _b, error_1, error_2;\n\n      var _c;\n\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            _d.trys.push([0, 2,, 3]);\n\n            _b = xchainClient.standardFeeRates;\n            return [4\n            /*yield*/\n            , this.getFeeRateFromThorchain()];\n\n          case 1:\n            ratesInGwei = _b.apply(void 0, [_d.sent()]);\n            return [2\n            /*return*/\n            , (_c = {}, _c[xchainClient.FeeOption.Average] = xchainUtil.baseAmount(ratesInGwei[xchainClient.FeeOption.Average] * Math.pow(10, 9), ETH_DECIMAL), _c[xchainClient.FeeOption.Fast] = xchainUtil.baseAmount(ratesInGwei[xchainClient.FeeOption.Fast] * Math.pow(10, 9), ETH_DECIMAL), _c[xchainClient.FeeOption.Fastest] = xchainUtil.baseAmount(ratesInGwei[xchainClient.FeeOption.Fastest] * Math.pow(10, 9), ETH_DECIMAL), _c)];\n\n          case 2:\n            error_1 = _d.sent();\n            return [3\n            /*break*/\n            , 3];\n\n          case 3:\n            _d.trys.push([3, 5,, 6]);\n\n            return [4\n            /*yield*/\n            , this.estimateGasPricesFromEtherscan()];\n\n          case 4:\n            return [2\n            /*return*/\n            , _d.sent()];\n\n          case 5:\n            error_2 = _d.sent();\n            return [2\n            /*return*/\n            , Promise.reject(new Error(\"Failed to estimate gas price: \" + ((_a = error_2.msg) !== null && _a !== void 0 ? _a : error_2.toString())))];\n\n          case 6:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Estimate gas price.\r\n   * @see https://etherscan.io/apis#gastracker\r\n   *\r\n   * @returns {GasPrices} The gas prices (average, fast, fastest) in `Wei` (`BaseAmount`)\r\n   *\r\n   * @throws {\"Failed to estimate gas price\"} Thrown if failed to estimate gas price.\r\n   */\n\n\n  Client.prototype.estimateGasPricesFromEtherscan = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var etherscan, response, averageWei, fastWei, fastestWei;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            etherscan = this.getEtherscanProvider();\n            return [4\n            /*yield*/\n            , getGasOracle(etherscan.baseUrl, etherscan.apiKey) // Convert result of gas prices: `Gwei` -> `Wei`\n            ];\n\n          case 1:\n            response = _a.sent();\n            averageWei = utils.parseUnits(response.SafeGasPrice, 'gwei');\n            fastWei = utils.parseUnits(response.ProposeGasPrice, 'gwei');\n            fastestWei = utils.parseUnits(response.FastGasPrice, 'gwei');\n            return [2\n            /*return*/\n            , {\n              average: xchainUtil.baseAmount(averageWei.toString(), ETH_DECIMAL),\n              fast: xchainUtil.baseAmount(fastWei.toString(), ETH_DECIMAL),\n              fastest: xchainUtil.baseAmount(fastestWei.toString(), ETH_DECIMAL)\n            }];\n        }\n      });\n    });\n  };\n  /**\r\n   * Estimate gas.\r\n   *\r\n   * @param {TxParams} params The transaction and fees options.\r\n   * @returns {BaseAmount} The estimated gas fee.\r\n   */\n\n\n  Client.prototype.estimateGasLimit = function (_a) {\n    var asset = _a.asset,\n        recipient = _a.recipient,\n        amount = _a.amount,\n        memo = _a.memo;\n    return __awaiter(this, void 0, void 0, function () {\n      var txAmount, assetAddress, estimate, contract, transactionRequest;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            txAmount = ethers.BigNumber.from(amount.amount().toFixed());\n\n            if (asset && xchainUtil.assetToString(asset) !== xchainUtil.assetToString(xchainUtil.AssetETH)) {\n              assetAddress = getTokenAddress(asset);\n            }\n\n            if (!(assetAddress && assetAddress !== ETHAddress)) return [3\n            /*break*/\n            , 2];\n            contract = new ethers.ethers.Contract(assetAddress, erc20ABI, this.getProvider());\n            return [4\n            /*yield*/\n            , contract.estimateGas.transfer(recipient, txAmount, {\n              from: this.getAddress()\n            })];\n\n          case 1:\n            estimate = _b.sent();\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            transactionRequest = {\n              from: this.getAddress(),\n              to: recipient,\n              value: txAmount,\n              data: memo ? utils.toUtf8Bytes(memo) : undefined\n            };\n            return [4\n            /*yield*/\n            , this.getProvider().estimateGas(transactionRequest)];\n\n          case 3:\n            estimate = _b.sent();\n            _b.label = 4;\n\n          case 4:\n            return [2\n            /*return*/\n            , estimate];\n        }\n      });\n    });\n  };\n  /**\r\n   * Estimate gas prices/limits (average, fast fastest).\r\n   *\r\n   * @param {TxParams} params\r\n   * @returns {FeesWithGasPricesAndLimits} The estimated gas prices/limits.\r\n   */\n\n\n  Client.prototype.estimateFeesWithGasPricesAndLimits = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var gasPrices, fastGP, fastestGP, averageGP, gasLimit;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.estimateGasPrices()];\n\n          case 1:\n            gasPrices = _a.sent();\n            fastGP = gasPrices.fast, fastestGP = gasPrices.fastest, averageGP = gasPrices.average;\n            return [4\n            /*yield*/\n            , this.estimateGasLimit({\n              asset: params.asset,\n              amount: params.amount,\n              recipient: params.recipient,\n              memo: params.memo\n            })];\n\n          case 2:\n            gasLimit = _a.sent();\n            return [2\n            /*return*/\n            , {\n              gasPrices: gasPrices,\n              fees: {\n                type: xchainClient.FeeType.PerByte,\n                average: getFee({\n                  gasPrice: averageGP,\n                  gasLimit: gasLimit\n                }),\n                fast: getFee({\n                  gasPrice: fastGP,\n                  gasLimit: gasLimit\n                }),\n                fastest: getFee({\n                  gasPrice: fastestGP,\n                  gasLimit: gasLimit\n                })\n              },\n              gasLimit: gasLimit\n            }];\n        }\n      });\n    });\n  };\n\n  Client.prototype.getFees = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var fees;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!params) throw new Error('Params need to be passed');\n            return [4\n            /*yield*/\n            , this.estimateFeesWithGasPricesAndLimits(params)];\n\n          case 1:\n            fees = _a.sent().fees;\n            return [2\n            /*return*/\n            , fees];\n        }\n      });\n    });\n  };\n\n  return Client;\n}(xchainClient.BaseXChainClient);\n\nexports.Client = Client;\nexports.ETHAddress = ETHAddress;\nexports.ETH_DECIMAL = ETH_DECIMAL;\nexports.estimateDefaultFeesWithGasPricesAndLimits = estimateDefaultFeesWithGasPricesAndLimits;\nexports.getDecimal = getDecimal;\nexports.getDefaultFees = getDefaultFees;\nexports.getFee = getFee;\nexports.getPrefix = getPrefix;\nexports.getTokenAddress = getTokenAddress;\nexports.validateAddress = validateAddress;","map":{"version":3,"sources":["../src/types/client-types.ts","../../../node_modules/tslib/tslib.es6.js","../src/utils.ts","../src/etherscan-api.ts","../src/ethplorer-api.ts","../src/client.ts"],"names":["EthNetwork","BigNumber","Network","ethers","assetFromString","Chain","baseAmount","TxType","AssetETH","assetToBase","assetAmount","parseUnits","assetToString","FeeType","axios","bnOrZero","BaseXChainClient","HDNode","Wallet","getDefaultProvider","EtherscanProvider","ethplorerAPI.getAddress","etherscanAPI.getTokenBalance","delay","etherscanAPI.getTokenTransactionHistory","etherscanAPI.getETHTransactionHistory","ethplorerAPI.getTxInfo","FeeOption","toUtf8Bytes","etherscanAPI.getGasOracle"],"mappings":"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","sourcesContent":["import { FeeOption, Fees, Network } from '@xchainjs/xchain-client'\nimport { BaseAmount } from '@xchainjs/xchain-util'\nimport { BigNumber, ethers } from 'ethers'\n\nexport type Address = string\n\nexport enum EthNetwork {\n  Test = 'ropsten',\n  Main = 'homestead',\n}\n\nexport type ClientUrl = Record<Network, string>\nexport type ExplorerUrl = Record<Network, string>\n\nexport type TxOverrides = {\n  nonce?: ethers.BigNumberish\n\n  // mandatory: https://github.com/ethers-io/ethers.js/issues/469#issuecomment-475926538\n  gasLimit: ethers.BigNumberish\n  gasPrice?: ethers.BigNumberish\n  data?: ethers.BytesLike\n  value?: ethers.BigNumberish\n}\n\nexport type InfuraCreds = {\n  projectId: string\n  projectSecret?: string\n}\n\nexport type GasPrices = Record<FeeOption, BaseAmount>\n\nexport type FeesWithGasPricesAndLimits = { fees: Fees; gasPrices: GasPrices; gasLimit: BigNumber }\n\nexport type ApproveParams = {\n  walletIndex?: number\n  contractAddress: Address\n  spenderAddress: Address\n  feeOptionKey?: FeeOption\n  amount?: BaseAmount\n  // Optional fallback in case estimation for gas limit fails\n  gasLimitFallback?: ethers.BigNumberish\n}\n\nexport type EstimateApproveParams = Omit<ApproveParams, 'feeOptionKey' | 'gasLimitFallback'>\n\nexport type IsApprovedParams = {\n  walletIndex?: number\n  contractAddress: Address\n  spenderAddress: Address\n  amount?: BaseAmount\n}\n\nexport type CallParams = {\n  walletIndex?: number\n  contractAddress: Address\n  abi: ethers.ContractInterface\n  funcName: string\n  funcParams?: unknown[]\n}\n\nexport type EstimateCallParams = Pick<CallParams, 'contractAddress' | 'abi' | 'funcName' | 'funcParams' | 'walletIndex'>\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { Balance, FeeType, Fees, Network, Tx, TxType } from '@xchainjs/xchain-client'\nimport {\n  Asset,\n  AssetETH,\n  BaseAmount,\n  Chain,\n  assetAmount,\n  assetFromString,\n  assetToBase,\n  assetToString,\n  baseAmount,\n} from '@xchainjs/xchain-util'\nimport { BigNumber, ethers, providers } from 'ethers'\nimport { parseUnits } from 'ethers/lib/utils'\n\nimport erc20ABI from './data/erc20.json'\nimport {\n  Address,\n  ETHTransactionInfo,\n  EthNetwork,\n  FeesWithGasPricesAndLimits,\n  GasPrices,\n  TokenBalance,\n  TokenTransactionInfo,\n  TransactionInfo,\n  TransactionOperation,\n} from './types'\n\nexport const ETH_DECIMAL = 18\nexport const ETHPLORER_FREEKEY = 'freekey'\n\n// from https://github.com/MetaMask/metamask-extension/blob/ee205b893fe61dc4736efc576e0663189a9d23da/ui/app/pages/send/send.constants.js#L39\n// and based on recommendations of https://ethgasstation.info/blog/gas-limit/\nexport const SIMPLE_GAS_COST: ethers.BigNumber = BigNumber.from(21000)\nexport const BASE_TOKEN_GAS_COST: ethers.BigNumber = BigNumber.from(100000)\n\n// default gas price in gwei\nexport const DEFAULT_GAS_PRICE = 50\n\nexport const ETHAddress = '0x0000000000000000000000000000000000000000'\nexport const MAX_APPROVAL = BigNumber.from(2).pow(256).sub(1)\n\n/**\n * Network -> EthNetwork\n *\n * @param {Network} network\n * @returns {EthNetwork}\n */\nexport const xchainNetworkToEths = (network: Network): EthNetwork => {\n  switch (network) {\n    case Network.Mainnet:\n      return EthNetwork.Main\n    case Network.Testnet:\n      return EthNetwork.Test\n  }\n}\n\n/**\n * EthNetwork -> Network\n *\n * @param {EthNetwork} network\n * @returns {Network}\n */\nexport const ethNetworkToXchains = (network: EthNetwork): Network => {\n  switch (network) {\n    case EthNetwork.Main:\n      return Network.Mainnet\n    case EthNetwork.Test:\n      return Network.Testnet\n  }\n}\n\n/**\n * Validate the given address.\n *\n * @param {Address} address\n * @returns {boolean} `true` or `false`\n */\nexport const validateAddress = (address: Address): boolean => {\n  try {\n    ethers.utils.getAddress(address)\n    return true\n  } catch (error) {\n    return false\n  }\n}\n\n/**\n * Get token address from asset.\n *\n * @param {Asset} asset\n * @returns {string|null} The token address.\n */\nexport const getTokenAddress = (asset: Asset): string | null => {\n  try {\n    // strip 0X only - 0x is still valid\n    return ethers.utils.getAddress(asset.symbol.slice(asset.ticker.length + 1).replace(/^0X/, ''))\n  } catch (err) {\n    return null\n  }\n}\n\n/**\n * Check if the symbol is valid.\n *\n * @param {string|null|undefined} symbol\n * @returns {boolean} `true` or `false`.\n */\nexport const validateSymbol = (symbol?: string | null): boolean => (symbol ? symbol.length >= 3 : false)\n\n/**\n * Get transactions from token tx\n *\n * @param {TokenTransactionInfo} tx\n * @returns {Tx|null} The parsed transaction.\n */\nexport const getTxFromTokenTransaction = (tx: TokenTransactionInfo): Tx | null => {\n  const decimals = parseInt(tx.tokenDecimal) || ETH_DECIMAL\n  const symbol = tx.tokenSymbol\n  const address = tx.contractAddress\n  if (validateSymbol(symbol) && validateAddress(address)) {\n    const tokenAsset = assetFromString(`${Chain.Ethereum}.${symbol}-${address}`)\n    if (tokenAsset) {\n      return {\n        asset: tokenAsset,\n        from: [\n          {\n            from: tx.from,\n            amount: baseAmount(tx.value, decimals),\n          },\n        ],\n        to: [\n          {\n            to: tx.to,\n            amount: baseAmount(tx.value, decimals),\n          },\n        ],\n        date: new Date(parseInt(tx.timeStamp) * 1000),\n        type: TxType.Transfer,\n        hash: tx.hash,\n      }\n    }\n  }\n\n  return null\n}\n\n/**\n * Get transactions from ETH transaction\n *\n * @param {ETHTransactionInfo} tx\n * @returns {Tx} The parsed transaction.\n */\nexport const getTxFromEthTransaction = (tx: ETHTransactionInfo): Tx => {\n  return {\n    asset: AssetETH,\n    from: [\n      {\n        from: tx.from,\n        amount: baseAmount(tx.value, ETH_DECIMAL),\n      },\n    ],\n    to: [\n      {\n        to: tx.to,\n        amount: baseAmount(tx.value, ETH_DECIMAL),\n      },\n    ],\n    date: new Date(parseInt(tx.timeStamp) * 1000),\n    type: TxType.Transfer,\n    hash: tx.hash,\n  }\n}\n\n/**\n * Get transactions from operation\n *\n * @param {TransactionOperation} operation\n * @returns {Tx|null} The parsed transaction.\n */\nexport const getTxFromEthplorerTokenOperation = (operation: TransactionOperation): Tx | null => {\n  const decimals = parseInt(operation.tokenInfo.decimals) || ETH_DECIMAL\n  const { symbol, address } = operation.tokenInfo\n  if (validateSymbol(symbol) && validateAddress(address)) {\n    const tokenAsset = assetFromString(`${Chain.Ethereum}.${symbol}-${address}`)\n    if (tokenAsset) {\n      return {\n        asset: tokenAsset,\n        from: [\n          {\n            from: operation.from,\n            amount: baseAmount(operation.value, decimals),\n          },\n        ],\n        to: [\n          {\n            to: operation.to,\n            amount: baseAmount(operation.value, decimals),\n          },\n        ],\n        date: new Date(operation.timestamp * 1000),\n        type: operation.type === 'transfer' ? TxType.Transfer : TxType.Unknown,\n        hash: operation.transactionHash,\n      }\n    }\n  }\n\n  return null\n}\n\n/**\n * Get transactions from ETH transaction\n *\n * @param {TransactionInfo} txInfo\n * @returns {Tx} The parsed transaction.\n */\nexport const getTxFromEthplorerEthTransaction = (txInfo: TransactionInfo): Tx => {\n  return {\n    asset: AssetETH,\n    from: [\n      {\n        from: txInfo.from,\n        amount: assetToBase(assetAmount(txInfo.value, ETH_DECIMAL)),\n      },\n    ],\n    to: [\n      {\n        to: txInfo.to,\n        amount: assetToBase(assetAmount(txInfo.value, ETH_DECIMAL)),\n      },\n    ],\n    date: new Date(txInfo.timestamp * 1000),\n    type: TxType.Transfer,\n    hash: txInfo.hash,\n  }\n}\n\n/**\n * Calculate fees by multiplying .\n *\n * @returns {Fees} The default gas price.\n */\nexport const getFee = ({ gasPrice, gasLimit }: { gasPrice: BaseAmount; gasLimit: BigNumber }) =>\n  baseAmount(gasPrice.amount().multipliedBy(gasLimit.toString()), ETH_DECIMAL)\n\nexport const estimateDefaultFeesWithGasPricesAndLimits = (asset?: Asset): FeesWithGasPricesAndLimits => {\n  const gasPrices = {\n    average: baseAmount(parseUnits(DEFAULT_GAS_PRICE.toString(), 'gwei').toString(), ETH_DECIMAL),\n    fast: baseAmount(parseUnits((DEFAULT_GAS_PRICE * 2).toString(), 'gwei').toString(), ETH_DECIMAL),\n    fastest: baseAmount(parseUnits((DEFAULT_GAS_PRICE * 3).toString(), 'gwei').toString(), ETH_DECIMAL),\n  }\n  const { fast: fastGP, fastest: fastestGP, average: averageGP } = gasPrices\n\n  let assetAddress\n  if (asset && assetToString(asset) !== assetToString(AssetETH)) {\n    assetAddress = getTokenAddress(asset)\n  }\n\n  let gasLimit\n  if (assetAddress && assetAddress !== ETHAddress) {\n    gasLimit = BigNumber.from(BASE_TOKEN_GAS_COST)\n  } else {\n    gasLimit = BigNumber.from(SIMPLE_GAS_COST)\n  }\n\n  return {\n    gasPrices,\n    gasLimit,\n    fees: {\n      type: FeeType.PerByte,\n      average: getFee({ gasPrice: averageGP, gasLimit }),\n      fast: getFee({ gasPrice: fastGP, gasLimit }),\n      fastest: getFee({ gasPrice: fastestGP, gasLimit }),\n    },\n  }\n}\n\n/**\n * Get the default fees.\n *\n * @returns {Fees} The default gas price.\n */\nexport const getDefaultFees = (asset?: Asset): Fees => {\n  const { fees } = estimateDefaultFeesWithGasPricesAndLimits(asset)\n  return fees\n}\n\n/**\n * Get the default gas price.\n *\n * @returns {Fees} The default gas prices.\n */\nexport const getDefaultGasPrices = (asset?: Asset): GasPrices => {\n  const { gasPrices } = estimateDefaultFeesWithGasPricesAndLimits(asset)\n  return gasPrices\n}\n\n/**\n * Get address prefix based on the network.\n *\n * @returns {string} The address prefix based on the network.\n *\n **/\nexport const getPrefix = () => '0x'\n\n/**\n * Filter self txs\n *\n * @returns {T[]}\n *\n **/\nexport const filterSelfTxs = <T extends { from: string; to: string; hash: string }>(txs: T[]): T[] => {\n  const filterTxs = txs.filter((tx) => tx.from !== tx.to)\n  let selfTxs = txs.filter((tx) => tx.from === tx.to)\n  while (selfTxs.length) {\n    const selfTx = selfTxs[0]\n    filterTxs.push(selfTx)\n    selfTxs = selfTxs.filter((tx) => tx.hash !== selfTx.hash)\n  }\n\n  return filterTxs\n}\n\n/**\n * Get Decimals\n *\n * @param {Asset} asset\n * @returns {Number} the decimal of a given asset\n *\n * @throws {\"Invalid asset\"} Thrown if the given asset is invalid\n */\nexport const getDecimal = async (asset: Asset, provider: providers.Provider): Promise<number> => {\n  if (assetToString(asset) === assetToString(AssetETH)) return ETH_DECIMAL\n\n  const assetAddress = getTokenAddress(asset)\n  if (!assetAddress) throw new Error(`Invalid asset ${assetToString(asset)}`)\n\n  const contract: ethers.Contract = new ethers.Contract(assetAddress, erc20ABI, provider)\n  const decimal: ethers.BigNumberish = await contract.decimals()\n\n  return ethers.BigNumber.from(decimal).toNumber()\n}\n\n/**\n * Get Token Balances\n *\n * @param {TokenBalance[]} tokenBalances\n * @returns {Balance[]} the parsed balances\n *\n */\nexport const getTokenBalances = (tokenBalances: TokenBalance[]): Balance[] => {\n  return tokenBalances.reduce((acc, cur) => {\n    const { symbol, address: tokenAddress } = cur.tokenInfo\n    if (validateSymbol(symbol) && validateAddress(tokenAddress) && cur?.tokenInfo?.decimals !== undefined) {\n      const decimals = parseInt(cur.tokenInfo.decimals, 10)\n      const tokenAsset = assetFromString(`${Chain.Ethereum}.${symbol}-${ethers.utils.getAddress(tokenAddress)}`)\n      if (tokenAsset) {\n        return [\n          ...acc,\n          {\n            asset: tokenAsset,\n            amount: baseAmount(cur.balance, decimals),\n          },\n        ]\n      }\n    }\n\n    return acc\n  }, [] as Balance[])\n}\n","import { Tx } from '@xchainjs/xchain-client'\nimport { bnOrZero } from '@xchainjs/xchain-util'\nimport axios from 'axios'\nimport { BigNumberish } from 'ethers'\n\nimport {\n  ETHTransactionInfo,\n  GasOracleResponse,\n  TokenBalanceParam,\n  TokenTransactionInfo,\n  TransactionHistoryParam,\n} from './types'\nimport { filterSelfTxs, getTxFromEthTransaction, getTxFromTokenTransaction } from './utils'\n\nconst getApiKeyQueryParameter = (apiKey?: string): string => (!!apiKey ? `&apiKey=${apiKey}` : '')\n\n/**\n * SafeGasPrice, ProposeGasPrice And FastGasPrice returned in string-Gwei\n *\n * @see https://etherscan.io/apis#gastracker\n *\n * @param {string} baseUrl The etherscan node url.\n * @param {string} apiKey The etherscan API key. (optional)\n * @returns {GasOracleResponse} LastBlock, SafeGasPrice, ProposeGasPrice, FastGasPrice\n */\nexport const getGasOracle = async (baseUrl: string, apiKey?: string): Promise<GasOracleResponse> => {\n  const url = baseUrl + '/api?module=gastracker&action=gasoracle'\n\n  return (await axios.get(url + getApiKeyQueryParameter(apiKey))).data.result\n}\n\n/**\n * Get token balance\n *\n * @see https://etherscan.io/apis#tokens\n *\n * @param {string} baseUrl The etherscan node url.\n * @param {string} address The address.\n * @param {string} assetAddress The token contract address.\n * @param {string} apiKey The etherscan API key. (optional)\n * @returns {BigNumberish} The token balance\n */\nexport const getTokenBalance = async ({\n  baseUrl,\n  address,\n  assetAddress,\n  apiKey,\n}: TokenBalanceParam & { baseUrl: string; apiKey?: string }): Promise<BigNumberish> => {\n  const url = baseUrl + `/api?module=account&action=tokenbalance&contractaddress=${assetAddress}&address=${address}`\n\n  return (await axios.get(url + getApiKeyQueryParameter(apiKey))).data.result\n}\n\n/**\n * Get ETH transaction history\n *\n * @see https://etherscan.io/apis#accounts\n *\n * @param {string} baseUrl The etherscan node url.\n * @param {string} address The address.\n * @param {TransactionHistoryParam} params The search options.\n * @param {string} apiKey The etherscan API key. (optional)\n * @returns {ETHTransactionInfo[]} The ETH transaction history\n */\nexport const getETHTransactionHistory = async ({\n  baseUrl,\n  address,\n  page,\n  offset,\n  startblock,\n  endblock,\n  apiKey,\n}: TransactionHistoryParam & { baseUrl: string; apiKey?: string }): Promise<Tx[]> => {\n  let url = baseUrl + `/api?module=account&action=txlist&sort=desc` + getApiKeyQueryParameter(apiKey)\n  if (address) url += `&address=${address}`\n  if (offset) url += `&offset=${offset}`\n  if (page) url += `&page=${page}`\n  if (startblock) url += `&startblock=${startblock}`\n  if (endblock) url += `&endblock=${endblock}`\n\n  const result = (await axios.get(url)).data.result\n  if (JSON.stringify(result).includes('Invalid API Key')) throw new Error('Invalid API Key')\n  if (typeof result !== 'object') throw new Error(result)\n\n  return filterSelfTxs<ETHTransactionInfo>(result)\n    .filter((tx) => !bnOrZero(tx.value).isZero())\n    .map(getTxFromEthTransaction)\n}\n\n/**\n * Get token transaction history\n *\n * @see https://etherscan.io/apis#accounts\n *\n * @param {string} baseUrl The etherscan node url.\n * @param {string} address The address.\n * @param {TransactionHistoryParam} params The search options.\n * @param {string} apiKey The etherscan API key. (optional)\n * @returns {Tx[]} The token transaction history\n */\nexport const getTokenTransactionHistory = async ({\n  baseUrl,\n  address,\n  assetAddress,\n  page,\n  offset,\n  startblock,\n  endblock,\n  apiKey,\n}: TransactionHistoryParam & { baseUrl: string; apiKey?: string }): Promise<Tx[]> => {\n  let url = baseUrl + `/api?module=account&action=tokentx&sort=desc` + getApiKeyQueryParameter(apiKey)\n  if (address) url += `&address=${address}`\n  if (assetAddress) url += `&contractaddress=${assetAddress}`\n  if (offset) url += `&offset=${offset}`\n  if (page) url += `&page=${page}`\n  if (startblock) url += `&startblock=${startblock}`\n  if (endblock) url += `&endblock=${endblock}`\n\n  const result = (await axios.get(url)).data.result\n  if (JSON.stringify(result).includes('Invalid API Key')) throw new Error('Invalid API Key')\n\n  return filterSelfTxs<TokenTransactionInfo>(result)\n    .filter((tx) => !bnOrZero(tx.value).isZero())\n    .reduce((acc, cur) => {\n      const tx = getTxFromTokenTransaction(cur)\n      return tx ? [...acc, tx] : acc\n    }, [] as Tx[])\n}\n","import { TxType } from '@xchainjs/xchain-client'\nimport axios from 'axios'\n\nimport { AddressInfo, TransactionInfo, TransactionOperation } from './types'\n\n/**\n * Get address information.\n *\n * @see https://github.com/EverexIO/Ethplorer/wiki/Ethplorer-API#get-address-info\n *\n * @param {string} baseUrl The ethplorer api url.\n * @param {string} address\n * @param {string} apiKey The ethplorer API key. (optional)\n * @returns {AddressInfo} The address information.\n */\nexport const getAddress = async (baseUrl: string, address: string, apiKey?: string): Promise<AddressInfo> => {\n  const response = await axios.get(`${baseUrl}/getAddressInfo/${address}`, {\n    params: {\n      apiKey: apiKey || 'freekey',\n    },\n  })\n  return response.data\n}\n\n/**\n * Get transaction by hash.\n *\n * @see https://github.com/EverexIO/Ethplorer/wiki/Ethplorer-API#get-transaction-info\n *\n * @param {string} baseUrl The ethplorer api url.\n * @param {string} hash The transaction hash.\n * @param {string} apiKey The ethplorer API key. (optional)\n * @returns {Transactions} The transaction result.\n */\nexport const getTxInfo = async (baseUrl: string, hash: string, apiKey?: string): Promise<TransactionInfo> => {\n  const response = await axios.get(`${baseUrl}/getTxInfo/${hash}`, {\n    params: {\n      apiKey: apiKey || 'freekey',\n    },\n  })\n  return response.data\n}\n\n/**\n * Get ETH transactions.\n *\n * @see https://github.com/EverexIO/Ethplorer/wiki/Ethplorer-API#get-address-transactions\n *\n * @param {string} baseUrl The ethplorer api url.\n * @param {string} address The transaction hash.\n * @param {number} limit The maximum number of transactions.\n * @param {number} timestamp The start timestamp.\n * @param {string} apiKey The ethplorer API key. (optional)\n * @returns {Transactions} The transaction result.\n */\nexport const getAddressTransactions = async (\n  baseUrl: string,\n  address: string,\n  limit?: number,\n  timestamp?: number,\n  apiKey?: string,\n): Promise<TransactionInfo[]> => {\n  const response = await axios.get(`${baseUrl}/getAddressTransactions/${address}`, {\n    params: {\n      apiKey: apiKey || 'freekey',\n      limit,\n      timestamp,\n    },\n  })\n  return response.data\n}\n\n/**\n * Get token transactions.\n *\n * @see https://github.com/EverexIO/Ethplorer/wiki/Ethplorer-API#get-last-address-operations\n *\n * @param {string} baseUrl The ethplorer api url.\n * @param {string} address The transaction hash.\n * @param {string} token The token address.\n * @param {number} limit The maximum number of transactions.\n * @param {number} timestamp The start timestamp.\n * @param {string} apiKey The ethplorer API key. (optional)\n * @returns {Transactions} The transaction result.\n */\nexport const getAddressHistory = async (\n  baseUrl: string,\n  address: string,\n  token: string,\n  limit?: number,\n  timestamp?: number,\n  apiKey?: string,\n): Promise<TransactionOperation[]> => {\n  const response = await axios.get(`${baseUrl}/getAddressHistory/${address}`, {\n    params: {\n      apiKey: apiKey || 'freekey',\n      token,\n      limit,\n      timestamp,\n      showZeroValues: true,\n      type: TxType.Transfer,\n    },\n  })\n  return response.data.operations\n}\n","import { Provider, TransactionResponse } from '@ethersproject/abstract-provider'\nimport { EtherscanProvider, getDefaultProvider } from '@ethersproject/providers'\nimport {\n  Address,\n  Balance,\n  BaseXChainClient,\n  FeeOption,\n  FeeType,\n  Fees,\n  Network,\n  Tx,\n  TxHash,\n  TxHistoryParams,\n  TxParams,\n  TxsPage,\n  XChainClient,\n  XChainClientParams,\n  standardFeeRates,\n} from '@xchainjs/xchain-client'\nimport { Asset, AssetETH, BaseAmount, Chain, assetToString, baseAmount, delay } from '@xchainjs/xchain-util'\nimport { BigNumber, BigNumberish, Wallet, ethers } from 'ethers'\nimport { HDNode, parseUnits, toUtf8Bytes } from 'ethers/lib/utils'\n\nimport erc20ABI from './data/erc20.json'\nimport * as etherscanAPI from './etherscan-api'\nimport * as ethplorerAPI from './ethplorer-api'\nimport {\n  ApproveParams,\n  CallParams,\n  EstimateApproveParams,\n  EstimateCallParams,\n  EthNetwork,\n  ExplorerUrl,\n  FeesWithGasPricesAndLimits,\n  GasOracleResponse,\n  GasPrices,\n  InfuraCreds,\n  IsApprovedParams,\n  TxOverrides,\n} from './types'\nimport {\n  BASE_TOKEN_GAS_COST,\n  ETHAddress,\n  ETH_DECIMAL,\n  MAX_APPROVAL,\n  SIMPLE_GAS_COST,\n  getDefaultGasPrices,\n  getFee,\n  getTokenAddress,\n  getTokenBalances,\n  getTxFromEthplorerEthTransaction,\n  getTxFromEthplorerTokenOperation,\n  validateAddress,\n  xchainNetworkToEths,\n} from './utils'\n\n/**\n * Interface for custom Ethereum client\n */\nexport interface EthereumClient {\n  call<T>(params: CallParams): Promise<T>\n  estimateCall(asset: EstimateCallParams): Promise<BigNumber>\n  estimateGasPrices(): Promise<GasPrices>\n  estimateGasLimit(params: TxParams): Promise<BigNumber>\n  estimateFeesWithGasPricesAndLimits(params: TxParams): Promise<FeesWithGasPricesAndLimits>\n  estimateApprove(params: EstimateApproveParams): Promise<BigNumber>\n  isApproved(params: IsApprovedParams): Promise<boolean>\n  approve(params: ApproveParams): Promise<TransactionResponse>\n  // `getFees` of `BaseXChainClient` needs to be overridden\n  getFees(params: TxParams): Promise<Fees>\n}\n\nexport type EthereumClientParams = XChainClientParams & {\n  ethplorerUrl?: string\n  ethplorerApiKey?: string\n  explorerUrl?: ExplorerUrl\n  etherscanApiKey?: string\n  infuraCreds?: InfuraCreds\n}\n\n/**\n * Custom Ethereum client\n */\nexport default class Client extends BaseXChainClient implements XChainClient, EthereumClient {\n  private ethNetwork: EthNetwork\n  private hdNode!: HDNode\n  private etherscanApiKey?: string\n  private explorerUrl: ExplorerUrl\n  private infuraCreds: InfuraCreds | undefined\n  private ethplorerUrl: string\n  private ethplorerApiKey: string\n  private providers: Map<Network, Provider> = new Map<Network, Provider>()\n\n  /**\n   * Constructor\n   * @param {EthereumClientParams} params\n   */\n  constructor({\n    network = Network.Testnet,\n    ethplorerUrl = 'https://api.ethplorer.io',\n    ethplorerApiKey = 'freekey',\n    explorerUrl,\n    phrase = '',\n    rootDerivationPaths = {\n      [Network.Mainnet]: `m/44'/60'/0'/0/`,\n      [Network.Testnet]: `m/44'/60'/0'/0/`, // this is INCORRECT but makes the unit tests pass\n    },\n    etherscanApiKey,\n    infuraCreds,\n  }: EthereumClientParams) {\n    super(Chain.Ethereum, { network, rootDerivationPaths })\n    this.ethNetwork = xchainNetworkToEths(network)\n    this.rootDerivationPaths = rootDerivationPaths\n    this.infuraCreds = infuraCreds\n    this.etherscanApiKey = etherscanApiKey\n    this.ethplorerUrl = ethplorerUrl\n    this.ethplorerApiKey = ethplorerApiKey\n    this.explorerUrl = explorerUrl || this.getDefaultExplorerURL()\n    this.setupProviders()\n    this.setPhrase(phrase)\n  }\n\n  /**\n   * Purge client.\n   *\n   * @returns {void}\n   */\n  purgeClient(): void {\n    super.purgeClient()\n    this.hdNode = HDNode.fromMnemonic('')\n  }\n\n  /**\n   * Set/Update the explorer url.\n   *\n   * @param {string} url The explorer url.\n   * @returns {void}\n   */\n  setExplorerURL(url: ExplorerUrl): void {\n    this.explorerUrl = url\n  }\n\n  /**\n   * Get the current address.\n   *\n   * @param {number} walletIndex (optional) HD wallet index\n   * @returns {Address} The current address.\n   *\n   * @throws {\"Phrase must be provided\"}\n   * Thrown if phrase has not been set before. A phrase is needed to create a wallet and to derive an address from it.\n   */\n  getAddress(walletIndex = 0): Address {\n    if (walletIndex < 0) {\n      throw new Error('index must be greater than zero')\n    }\n    return this.hdNode.derivePath(this.getFullDerivationPath(walletIndex)).address.toLowerCase()\n  }\n\n  /**\n   * Get etherjs wallet interface.\n   *\n   * @param {number} walletIndex (optional) HD wallet index\n   * @returns {Wallet} The current etherjs wallet interface.\n   *\n   * @throws {\"Phrase must be provided\"}\n   * Thrown if phrase has not been set before. A phrase is needed to create a wallet and to derive an address from it.\n   */\n  getWallet(walletIndex = 0): ethers.Wallet {\n    return new Wallet(this.hdNode.derivePath(this.getFullDerivationPath(walletIndex))).connect(this.getProvider())\n  }\n  setupProviders(): void {\n    if (this.infuraCreds) {\n      // Infura provider takes either a string of project id\n      // or an object of id and secret\n      const testnetProvider = this.infuraCreds.projectSecret\n        ? new ethers.providers.InfuraProvider(EthNetwork.Test, this.infuraCreds)\n        : new ethers.providers.InfuraProvider(EthNetwork.Test, this.infuraCreds.projectId)\n      const mainnetProvider = this.infuraCreds.projectSecret\n        ? new ethers.providers.InfuraProvider(EthNetwork.Main, this.infuraCreds)\n        : new ethers.providers.InfuraProvider(EthNetwork.Main, this.infuraCreds.projectId)\n      this.providers.set(Network.Testnet, testnetProvider)\n      this.providers.set(Network.Mainnet, mainnetProvider)\n    } else {\n      this.providers.set(Network.Testnet, getDefaultProvider(EthNetwork.Test))\n      this.providers.set(Network.Mainnet, getDefaultProvider(EthNetwork.Main))\n    }\n  }\n\n  /**\n   * Get etherjs Provider interface.\n   *\n   * @returns {Provider} The current etherjs Provider interface.\n   */\n  getProvider(): Provider {\n    return this.providers.get(this.network) || getDefaultProvider(this.network)\n  }\n\n  /**\n   * Get etherjs EtherscanProvider interface.\n   *\n   * @returns {EtherscanProvider} The current etherjs EtherscanProvider interface.\n   */\n  getEtherscanProvider(): EtherscanProvider {\n    return new EtherscanProvider(this.ethNetwork, this.etherscanApiKey)\n  }\n\n  /**\n   * Get the explorer url.\n   *\n   * @returns {string} The explorer url for ethereum based on the current network.\n   */\n  getExplorerUrl(): string {\n    return this.getExplorerUrlByNetwork(this.getNetwork())\n  }\n\n  /**\n   * Get the explorer url.\n   *\n   * @returns {ExplorerUrl} The explorer url (both mainnet and testnet) for ethereum.\n   */\n  private getDefaultExplorerURL(): ExplorerUrl {\n    return {\n      [Network.Testnet]: 'https://ropsten.etherscan.io',\n      [Network.Mainnet]: 'https://etherscan.io',\n    }\n  }\n\n  /**\n   * Get the explorer url.\n   *\n   * @param {Network} network\n   * @returns {string} The explorer url for ethereum based on the network.\n   */\n  private getExplorerUrlByNetwork(network: Network): string {\n    return this.explorerUrl[network]\n  }\n\n  /**\n   * Get the explorer url for the given address.\n   *\n   * @param {Address} address\n   * @returns {string} The explorer url for the given address.\n   */\n  getExplorerAddressUrl(address: Address): string {\n    return `${this.getExplorerUrl()}/address/${address}`\n  }\n\n  /**\n   * Get the explorer url for the given transaction id.\n   *\n   * @param {string} txID\n   * @returns {string} The explorer url for the given transaction id.\n   */\n  getExplorerTxUrl(txID: string): string {\n    return `${this.getExplorerUrl()}/tx/${txID}`\n  }\n\n  /**\n   * Set/update the current network.\n   *\n   * @param {Network} network\n   * @returns {void}\n   *\n   * @throws {\"Network must be provided\"}\n   * Thrown if network has not been set before.\n   */\n  setNetwork(network: Network): void {\n    super.setNetwork(network)\n    this.ethNetwork = xchainNetworkToEths(network)\n  }\n\n  /**\n   * Set/update a new phrase (Eg. If user wants to change wallet)\n   *\n   * @param {string} phrase A new phrase.\n   * @param {number} walletIndex (optional) HD wallet index\n   * @returns {Address} The address from the given phrase\n   *\n   * @throws {\"Invalid phrase\"}\n   * Thrown if the given phase is invalid.\n   */\n  setPhrase(phrase: string, walletIndex = 0): Address {\n    this.hdNode = HDNode.fromMnemonic(phrase)\n    return super.setPhrase(phrase, walletIndex)\n  }\n\n  /**\n   * Validate the given address.\n   *\n   * @param {Address} address\n   * @returns {boolean} `true` or `false`\n   */\n  validateAddress(address: Address): boolean {\n    return validateAddress(address)\n  }\n\n  /**\n   * Get the ETH balance of a given address.\n   *\n   * @param {Address} address By default, it will return the balance of the current wallet. (optional)\n   * @returns {Balance[]} The all balance of the address.\n   *\n   * @throws {\"Invalid asset\"} throws when the give asset is an invalid one\n   */\n  async getBalance(address: Address, assets?: Asset[]): Promise<Balance[]> {\n    const ethAddress = address || this.getAddress()\n    // get ETH balance directly from provider\n    const ethBalance: BigNumber = await this.getProvider().getBalance(ethAddress)\n    const ethBalanceAmount = baseAmount(ethBalance.toString(), ETH_DECIMAL)\n\n    switch (this.getNetwork()) {\n      case Network.Mainnet: {\n        // use ethplorerAPI for mainnet - ignore assets\n        const account = await ethplorerAPI.getAddress(this.ethplorerUrl, address, this.ethplorerApiKey)\n        const balances: Balance[] = [\n          {\n            asset: AssetETH,\n            amount: ethBalanceAmount,\n          },\n        ]\n\n        if (account.tokens) {\n          balances.push(...getTokenBalances(account.tokens))\n        }\n\n        return balances\n      }\n      case Network.Testnet: {\n        // use etherscan for testnet\n\n        const newAssets = assets || [AssetETH]\n        // Follow approach is only for testnet\n        // For mainnet, we will use ethplorer api(one request only)\n        // https://github.com/xchainjs/xchainjs-lib/issues/252\n        // And to avoid etherscan api call limit, it gets balances in a sequence way, not in parallel\n        const balances = []\n        for (let i = 0; i < newAssets.length; i++) {\n          const asset = newAssets[i]\n          const etherscan = this.getEtherscanProvider()\n          if (assetToString(asset) !== assetToString(AssetETH)) {\n            // Handle token balances\n            const assetAddress = getTokenAddress(asset)\n            if (!assetAddress) {\n              throw new Error(`Invalid asset ${asset}`)\n            }\n            const balance = await etherscanAPI.getTokenBalance({\n              baseUrl: etherscan.baseUrl,\n              address,\n              assetAddress,\n              apiKey: etherscan.apiKey,\n            })\n            const decimals =\n              BigNumber.from(\n                await this.call<BigNumberish>({ contractAddress: assetAddress, abi: erc20ABI, funcName: 'decimals' }),\n              ).toNumber() || ETH_DECIMAL\n\n            if (!Number.isNaN(decimals)) {\n              balances.push({\n                asset,\n                amount: baseAmount(balance.toString(), decimals),\n              })\n            }\n          } else {\n            balances.push({\n              asset: AssetETH,\n              amount: ethBalanceAmount,\n            })\n          }\n          // Due to etherscan api call limitation, put some delay before another call\n          // Free Etherscan api key limit: 5 calls per second\n          // So 0.3s delay is reasonable for now\n          await delay(300)\n        }\n\n        return balances\n      }\n    }\n  }\n\n  /**\n   * Get transaction history of a given address with pagination options.\n   * By default it will return the transaction history of the current wallet.\n   *\n   * @param {TxHistoryParams} params The options to get transaction history. (optional)\n   * @returns {TxsPage} The transaction history.\n   */\n  async getTransactions(params?: TxHistoryParams): Promise<TxsPage> {\n    const offset = params?.offset || 0\n    const limit = params?.limit || 10\n    const assetAddress = params?.asset\n\n    const maxCount = 10000\n\n    let transations\n    const etherscan = this.getEtherscanProvider()\n\n    if (assetAddress) {\n      transations = await etherscanAPI.getTokenTransactionHistory({\n        baseUrl: etherscan.baseUrl,\n        address: params?.address,\n        assetAddress,\n        page: 0,\n        offset: maxCount,\n        apiKey: etherscan.apiKey,\n      })\n    } else {\n      transations = await etherscanAPI.getETHTransactionHistory({\n        baseUrl: etherscan.baseUrl,\n        address: params?.address,\n        page: 0,\n        offset: maxCount,\n        apiKey: etherscan.apiKey,\n      })\n    }\n\n    return {\n      total: transations.length,\n      txs: transations.filter((_, index) => index >= offset && index < offset + limit),\n    }\n  }\n\n  /**\n   * Get the transaction details of a given transaction id.\n   *\n   * @param {string} txId The transaction id.\n   * @param {string} assetAddress The asset address. (optional)\n   * @returns {Tx} The transaction details of the given transaction id.\n   *\n   * @throws {\"Need to provide valid txId\"}\n   * Thrown if the given txId is invalid.\n   */\n  async getTransactionData(txId: string, assetAddress?: Address): Promise<Tx> {\n    switch (this.getNetwork()) {\n      case Network.Mainnet: {\n        // use ethplorerAPI for mainnet - ignore assetAddress\n        const txInfo = await ethplorerAPI.getTxInfo(this.ethplorerUrl, txId, this.ethplorerApiKey)\n        if (!txInfo.operations?.length) return getTxFromEthplorerEthTransaction(txInfo)\n        const tx = getTxFromEthplorerTokenOperation(txInfo.operations[0])\n        if (!tx) throw new Error('Could not parse transaction data')\n        return tx\n      }\n      case Network.Testnet: {\n        let tx\n        const etherscan = this.getEtherscanProvider()\n        const txInfo = await etherscan.getTransaction(txId)\n        if (txInfo) {\n          if (assetAddress) {\n            tx =\n              (\n                await etherscanAPI.getTokenTransactionHistory({\n                  baseUrl: etherscan.baseUrl,\n                  assetAddress,\n                  startblock: txInfo.blockNumber,\n                  endblock: txInfo.blockNumber,\n                  apiKey: etherscan.apiKey,\n                })\n              ).filter((info) => info.hash === txId)[0] ?? null\n          } else {\n            tx =\n              (\n                await etherscanAPI.getETHTransactionHistory({\n                  baseUrl: etherscan.baseUrl,\n                  startblock: txInfo.blockNumber,\n                  endblock: txInfo.blockNumber,\n                  apiKey: etherscan.apiKey,\n                  address: txInfo.from,\n                })\n              ).filter((info) => info.hash === txId)[0] ?? null\n          }\n        }\n\n        if (!tx) throw new Error('Could not get transaction history')\n\n        return tx\n      }\n    }\n  }\n\n  /**\n   * Call a contract function.\n   * @template T The result interface.\n   * @param {number} walletIndex (optional) HD wallet index\n   * @param {Address} contractAddress The contract address.\n   * @param {ContractInterface} abi The contract ABI json.\n   * @param {string} funcName The function to be called.\n   * @param {any[]} funcParams The parameters of the function.\n   * @returns {T} The result of the contract function call.\n   *\n   * @throws {\"contractAddress must be provided\"}\n   * Thrown if the given contract address is empty.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async call<T>({ walletIndex = 0, contractAddress, abi, funcName, funcParams = [] }: CallParams): Promise<T> {\n    if (!contractAddress) throw new Error('contractAddress must be provided')\n    const contract = new ethers.Contract(contractAddress, abi, this.getProvider()).connect(this.getWallet(walletIndex))\n    return contract[funcName](...funcParams)\n  }\n\n  /**\n   * Call a contract function.\n   * @param {Address} contractAddress The contract address.\n   * @param {ContractInterface} abi The contract ABI json.\n   * @param {string} funcName The function to be called.\n   * @param {any[]} funcParams The parameters of the function.\n   * @param {number} walletIndex (optional) HD wallet index\n   * @returns {BigNumber} The result of the contract function call.\n   *\n   * @throws {\"contractAddress must be provided\"}\n   * Thrown if the given contract address is empty.\n   */\n  async estimateCall({\n    contractAddress,\n    abi,\n    funcName,\n    funcParams = [],\n    walletIndex = 0,\n  }: EstimateCallParams): Promise<BigNumber> {\n    if (!contractAddress) throw new Error('contractAddress must be provided')\n    const contract = new ethers.Contract(contractAddress, abi, this.getProvider()).connect(this.getWallet(walletIndex))\n    return contract.estimateGas[funcName](...funcParams)\n  }\n\n  /**\n   * Check allowance.\n   *\n   * @param {Address} contractAddress The spender address.\n   * @param {Address} spenderAddress The spender address.\n   * @param {BaseAmount} amount The amount to check if it's allowed to spend or not (optional).\n   * @param {number} walletIndex (optional) HD wallet index\n   * @returns {boolean} `true` or `false`.\n   */\n  async isApproved({ contractAddress, spenderAddress, amount, walletIndex = 0 }: IsApprovedParams): Promise<boolean> {\n    // since amount is optional, set it to smallest amount by default\n    const txAmount = BigNumber.from(amount?.amount().toFixed() ?? 1)\n    const owner = this.getAddress(walletIndex)\n    const allowance = await this.call<BigNumberish>({\n      contractAddress,\n      abi: erc20ABI,\n      funcName: 'allowance',\n      funcParams: [owner, spenderAddress],\n    })\n    return txAmount.lte(allowance)\n  }\n\n  /**\n   * Check allowance.\n   *\n   * @param {Address} contractAddress The contract address.\n   * @param {Address} spenderAddress The spender address.\n   * @param {feeOptionKey} FeeOption Fee option (optional)\n   * @param {BaseAmount} amount The amount of token. By default, it will be unlimited token allowance. (optional)\n   * @param {number} walletIndex (optional) HD wallet index\n   *\n   * @returns {TransactionResponse} The transaction result.\n   */\n  async approve({\n    contractAddress,\n    spenderAddress,\n    feeOptionKey: feeOption = FeeOption.Fastest,\n    amount,\n    walletIndex = 0,\n    gasLimitFallback,\n  }: ApproveParams): Promise<TransactionResponse> {\n    const gasPrice = BigNumber.from(\n      (\n        await this.estimateGasPrices()\n          .then((prices) => prices[feeOption])\n          .catch(() => getDefaultGasPrices()[feeOption])\n      )\n        .amount()\n        .toFixed(),\n    )\n    const gasLimit = await this.estimateApprove({\n      walletIndex,\n      spenderAddress,\n      contractAddress,\n      amount,\n    }).catch(() => BigNumber.from(gasLimitFallback))\n\n    const txAmount = amount ? BigNumber.from(amount.amount().toFixed()) : MAX_APPROVAL\n    return await this.call<TransactionResponse>({\n      walletIndex,\n      contractAddress,\n      abi: erc20ABI,\n      funcName: 'approve',\n      funcParams: [spenderAddress, txAmount, { from: this.getAddress(walletIndex), gasPrice, gasLimit }],\n    })\n  }\n\n  /**\n   * Estimate gas limit of approve.\n   *\n   * @param {Address} contractAddress The contract address.\n   * @param {Address} spenderAddress The spender address.\n   * @param {number} walletIndex (optional) HD wallet index\n   * @param {BaseAmount} amount The amount of token. By default, it will be unlimited token allowance. (optional)\n   * @returns {BigNumber} The estimated gas limit.\n   */\n  async estimateApprove({\n    contractAddress,\n    spenderAddress,\n    walletIndex = 0,\n    amount,\n  }: EstimateApproveParams): Promise<BigNumber> {\n    const txAmount = amount ? BigNumber.from(amount.amount().toFixed()) : MAX_APPROVAL\n    const gasLimit = await this.estimateCall({\n      walletIndex,\n      contractAddress,\n      abi: erc20ABI,\n      funcName: 'approve',\n      funcParams: [spenderAddress, txAmount, { from: this.getAddress(walletIndex) }],\n    })\n\n    return gasLimit\n  }\n\n  /**\n   * Transfer ETH.\n   *\n   * @param {TxParams} params The transfer options.\n   * @param {feeOptionKey} FeeOption Fee option (optional)\n   * @param {gasPrice} BaseAmount Gas price (optional)\n   * @param {gasLimit} BigNumber Gas limit (optional)\n   *\n   * A given `feeOptionKey` wins over `gasPrice` and `gasLimit`\n   *\n   * @returns {TxHash} The transaction hash.\n   */\n  async transfer({\n    walletIndex = 0,\n    asset,\n    memo,\n    amount,\n    recipient,\n    feeOptionKey: feeOption,\n    gasPrice,\n    gasLimit,\n  }: TxParams & {\n    feeOptionKey?: FeeOption\n    gasPrice?: BaseAmount\n    gasLimit?: BigNumber\n  }): Promise<TxHash> {\n    const txAmount = BigNumber.from(amount.amount().toFixed())\n\n    let assetAddress\n    if (asset && assetToString(asset) !== assetToString(AssetETH)) {\n      assetAddress = getTokenAddress(asset)\n    }\n\n    const isETHAddress = assetAddress === ETHAddress\n\n    // feeOption\n\n    const defaultGasLimit: ethers.BigNumber = isETHAddress ? SIMPLE_GAS_COST : BASE_TOKEN_GAS_COST\n\n    let overrides: TxOverrides = {\n      gasLimit: gasLimit || defaultGasLimit,\n      gasPrice: gasPrice && BigNumber.from(gasPrice.amount().toFixed()),\n    }\n\n    // override `overrides` if `feeOption` is provided\n    if (feeOption) {\n      const gasPrice = await this.estimateGasPrices()\n        .then((prices) => prices[feeOption])\n        .catch(() => getDefaultGasPrices()[feeOption])\n      const gasLimit = await this.estimateGasLimit({ asset, recipient, amount, memo }).catch(() => defaultGasLimit)\n\n      overrides = {\n        gasLimit,\n        gasPrice: BigNumber.from(gasPrice.amount().toFixed()),\n      }\n    }\n\n    let txResult\n    if (assetAddress && !isETHAddress) {\n      // Transfer ERC20\n      txResult = await this.call<TransactionResponse>({\n        walletIndex,\n        contractAddress: assetAddress,\n        abi: erc20ABI,\n        funcName: 'transfer',\n        funcParams: [recipient, txAmount, Object.assign({}, overrides)],\n      })\n    } else {\n      // Transfer ETH\n      const transactionRequest = Object.assign(\n        { to: recipient, value: txAmount },\n        {\n          ...overrides,\n          data: memo ? toUtf8Bytes(memo) : undefined,\n        },\n      )\n\n      txResult = await this.getWallet().sendTransaction(transactionRequest)\n    }\n\n    return txResult.hash\n  }\n\n  /**\n   * Estimate gas price.\n   * @see https://etherscan.io/apis#gastracker\n   *\n   * @returns {GasPrices} The gas prices (average, fast, fastest) in `Wei` (`BaseAmount`)\n   */\n  async estimateGasPrices(): Promise<GasPrices> {\n    try {\n      // Note: `rates` are in `gwei`\n      // @see https://gitlab.com/thorchain/thornode/-/blob/develop/x/thorchain/querier.go#L416-420\n      // To have all values in `BaseAmount`, they needs to be converted into `wei` (1 gwei = 1,000,000,000 wei = 1e9)\n      const ratesInGwei = standardFeeRates(await this.getFeeRateFromThorchain())\n      return {\n        [FeeOption.Average]: baseAmount(ratesInGwei[FeeOption.Average] * 10 ** 9, ETH_DECIMAL),\n        [FeeOption.Fast]: baseAmount(ratesInGwei[FeeOption.Fast] * 10 ** 9, ETH_DECIMAL),\n        [FeeOption.Fastest]: baseAmount(ratesInGwei[FeeOption.Fastest] * 10 ** 9, ETH_DECIMAL),\n      }\n    } catch (error) {}\n    //should only get here if thor fails\n    try {\n      return await this.estimateGasPricesFromEtherscan()\n    } catch (error) {\n      return Promise.reject(new Error(`Failed to estimate gas price: ${error.msg ?? error.toString()}`))\n    }\n  }\n\n  /**\n   * Estimate gas price.\n   * @see https://etherscan.io/apis#gastracker\n   *\n   * @returns {GasPrices} The gas prices (average, fast, fastest) in `Wei` (`BaseAmount`)\n   *\n   * @throws {\"Failed to estimate gas price\"} Thrown if failed to estimate gas price.\n   */\n  async estimateGasPricesFromEtherscan(): Promise<GasPrices> {\n    const etherscan = this.getEtherscanProvider()\n    const response: GasOracleResponse = await etherscanAPI.getGasOracle(etherscan.baseUrl, etherscan.apiKey)\n\n    // Convert result of gas prices: `Gwei` -> `Wei`\n    const averageWei = parseUnits(response.SafeGasPrice, 'gwei')\n    const fastWei = parseUnits(response.ProposeGasPrice, 'gwei')\n    const fastestWei = parseUnits(response.FastGasPrice, 'gwei')\n\n    return {\n      average: baseAmount(averageWei.toString(), ETH_DECIMAL),\n      fast: baseAmount(fastWei.toString(), ETH_DECIMAL),\n      fastest: baseAmount(fastestWei.toString(), ETH_DECIMAL),\n    }\n  }\n\n  /**\n   * Estimate gas.\n   *\n   * @param {TxParams} params The transaction and fees options.\n   * @returns {BaseAmount} The estimated gas fee.\n   */\n  async estimateGasLimit({ asset, recipient, amount, memo }: TxParams): Promise<BigNumber> {\n    const txAmount = BigNumber.from(amount.amount().toFixed())\n\n    let assetAddress\n    if (asset && assetToString(asset) !== assetToString(AssetETH)) {\n      assetAddress = getTokenAddress(asset)\n    }\n\n    let estimate\n\n    if (assetAddress && assetAddress !== ETHAddress) {\n      // ERC20 gas estimate\n      const contract = new ethers.Contract(assetAddress, erc20ABI, this.getProvider())\n\n      estimate = await contract.estimateGas.transfer(recipient, txAmount, {\n        from: this.getAddress(),\n      })\n    } else {\n      // ETH gas estimate\n      const transactionRequest = {\n        from: this.getAddress(),\n        to: recipient,\n        value: txAmount,\n        data: memo ? toUtf8Bytes(memo) : undefined,\n      }\n\n      estimate = await this.getProvider().estimateGas(transactionRequest)\n    }\n\n    return estimate\n  }\n\n  /**\n   * Estimate gas prices/limits (average, fast fastest).\n   *\n   * @param {TxParams} params\n   * @returns {FeesWithGasPricesAndLimits} The estimated gas prices/limits.\n   */\n  async estimateFeesWithGasPricesAndLimits(params: TxParams): Promise<FeesWithGasPricesAndLimits> {\n    // gas prices\n    const gasPrices = await this.estimateGasPrices()\n    const { fast: fastGP, fastest: fastestGP, average: averageGP } = gasPrices\n\n    // gas limits\n    const gasLimit = await this.estimateGasLimit({\n      asset: params.asset,\n      amount: params.amount,\n      recipient: params.recipient,\n      memo: params.memo,\n    })\n\n    return {\n      gasPrices,\n      fees: {\n        type: FeeType.PerByte,\n        average: getFee({ gasPrice: averageGP, gasLimit }),\n        fast: getFee({ gasPrice: fastGP, gasLimit }),\n        fastest: getFee({ gasPrice: fastestGP, gasLimit }),\n      },\n      gasLimit,\n    }\n  }\n\n  /**\n   * Get fees.\n   *\n   * @param {TxParams} params\n   * @returns {Fees} The average/fast/fastest fees.\n   *\n   * @throws {\"Failed to get fees\"} Thrown if failed to get fees.\n   */\n  getFees(): never\n  getFees(params: TxParams): Promise<Fees>\n  async getFees(params?: TxParams): Promise<Fees> {\n    if (!params) throw new Error('Params need to be passed')\n\n    const { fees } = await this.estimateFeesWithGasPricesAndLimits(params)\n    return fees\n  }\n}\n\nexport { Client }\n"]},"metadata":{},"sourceType":"script"}