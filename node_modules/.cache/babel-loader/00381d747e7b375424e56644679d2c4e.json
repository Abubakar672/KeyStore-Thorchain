{"ast":null,"code":"var Buffer = require('safe-buffer').Buffer;\n\nvar baddress = require('./address');\n\nvar bcrypto = require('./crypto');\n\nvar bscript = require('./script');\n\nvar btemplates = require('./templates');\n\nvar networks = require('./networks');\n\nvar ops = require('@psf/bitcoincash-ops');\n\nvar typeforce = require('typeforce');\n\nvar types = require('./types');\n\nvar scriptTypes = btemplates.types;\nvar SIGNABLE = [btemplates.types.P2PKH, btemplates.types.P2PK, btemplates.types.MULTISIG];\nvar P2SH = SIGNABLE.concat([btemplates.types.P2WPKH, btemplates.types.P2WSH]);\n\nvar ECPair = require('./ecpair');\n\nvar ECSignature = require('./ecsignature');\n\nvar Transaction = require('./transaction');\n\nfunction supportedType(type) {\n  return SIGNABLE.indexOf(type) !== -1;\n}\n\nfunction supportedP2SHType(type) {\n  return P2SH.indexOf(type) !== -1;\n}\n\nfunction extractChunks(type, chunks, script) {\n  var pubKeys = [];\n  var signatures = [];\n\n  switch (type) {\n    case scriptTypes.P2PKH:\n      // if (redeemScript) throw new Error('Nonstandard... P2SH(P2PKH)')\n      pubKeys = chunks.slice(1);\n      signatures = chunks.slice(0, 1);\n      break;\n\n    case scriptTypes.P2PK:\n      pubKeys[0] = script ? btemplates.pubKey.output.decode(script) : undefined;\n      signatures = chunks.slice(0, 1);\n      break;\n\n    case scriptTypes.MULTISIG:\n      if (script) {\n        var multisig = btemplates.multisig.output.decode(script);\n        pubKeys = multisig.pubKeys;\n      }\n\n      signatures = chunks.slice(1).map(function (chunk) {\n        return chunk.length === 0 ? undefined : chunk;\n      });\n      break;\n  }\n\n  return {\n    pubKeys: pubKeys,\n    signatures: signatures\n  };\n}\n\nfunction expandInput(scriptSig, witnessStack) {\n  if (scriptSig.length === 0 && witnessStack.length === 0) return {};\n  var prevOutScript;\n  var prevOutType;\n  var scriptType;\n  var script;\n  var redeemScript;\n  var witnessScript;\n  var witnessScriptType;\n  var redeemScriptType;\n  var witness = false;\n  var p2wsh = false;\n  var p2sh = false;\n  var witnessProgram;\n  var chunks;\n  var scriptSigChunks = bscript.decompile(scriptSig);\n  var sigType = btemplates.classifyInput(scriptSigChunks, true);\n\n  if (sigType === scriptTypes.P2SH) {\n    p2sh = true;\n    redeemScript = scriptSigChunks[scriptSigChunks.length - 1];\n    redeemScriptType = btemplates.classifyOutput(redeemScript);\n    prevOutScript = btemplates.scriptHash.output.encode(bcrypto.hash160(redeemScript));\n    prevOutType = scriptTypes.P2SH;\n    script = redeemScript;\n  }\n\n  var classifyWitness = btemplates.classifyWitness(witnessStack, true);\n\n  if (classifyWitness === scriptTypes.P2WSH) {\n    witnessScript = witnessStack[witnessStack.length - 1];\n    witnessScriptType = btemplates.classifyOutput(witnessScript);\n    p2wsh = true;\n    witness = true;\n\n    if (scriptSig.length === 0) {\n      prevOutScript = btemplates.witnessScriptHash.output.encode(bcrypto.sha256(witnessScript));\n      prevOutType = scriptTypes.P2WSH;\n\n      if (redeemScript !== undefined) {\n        throw new Error('Redeem script given when unnecessary');\n      } // bare witness\n\n    } else {\n      if (!redeemScript) {\n        throw new Error('No redeemScript provided for P2WSH, but scriptSig non-empty');\n      }\n\n      witnessProgram = btemplates.witnessScriptHash.output.encode(bcrypto.sha256(witnessScript));\n\n      if (!redeemScript.equals(witnessProgram)) {\n        throw new Error('Redeem script didn\\'t match witnessScript');\n      }\n    }\n\n    if (!supportedType(btemplates.classifyOutput(witnessScript))) {\n      throw new Error('unsupported witness script');\n    }\n\n    script = witnessScript;\n    scriptType = witnessScriptType;\n    chunks = witnessStack.slice(0, -1);\n  } else if (classifyWitness === scriptTypes.P2WPKH) {\n    witness = true;\n    var key = witnessStack[witnessStack.length - 1];\n    var keyHash = bcrypto.hash160(key);\n\n    if (scriptSig.length === 0) {\n      prevOutScript = btemplates.witnessPubKeyHash.output.encode(keyHash);\n      prevOutType = scriptTypes.P2WPKH;\n\n      if (typeof redeemScript !== 'undefined') {\n        throw new Error('Redeem script given when unnecessary');\n      }\n    } else {\n      if (!redeemScript) {\n        throw new Error('No redeemScript provided for P2WPKH, but scriptSig wasn\\'t empty');\n      }\n\n      witnessProgram = btemplates.witnessPubKeyHash.output.encode(keyHash);\n\n      if (!redeemScript.equals(witnessProgram)) {\n        throw new Error('Redeem script did not have the right witness program');\n      }\n    }\n\n    scriptType = scriptTypes.P2PKH;\n    chunks = witnessStack;\n  } else if (redeemScript) {\n    if (!supportedP2SHType(redeemScriptType)) {\n      throw new Error('Bad redeemscript!');\n    }\n\n    script = redeemScript;\n    scriptType = redeemScriptType;\n    chunks = scriptSigChunks.slice(0, -1);\n  } else {\n    prevOutType = scriptType = btemplates.classifyInput(scriptSig);\n    chunks = scriptSigChunks;\n  }\n\n  var expanded = extractChunks(scriptType, chunks, script);\n  var result = {\n    pubKeys: expanded.pubKeys,\n    signatures: expanded.signatures,\n    prevOutScript: prevOutScript,\n    prevOutType: prevOutType,\n    signType: scriptType,\n    signScript: script,\n    witness: Boolean(witness)\n  };\n\n  if (p2sh) {\n    result.redeemScript = redeemScript;\n    result.redeemScriptType = redeemScriptType;\n  }\n\n  if (p2wsh) {\n    result.witnessScript = witnessScript;\n    result.witnessScriptType = witnessScriptType;\n  }\n\n  return result;\n} // could be done in expandInput, but requires the original Transaction for hashForSignature\n\n\nfunction fixMultisigOrder(input, transaction, vin, value, bitcoinCash) {\n  if (input.redeemScriptType !== scriptTypes.MULTISIG || !input.redeemScript) return;\n  if (input.pubKeys.length === input.signatures.length) return;\n  var unmatched = input.signatures.concat();\n  input.signatures = input.pubKeys.map(function (pubKey) {\n    var keyPair = ECPair.fromPublicKeyBuffer(pubKey);\n    var match; // check for a signature\n\n    unmatched.some(function (signature, i) {\n      // skip if undefined || OP_0\n      if (!signature) return false; // TODO: avoid O(n) hashForSignature\n\n      var parsed = ECSignature.parseScriptSignature(signature);\n      var hash;\n\n      if (bitcoinCash) {\n        hash = transaction.hashForCashSignature(vin, input.signScript, value, parsed.hashType);\n      } else {\n        if (input.witness) {\n          hash = transaction.hashForWitnessV0(vin, input.signScript, value, parsed.hashType);\n        } else {\n          hash = transaction.hashForSignature(vin, input.signScript, parsed.hashType);\n        }\n      } // skip if signature does not match pubKey\n\n\n      if (!keyPair.verify(hash, parsed.signature)) return false; // remove matched signature from unmatched\n\n      unmatched[i] = undefined;\n      match = signature;\n      return true;\n    });\n    return match;\n  });\n}\n\nfunction expandOutput(script, scriptType, ourPubKey) {\n  typeforce(types.Buffer, script);\n  var scriptChunks = bscript.decompile(script);\n\n  if (!scriptType) {\n    scriptType = btemplates.classifyOutput(script);\n  }\n\n  var pubKeys = [];\n\n  switch (scriptType) {\n    // does our hash160(pubKey) match the output scripts?\n    case scriptTypes.P2PKH:\n      if (!ourPubKey) break;\n      var pkh1 = scriptChunks[2];\n      var pkh2 = bcrypto.hash160(ourPubKey);\n      if (pkh1.equals(pkh2)) pubKeys = [ourPubKey];\n      break;\n    // does our hash160(pubKey) match the output scripts?\n\n    case scriptTypes.P2WPKH:\n      if (!ourPubKey) break;\n      var wpkh1 = scriptChunks[1];\n      var wpkh2 = bcrypto.hash160(ourPubKey);\n      if (wpkh1.equals(wpkh2)) pubKeys = [ourPubKey];\n      break;\n\n    case scriptTypes.P2PK:\n      pubKeys = scriptChunks.slice(0, 1);\n      break;\n\n    case scriptTypes.MULTISIG:\n      pubKeys = scriptChunks.slice(1, -2);\n      break;\n\n    default:\n      return {\n        scriptType: scriptType\n      };\n  }\n\n  return {\n    pubKeys: pubKeys,\n    scriptType: scriptType,\n    signatures: pubKeys.map(function () {\n      return undefined;\n    })\n  };\n}\n\nfunction checkP2SHInput(input, redeemScriptHash) {\n  if (input.prevOutType) {\n    if (input.prevOutType !== scriptTypes.P2SH) throw new Error('PrevOutScript must be P2SH');\n    var prevOutScriptScriptHash = bscript.decompile(input.prevOutScript)[1];\n    if (!prevOutScriptScriptHash.equals(redeemScriptHash)) throw new Error('Inconsistent hash160(RedeemScript)');\n  }\n}\n\nfunction checkP2WSHInput(input, witnessScriptHash) {\n  if (input.prevOutType) {\n    if (input.prevOutType !== scriptTypes.P2WSH) throw new Error('PrevOutScript must be P2WSH');\n    var scriptHash = bscript.decompile(input.prevOutScript)[1];\n    if (!scriptHash.equals(witnessScriptHash)) throw new Error('Inconsistent sha25(WitnessScript)');\n  }\n}\n\nfunction prepareInput(input, kpPubKey, redeemScript, witnessValue, witnessScript) {\n  var expanded;\n  var prevOutType;\n  var prevOutScript;\n  var p2sh = false;\n  var p2shType;\n  var redeemScriptHash;\n  var witness = false;\n  var p2wsh = false;\n  var witnessType;\n  var witnessScriptHash;\n  var signType;\n  var signScript;\n\n  if (redeemScript && witnessScript) {\n    redeemScriptHash = bcrypto.hash160(redeemScript);\n    witnessScriptHash = bcrypto.sha256(witnessScript);\n    checkP2SHInput(input, redeemScriptHash);\n    if (!redeemScript.equals(btemplates.witnessScriptHash.output.encode(witnessScriptHash))) throw new Error('Witness script inconsistent with redeem script');\n    expanded = expandOutput(witnessScript, undefined, kpPubKey);\n    if (!expanded.pubKeys) throw new Error('WitnessScript not supported \"' + bscript.toASM(redeemScript) + '\"');\n    prevOutType = btemplates.types.P2SH;\n    prevOutScript = btemplates.scriptHash.output.encode(redeemScriptHash);\n    p2sh = witness = p2wsh = true;\n    p2shType = btemplates.types.P2WSH;\n    signType = witnessType = expanded.scriptType;\n    signScript = witnessScript;\n  } else if (redeemScript) {\n    redeemScriptHash = bcrypto.hash160(redeemScript);\n    checkP2SHInput(input, redeemScriptHash);\n    expanded = expandOutput(redeemScript, undefined, kpPubKey);\n    if (!expanded.pubKeys) throw new Error('RedeemScript not supported \"' + bscript.toASM(redeemScript) + '\"');\n    prevOutType = btemplates.types.P2SH;\n    prevOutScript = btemplates.scriptHash.output.encode(redeemScriptHash);\n    p2sh = true;\n    signType = p2shType = expanded.scriptType;\n    signScript = redeemScript;\n    witness = signType === btemplates.types.P2WPKH;\n  } else if (witnessScript) {\n    witnessScriptHash = bcrypto.sha256(witnessScript);\n    checkP2WSHInput(input, witnessScriptHash);\n    expanded = expandOutput(witnessScript, undefined, kpPubKey);\n    if (!expanded.pubKeys) throw new Error('WitnessScript not supported \"' + bscript.toASM(redeemScript) + '\"');\n    prevOutType = btemplates.types.P2WSH;\n    prevOutScript = btemplates.witnessScriptHash.output.encode(witnessScriptHash);\n    witness = p2wsh = true;\n    signType = witnessType = expanded.scriptType;\n    signScript = witnessScript;\n  } else if (input.prevOutType) {\n    // embedded scripts are not possible without a redeemScript\n    if (input.prevOutType === scriptTypes.P2SH || input.prevOutType === scriptTypes.P2WSH) {\n      throw new Error('PrevOutScript is ' + input.prevOutType + ', requires redeemScript');\n    }\n\n    prevOutType = input.prevOutType;\n    prevOutScript = input.prevOutScript;\n    expanded = expandOutput(input.prevOutScript, input.prevOutType, kpPubKey);\n    if (!expanded.pubKeys) return;\n    witness = input.prevOutType === scriptTypes.P2WPKH;\n    signType = prevOutType;\n    signScript = prevOutScript;\n  } else {\n    prevOutScript = btemplates.pubKeyHash.output.encode(bcrypto.hash160(kpPubKey));\n    expanded = expandOutput(prevOutScript, scriptTypes.P2PKH, kpPubKey);\n    prevOutType = scriptTypes.P2PKH;\n    witness = false;\n    signType = prevOutType;\n    signScript = prevOutScript;\n  }\n\n  if (signType === scriptTypes.P2WPKH) {\n    signScript = btemplates.pubKeyHash.output.encode(btemplates.witnessPubKeyHash.output.decode(signScript));\n  }\n\n  if (p2sh) {\n    input.redeemScript = redeemScript;\n    input.redeemScriptType = p2shType;\n  }\n\n  if (p2wsh) {\n    input.witnessScript = witnessScript;\n    input.witnessScriptType = witnessType;\n  }\n\n  input.pubKeys = expanded.pubKeys;\n  input.signatures = expanded.signatures;\n  input.signScript = signScript;\n  input.signType = signType;\n  input.prevOutScript = prevOutScript;\n  input.prevOutType = prevOutType;\n  input.witness = witness;\n}\n\nfunction buildStack(type, signatures, pubKeys, allowIncomplete) {\n  if (type === scriptTypes.P2PKH) {\n    if (signatures.length === 1 && Buffer.isBuffer(signatures[0]) && pubKeys.length === 1) return btemplates.pubKeyHash.input.encodeStack(signatures[0], pubKeys[0]);\n  } else if (type === scriptTypes.P2PK) {\n    if (signatures.length === 1 && Buffer.isBuffer(signatures[0])) return btemplates.pubKey.input.encodeStack(signatures[0]);\n  } else if (type === scriptTypes.MULTISIG) {\n    if (signatures.length > 0) {\n      signatures = signatures.map(function (signature) {\n        return signature || ops.OP_0;\n      });\n\n      if (!allowIncomplete) {\n        // remove blank signatures\n        signatures = signatures.filter(function (x) {\n          return x !== ops.OP_0;\n        });\n      }\n\n      return btemplates.multisig.input.encodeStack(signatures);\n    }\n  } else {\n    throw new Error('Not yet supported');\n  }\n\n  if (!allowIncomplete) throw new Error('Not enough signatures provided');\n  return [];\n}\n\nfunction buildInput(input, allowIncomplete) {\n  var scriptType = input.prevOutType;\n  var sig = [];\n  var witness = [];\n\n  if (supportedType(scriptType)) {\n    sig = buildStack(scriptType, input.signatures, input.pubKeys, allowIncomplete);\n  }\n\n  var p2sh = false;\n\n  if (scriptType === btemplates.types.P2SH) {\n    // We can remove this error later when we have a guarantee prepareInput\n    // rejects unsignable scripts - it MUST be signable at this point.\n    if (!allowIncomplete && !supportedP2SHType(input.redeemScriptType)) {\n      throw new Error('Impossible to sign this type');\n    }\n\n    if (supportedType(input.redeemScriptType)) {\n      sig = buildStack(input.redeemScriptType, input.signatures, input.pubKeys, allowIncomplete);\n    } // If it wasn't SIGNABLE, it's witness, defer to that\n\n\n    if (input.redeemScriptType) {\n      p2sh = true;\n      scriptType = input.redeemScriptType;\n    }\n  }\n\n  switch (scriptType) {\n    // P2WPKH is a special case of P2PKH\n    case btemplates.types.P2WPKH:\n      witness = buildStack(btemplates.types.P2PKH, input.signatures, input.pubKeys, allowIncomplete);\n      break;\n\n    case btemplates.types.P2WSH:\n      // We can remove this check later\n      if (!allowIncomplete && !supportedType(input.witnessScriptType)) {\n        throw new Error('Impossible to sign this type');\n      }\n\n      if (supportedType(input.witnessScriptType)) {\n        witness = buildStack(input.witnessScriptType, input.signatures, input.pubKeys, allowIncomplete);\n        witness.push(input.witnessScript);\n        scriptType = input.witnessScriptType;\n      }\n\n      break;\n  } // append redeemScript if necessary\n\n\n  if (p2sh) {\n    sig.push(input.redeemScript);\n  }\n\n  return {\n    type: scriptType,\n    script: bscript.compile(sig),\n    witness: witness\n  };\n}\n\nfunction TransactionBuilder(network, maximumFeeRate) {\n  this.prevTxMap = {};\n  this.network = network || networks.bitcoin; // WARNING: This is __NOT__ to be relied on, its just another potential safety mechanism (safety in-depth)\n\n  this.maximumFeeRate = maximumFeeRate || 2500;\n  this.inputs = [];\n  this.bitcoinCash = true;\n  this.tx = new Transaction();\n}\n\nTransactionBuilder.prototype.setLockTime = function (locktime) {\n  typeforce(types.UInt32, locktime); // if any signatures exist, throw\n\n  if (this.inputs.some(function (input) {\n    if (!input.signatures) return false;\n    return input.signatures.some(function (s) {\n      return s;\n    });\n  })) {\n    throw new Error('No, this would invalidate signatures');\n  }\n\n  this.tx.locktime = locktime;\n};\n\nTransactionBuilder.fromTransaction = function (transaction, network, bitcoinCashTx) {\n  var txb = new TransactionBuilder(network); // Copy transaction fields\n\n  txb.setLockTime(transaction.locktime); // Copy outputs (done first to avoid signature invalidation)\n\n  transaction.outs.forEach(function (txOut) {\n    txb.addOutput(txOut.script, txOut.value);\n  }); // Copy inputs\n\n  transaction.ins.forEach(function (txIn) {\n    txb.__addInputUnsafe(txIn.hash, txIn.index, {\n      sequence: txIn.sequence,\n      script: txIn.script,\n      witness: txIn.witness,\n      value: txIn.value\n    });\n  }); // fix some things not possible through the public API\n\n  txb.inputs.forEach(function (input, i) {\n    fixMultisigOrder(input, transaction, i, input.value, bitcoinCashTx);\n  });\n  return txb;\n};\n\nTransactionBuilder.prototype.addInput = function (txHash, vout, sequence, prevOutScript) {\n  if (!this.__canModifyInputs()) {\n    throw new Error('No, this would invalidate signatures');\n  }\n\n  var value; // is it a hex string?\n\n  if (typeof txHash === 'string') {\n    // transaction hashs's are displayed in reverse order, un-reverse it\n    txHash = Buffer.from(txHash, 'hex').reverse(); // is it a Transaction object?\n  } else if (txHash instanceof Transaction) {\n    var txOut = txHash.outs[vout];\n    prevOutScript = txOut.script;\n    value = txOut.value;\n    txHash = txHash.getHash();\n  }\n\n  return this.__addInputUnsafe(txHash, vout, {\n    sequence: sequence,\n    prevOutScript: prevOutScript,\n    value: value\n  });\n};\n\nTransactionBuilder.prototype.__addInputUnsafe = function (txHash, vout, options) {\n  if (Transaction.isCoinbaseHash(txHash)) {\n    throw new Error('coinbase inputs not supported');\n  }\n\n  var prevTxOut = txHash.toString('hex') + ':' + vout;\n  if (this.prevTxMap[prevTxOut] !== undefined) throw new Error('Duplicate TxOut: ' + prevTxOut);\n  var input = {}; // derive what we can from the scriptSig\n\n  if (options.script !== undefined) {\n    input = expandInput(options.script, options.witness || []);\n  } // if an input value was given, retain it\n\n\n  if (options.value !== undefined) {\n    input.value = options.value;\n  } // derive what we can from the previous transactions output script\n\n\n  if (!input.prevOutScript && options.prevOutScript) {\n    var prevOutType;\n\n    if (!input.pubKeys && !input.signatures) {\n      var expanded = expandOutput(options.prevOutScript);\n\n      if (expanded.pubKeys) {\n        input.pubKeys = expanded.pubKeys;\n        input.signatures = expanded.signatures;\n      }\n\n      prevOutType = expanded.scriptType;\n    }\n\n    input.prevOutScript = options.prevOutScript;\n    input.prevOutType = prevOutType || btemplates.classifyOutput(options.prevOutScript);\n  }\n\n  var vin = this.tx.addInput(txHash, vout, options.sequence, options.scriptSig);\n  this.inputs[vin] = input;\n  this.prevTxMap[prevTxOut] = vin;\n  return vin;\n};\n\nTransactionBuilder.prototype.addOutput = function (scriptPubKey, value) {\n  if (!this.__canModifyOutputs()) {\n    throw new Error('No, this would invalidate signatures');\n  } // Attempt to get a script if it's a base58 address string\n\n\n  if (typeof scriptPubKey === 'string') {\n    scriptPubKey = baddress.toOutputScript(scriptPubKey, this.network);\n  }\n\n  return this.tx.addOutput(scriptPubKey, value);\n};\n\nTransactionBuilder.prototype.build = function () {\n  return this.__build(false);\n};\n\nTransactionBuilder.prototype.buildIncomplete = function () {\n  return this.__build(true);\n};\n\nTransactionBuilder.prototype.__build = function (allowIncomplete) {\n  if (!allowIncomplete) {\n    if (!this.tx.ins.length) throw new Error('Transaction has no inputs');\n    if (!this.tx.outs.length) throw new Error('Transaction has no outputs');\n  }\n\n  var tx = this.tx.clone(); // Create script signatures from inputs\n\n  this.inputs.forEach(function (input, i) {\n    var scriptType = input.witnessScriptType || input.redeemScriptType || input.prevOutType;\n    if (!scriptType && !allowIncomplete) throw new Error('Transaction is not complete');\n    var result = buildInput(input, allowIncomplete); // skip if no result\n\n    if (!allowIncomplete) {\n      if (!supportedType(result.type) && result.type !== btemplates.types.P2WPKH) {\n        throw new Error(result.type + ' not supported');\n      }\n    }\n\n    tx.setInputScript(i, result.script);\n    tx.setWitness(i, result.witness);\n  });\n\n  if (!allowIncomplete) {\n    // do not rely on this, its merely a last resort\n    if (this.__overMaximumFees(tx.virtualSize())) {\n      throw new Error('Transaction has absurd fees');\n    }\n  }\n\n  return tx;\n};\n\nfunction canSign(input) {\n  return input.prevOutScript !== undefined && input.signScript !== undefined && input.pubKeys !== undefined && input.signatures !== undefined && input.signatures.length === input.pubKeys.length && input.pubKeys.length > 0 && (input.witness === false || input.witness === true && input.value !== undefined);\n}\n\nTransactionBuilder.prototype.sign = function (vin, keyPair, redeemScript, hashType, witnessValue, witnessScript, signatureAlgorithm) {\n  hashType = hashType | Transaction.SIGHASH_BITCOINCASHBIP143;\n  if (!this.inputs[vin]) throw new Error('No input at index: ' + vin);\n  hashType = hashType || Transaction.SIGHASH_ALL;\n  var input = this.inputs[vin]; // if redeemScript was previously provided, enforce consistency\n\n  if (input.redeemScript !== undefined && redeemScript && !input.redeemScript.equals(redeemScript)) {\n    throw new Error('Inconsistent redeemScript');\n  }\n\n  var kpPubKey = keyPair.publicKey || keyPair.getPublicKeyBuffer();\n\n  if (!canSign(input)) {\n    if (witnessValue !== undefined) {\n      if (input.value !== undefined && input.value !== witnessValue) throw new Error('Input didn\\'t match witnessValue');\n      typeforce(types.Satoshi, witnessValue);\n      input.value = witnessValue;\n    }\n\n    if (!canSign(input)) prepareInput(input, kpPubKey, redeemScript, witnessValue, witnessScript);\n    if (!canSign(input)) throw Error(input.prevOutType + ' not supported');\n  } // ready to sign\n  // var signatureHash = this.tx.hashForCashSignature(vin, input.signScript, witnessValue, hashType)\n\n\n  var signatureHash = this.tx.hashForCashSignature(vin, input.signScript, witnessValue, hashType); // if (this.bitcoinCash) {\n  //   signatureHash = this.tx.hashForCashSignature(vin, input.signScript, witnessValue, hashType)\n  // } else {\n  //   if (input.witness) {\n  //     signatureHash = this.tx.hashForWitnessV0(vin, input.signScript, witnessValue, hashType)\n  //   } else {\n  //     signatureHash = this.tx.hashForSignature(vin, input.signScript, hashType)\n  //   }\n  // }\n  // enforce in order signing of public keys\n\n  var signed = input.pubKeys.some(function (pubKey, i) {\n    if (!kpPubKey.equals(pubKey)) return false;\n    if (input.signatures[i]) throw new Error('Signature already exists');\n    if (kpPubKey.length !== 33 && input.signType === scriptTypes.P2WPKH) throw new Error('BIP143 rejects uncompressed public keys in P2WPKH or P2WSH');\n    var signature = keyPair.sign(signatureHash, signatureAlgorithm);\n    if (Buffer.isBuffer(signature)) signature = ECSignature.fromRSBuffer(signature);\n    input.signatures[i] = signature.toScriptSignature(hashType, signatureAlgorithm);\n    return true;\n  });\n  if (!signed) throw new Error('Key pair cannot sign for this input');\n};\n\nfunction signatureHashType(buffer) {\n  return buffer.readUInt8(buffer.length - 1);\n}\n\nTransactionBuilder.prototype.__canModifyInputs = function () {\n  return this.inputs.every(function (input) {\n    // any signatures?\n    if (input.signatures === undefined) return true;\n    return input.signatures.every(function (signature) {\n      if (!signature) return true;\n      var hashType = signatureHashType(signature); // if SIGHASH_ANYONECANPAY is set, signatures would not\n      // be invalidated by more inputs\n\n      return hashType & Transaction.SIGHASH_ANYONECANPAY;\n    });\n  });\n};\n\nTransactionBuilder.prototype.__canModifyOutputs = function () {\n  var nInputs = this.tx.ins.length;\n  var nOutputs = this.tx.outs.length;\n  return this.inputs.every(function (input) {\n    if (input.signatures === undefined) return true;\n    return input.signatures.every(function (signature) {\n      if (!signature) return true;\n      var hashType = signatureHashType(signature);\n      var hashTypeMod = hashType & 0x1f;\n      if (hashTypeMod === Transaction.SIGHASH_NONE) return true;\n\n      if (hashTypeMod === Transaction.SIGHASH_SINGLE) {\n        // if SIGHASH_SINGLE is set, and nInputs > nOutputs\n        // some signatures would be invalidated by the addition\n        // of more outputs\n        return nInputs <= nOutputs;\n      }\n    });\n  });\n};\n\nTransactionBuilder.prototype.__overMaximumFees = function (bytes) {\n  // not all inputs will have .value defined\n  var incoming = this.inputs.reduce(function (a, x) {\n    return a + (x.value >>> 0);\n  }, 0); // but all outputs do, and if we have any input value\n  // we can immediately determine if the outputs are too small\n\n  var outgoing = this.tx.outs.reduce(function (a, x) {\n    return a + x.value;\n  }, 0);\n  var fee = incoming - outgoing;\n  var feeRate = fee / bytes;\n  return feeRate > this.maximumFeeRate;\n};\n\nmodule.exports = TransactionBuilder;","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@psf/bitcoincashjs-lib/src/transaction_builder.js"],"names":["Buffer","require","baddress","bcrypto","bscript","btemplates","networks","ops","typeforce","types","scriptTypes","SIGNABLE","P2PKH","P2PK","MULTISIG","P2SH","concat","P2WPKH","P2WSH","ECPair","ECSignature","Transaction","supportedType","type","indexOf","supportedP2SHType","extractChunks","chunks","script","pubKeys","signatures","slice","pubKey","output","decode","undefined","multisig","map","chunk","length","expandInput","scriptSig","witnessStack","prevOutScript","prevOutType","scriptType","redeemScript","witnessScript","witnessScriptType","redeemScriptType","witness","p2wsh","p2sh","witnessProgram","scriptSigChunks","decompile","sigType","classifyInput","classifyOutput","scriptHash","encode","hash160","classifyWitness","witnessScriptHash","sha256","Error","equals","key","keyHash","witnessPubKeyHash","expanded","result","signType","signScript","Boolean","fixMultisigOrder","input","transaction","vin","value","bitcoinCash","unmatched","keyPair","fromPublicKeyBuffer","match","some","signature","i","parsed","parseScriptSignature","hash","hashForCashSignature","hashType","hashForWitnessV0","hashForSignature","verify","expandOutput","ourPubKey","scriptChunks","pkh1","pkh2","wpkh1","wpkh2","checkP2SHInput","redeemScriptHash","prevOutScriptScriptHash","checkP2WSHInput","prepareInput","kpPubKey","witnessValue","p2shType","witnessType","toASM","pubKeyHash","buildStack","allowIncomplete","isBuffer","encodeStack","OP_0","filter","x","buildInput","sig","push","compile","TransactionBuilder","network","maximumFeeRate","prevTxMap","bitcoin","inputs","tx","prototype","setLockTime","locktime","UInt32","s","fromTransaction","bitcoinCashTx","txb","outs","forEach","txOut","addOutput","ins","txIn","__addInputUnsafe","index","sequence","addInput","txHash","vout","__canModifyInputs","from","reverse","getHash","options","isCoinbaseHash","prevTxOut","toString","scriptPubKey","__canModifyOutputs","toOutputScript","build","__build","buildIncomplete","clone","setInputScript","setWitness","__overMaximumFees","virtualSize","canSign","sign","signatureAlgorithm","SIGHASH_BITCOINCASHBIP143","SIGHASH_ALL","publicKey","getPublicKeyBuffer","Satoshi","signatureHash","signed","fromRSBuffer","toScriptSignature","signatureHashType","buffer","readUInt8","every","SIGHASH_ANYONECANPAY","nInputs","nOutputs","hashTypeMod","SIGHASH_NONE","SIGHASH_SINGLE","bytes","incoming","reduce","a","outgoing","fee","feeRate","module","exports"],"mappings":"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","sourcesContent":["var Buffer = require('safe-buffer').Buffer\nvar baddress = require('./address')\nvar bcrypto = require('./crypto')\nvar bscript = require('./script')\nvar btemplates = require('./templates')\nvar networks = require('./networks')\nvar ops = require('@psf/bitcoincash-ops')\nvar typeforce = require('typeforce')\nvar types = require('./types')\nvar scriptTypes = btemplates.types\nvar SIGNABLE = [btemplates.types.P2PKH, btemplates.types.P2PK, btemplates.types.MULTISIG]\nvar P2SH = SIGNABLE.concat([btemplates.types.P2WPKH, btemplates.types.P2WSH])\n\nvar ECPair = require('./ecpair')\nvar ECSignature = require('./ecsignature')\nvar Transaction = require('./transaction')\n\nfunction supportedType (type) {\n  return SIGNABLE.indexOf(type) !== -1\n}\n\nfunction supportedP2SHType (type) {\n  return P2SH.indexOf(type) !== -1\n}\n\nfunction extractChunks (type, chunks, script) {\n  var pubKeys = []\n  var signatures = []\n  switch (type) {\n    case scriptTypes.P2PKH:\n      // if (redeemScript) throw new Error('Nonstandard... P2SH(P2PKH)')\n      pubKeys = chunks.slice(1)\n      signatures = chunks.slice(0, 1)\n      break\n\n    case scriptTypes.P2PK:\n      pubKeys[0] = script ? btemplates.pubKey.output.decode(script) : undefined\n      signatures = chunks.slice(0, 1)\n      break\n\n    case scriptTypes.MULTISIG:\n      if (script) {\n        var multisig = btemplates.multisig.output.decode(script)\n        pubKeys = multisig.pubKeys\n      }\n\n      signatures = chunks.slice(1).map(function (chunk) {\n        return chunk.length === 0 ? undefined : chunk\n      })\n      break\n  }\n\n  return {\n    pubKeys: pubKeys,\n    signatures: signatures\n  }\n}\nfunction expandInput (scriptSig, witnessStack) {\n  if (scriptSig.length === 0 && witnessStack.length === 0) return {}\n\n  var prevOutScript\n  var prevOutType\n  var scriptType\n  var script\n  var redeemScript\n  var witnessScript\n  var witnessScriptType\n  var redeemScriptType\n  var witness = false\n  var p2wsh = false\n  var p2sh = false\n  var witnessProgram\n  var chunks\n\n  var scriptSigChunks = bscript.decompile(scriptSig)\n  var sigType = btemplates.classifyInput(scriptSigChunks, true)\n  if (sigType === scriptTypes.P2SH) {\n    p2sh = true\n    redeemScript = scriptSigChunks[scriptSigChunks.length - 1]\n    redeemScriptType = btemplates.classifyOutput(redeemScript)\n    prevOutScript = btemplates.scriptHash.output.encode(bcrypto.hash160(redeemScript))\n    prevOutType = scriptTypes.P2SH\n    script = redeemScript\n  }\n\n  var classifyWitness = btemplates.classifyWitness(witnessStack, true)\n  if (classifyWitness === scriptTypes.P2WSH) {\n    witnessScript = witnessStack[witnessStack.length - 1]\n    witnessScriptType = btemplates.classifyOutput(witnessScript)\n    p2wsh = true\n    witness = true\n    if (scriptSig.length === 0) {\n      prevOutScript = btemplates.witnessScriptHash.output.encode(bcrypto.sha256(witnessScript))\n      prevOutType = scriptTypes.P2WSH\n      if (redeemScript !== undefined) {\n        throw new Error('Redeem script given when unnecessary')\n      }\n      // bare witness\n    } else {\n      if (!redeemScript) {\n        throw new Error('No redeemScript provided for P2WSH, but scriptSig non-empty')\n      }\n      witnessProgram = btemplates.witnessScriptHash.output.encode(bcrypto.sha256(witnessScript))\n      if (!redeemScript.equals(witnessProgram)) {\n        throw new Error('Redeem script didn\\'t match witnessScript')\n      }\n    }\n\n    if (!supportedType(btemplates.classifyOutput(witnessScript))) {\n      throw new Error('unsupported witness script')\n    }\n\n    script = witnessScript\n    scriptType = witnessScriptType\n    chunks = witnessStack.slice(0, -1)\n  } else if (classifyWitness === scriptTypes.P2WPKH) {\n    witness = true\n    var key = witnessStack[witnessStack.length - 1]\n    var keyHash = bcrypto.hash160(key)\n    if (scriptSig.length === 0) {\n      prevOutScript = btemplates.witnessPubKeyHash.output.encode(keyHash)\n      prevOutType = scriptTypes.P2WPKH\n      if (typeof redeemScript !== 'undefined') {\n        throw new Error('Redeem script given when unnecessary')\n      }\n    } else {\n      if (!redeemScript) {\n        throw new Error('No redeemScript provided for P2WPKH, but scriptSig wasn\\'t empty')\n      }\n      witnessProgram = btemplates.witnessPubKeyHash.output.encode(keyHash)\n      if (!redeemScript.equals(witnessProgram)) {\n        throw new Error('Redeem script did not have the right witness program')\n      }\n    }\n\n    scriptType = scriptTypes.P2PKH\n    chunks = witnessStack\n  } else if (redeemScript) {\n    if (!supportedP2SHType(redeemScriptType)) {\n      throw new Error('Bad redeemscript!')\n    }\n\n    script = redeemScript\n    scriptType = redeemScriptType\n    chunks = scriptSigChunks.slice(0, -1)\n  } else {\n    prevOutType = scriptType = btemplates.classifyInput(scriptSig)\n    chunks = scriptSigChunks\n  }\n\n  var expanded = extractChunks(scriptType, chunks, script)\n\n  var result = {\n    pubKeys: expanded.pubKeys,\n    signatures: expanded.signatures,\n    prevOutScript: prevOutScript,\n    prevOutType: prevOutType,\n    signType: scriptType,\n    signScript: script,\n    witness: Boolean(witness)\n  }\n\n  if (p2sh) {\n    result.redeemScript = redeemScript\n    result.redeemScriptType = redeemScriptType\n  }\n\n  if (p2wsh) {\n    result.witnessScript = witnessScript\n    result.witnessScriptType = witnessScriptType\n  }\n\n  return result\n}\n\n// could be done in expandInput, but requires the original Transaction for hashForSignature\nfunction fixMultisigOrder (input, transaction, vin, value, bitcoinCash) {\n  if (input.redeemScriptType !== scriptTypes.MULTISIG || !input.redeemScript) return\n  if (input.pubKeys.length === input.signatures.length) return\n\n  var unmatched = input.signatures.concat()\n\n  input.signatures = input.pubKeys.map(function (pubKey) {\n    var keyPair = ECPair.fromPublicKeyBuffer(pubKey)\n    var match\n\n    // check for a signature\n    unmatched.some(function (signature, i) {\n      // skip if undefined || OP_0\n      if (!signature) return false\n\n      // TODO: avoid O(n) hashForSignature\n      var parsed = ECSignature.parseScriptSignature(signature)\n      var hash\n      if (bitcoinCash) {\n        hash = transaction.hashForCashSignature(vin, input.signScript, value, parsed.hashType)\n      } else {\n        if (input.witness) {\n          hash = transaction.hashForWitnessV0(vin, input.signScript, value, parsed.hashType)\n        } else {\n          hash = transaction.hashForSignature(vin, input.signScript, parsed.hashType)\n        }\n      }\n\n      // skip if signature does not match pubKey\n      if (!keyPair.verify(hash, parsed.signature)) return false\n\n      // remove matched signature from unmatched\n      unmatched[i] = undefined\n      match = signature\n\n      return true\n    })\n\n    return match\n  })\n}\n\nfunction expandOutput (script, scriptType, ourPubKey) {\n  typeforce(types.Buffer, script)\n\n  var scriptChunks = bscript.decompile(script)\n  if (!scriptType) {\n    scriptType = btemplates.classifyOutput(script)\n  }\n\n  var pubKeys = []\n\n  switch (scriptType) {\n    // does our hash160(pubKey) match the output scripts?\n    case scriptTypes.P2PKH:\n      if (!ourPubKey) break\n\n      var pkh1 = scriptChunks[2]\n      var pkh2 = bcrypto.hash160(ourPubKey)\n      if (pkh1.equals(pkh2)) pubKeys = [ourPubKey]\n      break\n\n    // does our hash160(pubKey) match the output scripts?\n    case scriptTypes.P2WPKH:\n      if (!ourPubKey) break\n\n      var wpkh1 = scriptChunks[1]\n      var wpkh2 = bcrypto.hash160(ourPubKey)\n      if (wpkh1.equals(wpkh2)) pubKeys = [ourPubKey]\n      break\n\n    case scriptTypes.P2PK:\n      pubKeys = scriptChunks.slice(0, 1)\n      break\n\n    case scriptTypes.MULTISIG:\n      pubKeys = scriptChunks.slice(1, -2)\n      break\n\n    default: return { scriptType: scriptType }\n  }\n\n  return {\n    pubKeys: pubKeys,\n    scriptType: scriptType,\n    signatures: pubKeys.map(function () { return undefined })\n  }\n}\n\nfunction checkP2SHInput (input, redeemScriptHash) {\n  if (input.prevOutType) {\n    if (input.prevOutType !== scriptTypes.P2SH) throw new Error('PrevOutScript must be P2SH')\n\n    var prevOutScriptScriptHash = bscript.decompile(input.prevOutScript)[1]\n    if (!prevOutScriptScriptHash.equals(redeemScriptHash)) throw new Error('Inconsistent hash160(RedeemScript)')\n  }\n}\n\nfunction checkP2WSHInput (input, witnessScriptHash) {\n  if (input.prevOutType) {\n    if (input.prevOutType !== scriptTypes.P2WSH) throw new Error('PrevOutScript must be P2WSH')\n\n    var scriptHash = bscript.decompile(input.prevOutScript)[1]\n    if (!scriptHash.equals(witnessScriptHash)) throw new Error('Inconsistent sha25(WitnessScript)')\n  }\n}\n\nfunction prepareInput (input, kpPubKey, redeemScript, witnessValue, witnessScript) {\n  var expanded\n  var prevOutType\n  var prevOutScript\n\n  var p2sh = false\n  var p2shType\n  var redeemScriptHash\n\n  var witness = false\n  var p2wsh = false\n  var witnessType\n  var witnessScriptHash\n\n  var signType\n  var signScript\n\n  if (redeemScript && witnessScript) {\n    redeemScriptHash = bcrypto.hash160(redeemScript)\n    witnessScriptHash = bcrypto.sha256(witnessScript)\n    checkP2SHInput(input, redeemScriptHash)\n\n    if (!redeemScript.equals(btemplates.witnessScriptHash.output.encode(witnessScriptHash))) throw new Error('Witness script inconsistent with redeem script')\n\n    expanded = expandOutput(witnessScript, undefined, kpPubKey)\n    if (!expanded.pubKeys) throw new Error('WitnessScript not supported \"' + bscript.toASM(redeemScript) + '\"')\n\n    prevOutType = btemplates.types.P2SH\n    prevOutScript = btemplates.scriptHash.output.encode(redeemScriptHash)\n    p2sh = witness = p2wsh = true\n    p2shType = btemplates.types.P2WSH\n    signType = witnessType = expanded.scriptType\n    signScript = witnessScript\n  } else if (redeemScript) {\n    redeemScriptHash = bcrypto.hash160(redeemScript)\n    checkP2SHInput(input, redeemScriptHash)\n\n    expanded = expandOutput(redeemScript, undefined, kpPubKey)\n    if (!expanded.pubKeys) throw new Error('RedeemScript not supported \"' + bscript.toASM(redeemScript) + '\"')\n\n    prevOutType = btemplates.types.P2SH\n    prevOutScript = btemplates.scriptHash.output.encode(redeemScriptHash)\n    p2sh = true\n    signType = p2shType = expanded.scriptType\n    signScript = redeemScript\n    witness = signType === btemplates.types.P2WPKH\n  } else if (witnessScript) {\n    witnessScriptHash = bcrypto.sha256(witnessScript)\n    checkP2WSHInput(input, witnessScriptHash)\n\n    expanded = expandOutput(witnessScript, undefined, kpPubKey)\n    if (!expanded.pubKeys) throw new Error('WitnessScript not supported \"' + bscript.toASM(redeemScript) + '\"')\n\n    prevOutType = btemplates.types.P2WSH\n    prevOutScript = btemplates.witnessScriptHash.output.encode(witnessScriptHash)\n    witness = p2wsh = true\n    signType = witnessType = expanded.scriptType\n    signScript = witnessScript\n  } else if (input.prevOutType) {\n    // embedded scripts are not possible without a redeemScript\n    if (input.prevOutType === scriptTypes.P2SH ||\n      input.prevOutType === scriptTypes.P2WSH) {\n      throw new Error('PrevOutScript is ' + input.prevOutType + ', requires redeemScript')\n    }\n\n    prevOutType = input.prevOutType\n    prevOutScript = input.prevOutScript\n    expanded = expandOutput(input.prevOutScript, input.prevOutType, kpPubKey)\n    if (!expanded.pubKeys) return\n\n    witness = (input.prevOutType === scriptTypes.P2WPKH)\n    signType = prevOutType\n    signScript = prevOutScript\n  } else {\n    prevOutScript = btemplates.pubKeyHash.output.encode(bcrypto.hash160(kpPubKey))\n    expanded = expandOutput(prevOutScript, scriptTypes.P2PKH, kpPubKey)\n\n    prevOutType = scriptTypes.P2PKH\n    witness = false\n    signType = prevOutType\n    signScript = prevOutScript\n  }\n\n  if (signType === scriptTypes.P2WPKH) {\n    signScript = btemplates.pubKeyHash.output.encode(btemplates.witnessPubKeyHash.output.decode(signScript))\n  }\n\n  if (p2sh) {\n    input.redeemScript = redeemScript\n    input.redeemScriptType = p2shType\n  }\n\n  if (p2wsh) {\n    input.witnessScript = witnessScript\n    input.witnessScriptType = witnessType\n  }\n\n  input.pubKeys = expanded.pubKeys\n  input.signatures = expanded.signatures\n  input.signScript = signScript\n  input.signType = signType\n  input.prevOutScript = prevOutScript\n  input.prevOutType = prevOutType\n  input.witness = witness\n}\n\nfunction buildStack (type, signatures, pubKeys, allowIncomplete) {\n  if (type === scriptTypes.P2PKH) {\n    if (signatures.length === 1 && Buffer.isBuffer(signatures[0]) && pubKeys.length === 1) return btemplates.pubKeyHash.input.encodeStack(signatures[0], pubKeys[0])\n  } else if (type === scriptTypes.P2PK) {\n    if (signatures.length === 1 && Buffer.isBuffer(signatures[0])) return btemplates.pubKey.input.encodeStack(signatures[0])\n  } else if (type === scriptTypes.MULTISIG) {\n    if (signatures.length > 0) {\n      signatures = signatures.map(function (signature) {\n        return signature || ops.OP_0\n      })\n      if (!allowIncomplete) {\n        // remove blank signatures\n        signatures = signatures.filter(function (x) { return x !== ops.OP_0 })\n      }\n\n      return btemplates.multisig.input.encodeStack(signatures)\n    }\n  } else {\n    throw new Error('Not yet supported')\n  }\n\n  if (!allowIncomplete) throw new Error('Not enough signatures provided')\n  return []\n}\n\nfunction buildInput (input, allowIncomplete) {\n  var scriptType = input.prevOutType\n  var sig = []\n  var witness = []\n\n  if (supportedType(scriptType)) {\n    sig = buildStack(scriptType, input.signatures, input.pubKeys, allowIncomplete)\n  }\n\n  var p2sh = false\n  if (scriptType === btemplates.types.P2SH) {\n    // We can remove this error later when we have a guarantee prepareInput\n    // rejects unsignable scripts - it MUST be signable at this point.\n    if (!allowIncomplete && !supportedP2SHType(input.redeemScriptType)) {\n      throw new Error('Impossible to sign this type')\n    }\n\n    if (supportedType(input.redeemScriptType)) {\n      sig = buildStack(input.redeemScriptType, input.signatures, input.pubKeys, allowIncomplete)\n    }\n\n    // If it wasn't SIGNABLE, it's witness, defer to that\n    if (input.redeemScriptType) {\n      p2sh = true\n      scriptType = input.redeemScriptType\n    }\n  }\n\n  switch (scriptType) {\n    // P2WPKH is a special case of P2PKH\n    case btemplates.types.P2WPKH:\n      witness = buildStack(btemplates.types.P2PKH, input.signatures, input.pubKeys, allowIncomplete)\n      break\n\n    case btemplates.types.P2WSH:\n      // We can remove this check later\n      if (!allowIncomplete && !supportedType(input.witnessScriptType)) {\n        throw new Error('Impossible to sign this type')\n      }\n\n      if (supportedType(input.witnessScriptType)) {\n        witness = buildStack(input.witnessScriptType, input.signatures, input.pubKeys, allowIncomplete)\n        witness.push(input.witnessScript)\n        scriptType = input.witnessScriptType\n      }\n\n      break\n  }\n\n  // append redeemScript if necessary\n  if (p2sh) {\n    sig.push(input.redeemScript)\n  }\n\n  return {\n    type: scriptType,\n    script: bscript.compile(sig),\n    witness: witness\n  }\n}\n\nfunction TransactionBuilder (network, maximumFeeRate) {\n  this.prevTxMap = {}\n  this.network = network || networks.bitcoin\n\n  // WARNING: This is __NOT__ to be relied on, its just another potential safety mechanism (safety in-depth)\n  this.maximumFeeRate = maximumFeeRate || 2500\n\n  this.inputs = []\n  this.bitcoinCash = true\n  this.tx = new Transaction()\n}\n\nTransactionBuilder.prototype.setLockTime = function (locktime) {\n  typeforce(types.UInt32, locktime)\n\n  // if any signatures exist, throw\n  if (this.inputs.some(function (input) {\n    if (!input.signatures) return false\n\n    return input.signatures.some(function (s) { return s })\n  })) {\n    throw new Error('No, this would invalidate signatures')\n  }\n\n  this.tx.locktime = locktime\n}\n\nTransactionBuilder.fromTransaction = function (transaction, network, bitcoinCashTx) {\n  var txb = new TransactionBuilder(network)\n\n  // Copy transaction fields\n  txb.setLockTime(transaction.locktime)\n\n  // Copy outputs (done first to avoid signature invalidation)\n  transaction.outs.forEach(function (txOut) {\n    txb.addOutput(txOut.script, txOut.value)\n  })\n\n  // Copy inputs\n  transaction.ins.forEach(function (txIn) {\n    txb.__addInputUnsafe(txIn.hash, txIn.index, {\n      sequence: txIn.sequence,\n      script: txIn.script,\n      witness: txIn.witness,\n      value: txIn.value\n    })\n  })\n\n  // fix some things not possible through the public API\n  txb.inputs.forEach(function (input, i) {\n    fixMultisigOrder(input, transaction, i, input.value, bitcoinCashTx)\n  })\n\n  return txb\n}\n\nTransactionBuilder.prototype.addInput = function (txHash, vout, sequence, prevOutScript) {\n  if (!this.__canModifyInputs()) {\n    throw new Error('No, this would invalidate signatures')\n  }\n\n  var value\n\n  // is it a hex string?\n  if (typeof txHash === 'string') {\n    // transaction hashs's are displayed in reverse order, un-reverse it\n    txHash = Buffer.from(txHash, 'hex').reverse()\n\n  // is it a Transaction object?\n  } else if (txHash instanceof Transaction) {\n    var txOut = txHash.outs[vout]\n    prevOutScript = txOut.script\n    value = txOut.value\n\n    txHash = txHash.getHash()\n  }\n\n  return this.__addInputUnsafe(txHash, vout, {\n    sequence: sequence,\n    prevOutScript: prevOutScript,\n    value: value\n  })\n}\n\nTransactionBuilder.prototype.__addInputUnsafe = function (txHash, vout, options) {\n  if (Transaction.isCoinbaseHash(txHash)) {\n    throw new Error('coinbase inputs not supported')\n  }\n\n  var prevTxOut = txHash.toString('hex') + ':' + vout\n  if (this.prevTxMap[prevTxOut] !== undefined) throw new Error('Duplicate TxOut: ' + prevTxOut)\n\n  var input = {}\n\n  // derive what we can from the scriptSig\n  if (options.script !== undefined) {\n    input = expandInput(options.script, options.witness || [])\n  }\n\n  // if an input value was given, retain it\n  if (options.value !== undefined) {\n    input.value = options.value\n  }\n\n  // derive what we can from the previous transactions output script\n  if (!input.prevOutScript && options.prevOutScript) {\n    var prevOutType\n\n    if (!input.pubKeys && !input.signatures) {\n      var expanded = expandOutput(options.prevOutScript)\n\n      if (expanded.pubKeys) {\n        input.pubKeys = expanded.pubKeys\n        input.signatures = expanded.signatures\n      }\n\n      prevOutType = expanded.scriptType\n    }\n\n    input.prevOutScript = options.prevOutScript\n    input.prevOutType = prevOutType || btemplates.classifyOutput(options.prevOutScript)\n  }\n\n  var vin = this.tx.addInput(txHash, vout, options.sequence, options.scriptSig)\n  this.inputs[vin] = input\n  this.prevTxMap[prevTxOut] = vin\n  return vin\n}\n\nTransactionBuilder.prototype.addOutput = function (scriptPubKey, value) {\n  if (!this.__canModifyOutputs()) {\n    throw new Error('No, this would invalidate signatures')\n  }\n\n  // Attempt to get a script if it's a base58 address string\n  if (typeof scriptPubKey === 'string') {\n    scriptPubKey = baddress.toOutputScript(scriptPubKey, this.network)\n  }\n\n  return this.tx.addOutput(scriptPubKey, value)\n}\n\nTransactionBuilder.prototype.build = function () {\n  return this.__build(false)\n}\nTransactionBuilder.prototype.buildIncomplete = function () {\n  return this.__build(true)\n}\n\nTransactionBuilder.prototype.__build = function (allowIncomplete) {\n  if (!allowIncomplete) {\n    if (!this.tx.ins.length) throw new Error('Transaction has no inputs')\n    if (!this.tx.outs.length) throw new Error('Transaction has no outputs')\n  }\n\n  var tx = this.tx.clone()\n  // Create script signatures from inputs\n  this.inputs.forEach(function (input, i) {\n    var scriptType = input.witnessScriptType || input.redeemScriptType || input.prevOutType\n    if (!scriptType && !allowIncomplete) throw new Error('Transaction is not complete')\n    var result = buildInput(input, allowIncomplete)\n\n    // skip if no result\n    if (!allowIncomplete) {\n      if (!supportedType(result.type) && result.type !== btemplates.types.P2WPKH) {\n        throw new Error(result.type + ' not supported')\n      }\n    }\n\n    tx.setInputScript(i, result.script)\n    tx.setWitness(i, result.witness)\n  })\n\n  if (!allowIncomplete) {\n    // do not rely on this, its merely a last resort\n    if (this.__overMaximumFees(tx.virtualSize())) {\n      throw new Error('Transaction has absurd fees')\n    }\n  }\n\n  return tx\n}\n\nfunction canSign (input) {\n  return input.prevOutScript !== undefined &&\n    input.signScript !== undefined &&\n    input.pubKeys !== undefined &&\n    input.signatures !== undefined &&\n    input.signatures.length === input.pubKeys.length &&\n    input.pubKeys.length > 0 &&\n    (\n      input.witness === false ||\n      (input.witness === true && input.value !== undefined)\n    )\n}\n\nTransactionBuilder.prototype.sign = function (vin, keyPair, redeemScript, hashType, witnessValue, witnessScript, signatureAlgorithm) {\n  hashType = hashType | Transaction.SIGHASH_BITCOINCASHBIP143;\n\n  if (!this.inputs[vin]) throw new Error('No input at index: ' + vin)\n  hashType = hashType || Transaction.SIGHASH_ALL\n\n  var input = this.inputs[vin]\n\n  // if redeemScript was previously provided, enforce consistency\n  if (input.redeemScript !== undefined &&\n      redeemScript &&\n      !input.redeemScript.equals(redeemScript)) {\n    throw new Error('Inconsistent redeemScript')\n  }\n\n  var kpPubKey = keyPair.publicKey || keyPair.getPublicKeyBuffer()\n  if (!canSign(input)) {\n    if (witnessValue !== undefined) {\n      if (input.value !== undefined && input.value !== witnessValue) throw new Error('Input didn\\'t match witnessValue')\n      typeforce(types.Satoshi, witnessValue)\n      input.value = witnessValue\n    }\n\n    if (!canSign(input)) prepareInput(input, kpPubKey, redeemScript, witnessValue, witnessScript)\n    if (!canSign(input)) throw Error(input.prevOutType + ' not supported')\n  }\n\n  // ready to sign\n  // var signatureHash = this.tx.hashForCashSignature(vin, input.signScript, witnessValue, hashType)\n  var signatureHash = this.tx.hashForCashSignature(vin, input.signScript, witnessValue, hashType);\n  // if (this.bitcoinCash) {\n  //   signatureHash = this.tx.hashForCashSignature(vin, input.signScript, witnessValue, hashType)\n  // } else {\n  //   if (input.witness) {\n  //     signatureHash = this.tx.hashForWitnessV0(vin, input.signScript, witnessValue, hashType)\n  //   } else {\n  //     signatureHash = this.tx.hashForSignature(vin, input.signScript, hashType)\n  //   }\n  // }\n\n  // enforce in order signing of public keys\n  var signed = input.pubKeys.some(function (pubKey, i) {\n    if (!kpPubKey.equals(pubKey)) return false\n    if (input.signatures[i]) throw new Error('Signature already exists')\n    if (kpPubKey.length !== 33 &&\n      input.signType === scriptTypes.P2WPKH) throw new Error('BIP143 rejects uncompressed public keys in P2WPKH or P2WSH')\n\n    var signature = keyPair.sign(signatureHash, signatureAlgorithm)\n    if (Buffer.isBuffer(signature)) signature = ECSignature.fromRSBuffer(signature)\n\n    input.signatures[i] = signature.toScriptSignature(hashType, signatureAlgorithm)\n    return true\n  })\n\n  if (!signed) throw new Error('Key pair cannot sign for this input')\n}\n\nfunction signatureHashType (buffer) {\n  return buffer.readUInt8(buffer.length - 1)\n}\n\nTransactionBuilder.prototype.__canModifyInputs = function () {\n  return this.inputs.every(function (input) {\n    // any signatures?\n    if (input.signatures === undefined) return true\n\n    return input.signatures.every(function (signature) {\n      if (!signature) return true\n      var hashType = signatureHashType(signature)\n\n      // if SIGHASH_ANYONECANPAY is set, signatures would not\n      // be invalidated by more inputs\n      return hashType & Transaction.SIGHASH_ANYONECANPAY\n    })\n  })\n}\n\nTransactionBuilder.prototype.__canModifyOutputs = function () {\n  var nInputs = this.tx.ins.length\n  var nOutputs = this.tx.outs.length\n\n  return this.inputs.every(function (input) {\n    if (input.signatures === undefined) return true\n\n    return input.signatures.every(function (signature) {\n      if (!signature) return true\n      var hashType = signatureHashType(signature)\n\n      var hashTypeMod = hashType & 0x1f\n      if (hashTypeMod === Transaction.SIGHASH_NONE) return true\n      if (hashTypeMod === Transaction.SIGHASH_SINGLE) {\n        // if SIGHASH_SINGLE is set, and nInputs > nOutputs\n        // some signatures would be invalidated by the addition\n        // of more outputs\n        return nInputs <= nOutputs\n      }\n    })\n  })\n}\n\nTransactionBuilder.prototype.__overMaximumFees = function (bytes) {\n  // not all inputs will have .value defined\n  var incoming = this.inputs.reduce(function (a, x) { return a + (x.value >>> 0) }, 0)\n\n  // but all outputs do, and if we have any input value\n  // we can immediately determine if the outputs are too small\n  var outgoing = this.tx.outs.reduce(function (a, x) { return a + x.value }, 0)\n  var fee = incoming - outgoing\n  var feeRate = fee / bytes\n\n  return feeRate > this.maximumFeeRate\n}\n\nmodule.exports = TransactionBuilder\n"]},"metadata":{},"sourceType":"script"}