{"ast":null,"code":"// Copyright 2017-2021 @polkadot/util authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n// Adapted from https://github.com/JulienPalard/is_utf8/blob/master/is_utf8.c\nimport { u8aToU8a } from \"../u8a/toU8a.js\";\nimport { isString } from \"./string.js\";\n/**\n * @name isUtf8\n * @summary Tests if the input is valid Utf8\n * @description\n * Checks to see if the input string or Uint8Array is valid Utf8\n */\n\nexport function isUtf8(value) {\n  if (!value) {\n    return isString(value);\n  }\n\n  const u8a = u8aToU8a(value);\n  const len = u8a.length;\n  let i = 0;\n\n  while (i < len) {\n    if (u8a[i] <= 0x7F)\n      /* 00..7F */\n      {\n        i += 1;\n      } else if (u8a[i] >= 0xC2 && u8a[i] <= 0xDF)\n      /* C2..DF 80..BF */\n      {\n        if (i + 1 < len)\n          /* Expect a 2nd byte */\n          {\n            if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0xBF) {\n              // *message = \"After a first byte between C2 and DF, expecting a 2nd byte between 80 and BF\";\n              // *faulty_bytes = 2;\n              return false;\n            }\n          } else {\n          // *message = \"After a first byte between C2 and DF, expecting a 2nd byte.\";\n          // *faulty_bytes = 1;\n          return false;\n        }\n\n        i += 2;\n      } else if (u8a[i] === 0xE0)\n      /* E0 A0..BF 80..BF */\n      {\n        if (i + 2 < len)\n          /* Expect a 2nd and 3rd byte */\n          {\n            if (u8a[i + 1] < 0xA0 || u8a[i + 1] > 0xBF) {\n              // *message = \"After a first byte of E0, expecting a 2nd byte between A0 and BF.\";\n              // *faulty_bytes = 2;\n              return false;\n            }\n\n            if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {\n              // *message = \"After a first byte of E0, expecting a 3nd byte between 80 and BF.\";\n              // *faulty_bytes = 3;\n              return false;\n            }\n          } else {\n          // *message = \"After a first byte of E0, expecting two following bytes.\";\n          // *faulty_bytes = 1;\n          return false;\n        }\n\n        i += 3;\n      } else if (u8a[i] >= 0xE1 && u8a[i] <= 0xEC)\n      /* E1..EC 80..BF 80..BF */\n      {\n        if (i + 2 < len)\n          /* Expect a 2nd and 3rd byte */\n          {\n            if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0xBF) {\n              // *message = \"After a first byte between E1 and EC, expecting the 2nd byte between 80 and BF.\";\n              // *faulty_bytes = 2;\n              return false;\n            }\n\n            if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {\n              // *message = \"After a first byte between E1 and EC, expecting the 3rd byte between 80 and BF.\";\n              // *faulty_bytes = 3;\n              return false;\n            }\n          } else {\n          // *message = \"After a first byte between E1 and EC, expecting two following bytes.\";\n          // *faulty_bytes = 1;\n          return false;\n        }\n\n        i += 3;\n      } else if (u8a[i] === 0xED)\n      /* ED 80..9F 80..BF */\n      {\n        if (i + 2 < len)\n          /* Expect a 2nd and 3rd byte */\n          {\n            if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0x9F) {\n              // *message = \"After a first byte of ED, expecting 2nd byte between 80 and 9F.\";\n              // *faulty_bytes = 2;\n              return false;\n            }\n\n            if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {\n              // *message = \"After a first byte of ED, expecting 3rd byte between 80 and BF.\";\n              // *faulty_bytes = 3;\n              return false;\n            }\n          } else {\n          // *message = \"After a first byte of ED, expecting two following bytes.\";\n          // *faulty_bytes = 1;\n          return false;\n        }\n\n        i += 3;\n      } else if (u8a[i] >= 0xEE && u8a[i] <= 0xEF)\n      /* EE..EF 80..BF 80..BF */\n      {\n        if (i + 2 < len)\n          /* Expect a 2nd and 3rd byte */\n          {\n            if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0xBF) {\n              // *message = \"After a first byte between EE and EF, expecting 2nd byte between 80 and BF.\";\n              // *faulty_bytes = 2;\n              return false;\n            }\n\n            if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {\n              // *message = \"After a first byte between EE and EF, expecting 3rd byte between 80 and BF.\";\n              // *faulty_bytes = 3;\n              return false;\n            }\n          } else {\n          // *message = \"After a first byte between EE and EF, two following bytes.\";\n          // *faulty_bytes = 1;\n          return false;\n        }\n\n        i += 3;\n      } else if (u8a[i] === 0xF0)\n      /* F0 90..BF 80..BF 80..BF */\n      {\n        if (i + 3 < len)\n          /* Expect a 2nd, 3rd 3th byte */\n          {\n            if (u8a[i + 1] < 0x90 || u8a[i + 1] > 0xBF) {\n              // *message = \"After a first byte of F0, expecting 2nd byte between 90 and BF.\";\n              // *faulty_bytes = 2;\n              return false;\n            }\n\n            if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {\n              // *message = \"After a first byte of F0, expecting 3rd byte between 80 and BF.\";\n              // *faulty_bytes = 3;\n              return false;\n            }\n\n            if (u8a[i + 3] < 0x80 || u8a[i + 3] > 0xBF) {\n              // *message = \"After a first byte of F0, expecting 4th byte between 80 and BF.\";\n              // *faulty_bytes = 4;\n              return false;\n            }\n          } else {\n          // *message = \"After a first byte of F0, expecting three following bytes.\";\n          // *faulty_bytes = 1;\n          return false;\n        }\n\n        i += 4;\n      } else if (u8a[i] >= 0xF1 && u8a[i] <= 0xF3)\n      /* F1..F3 80..BF 80..BF 80..BF */\n      {\n        if (i + 3 < len)\n          /* Expect a 2nd, 3rd 3th byte */\n          {\n            if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0xBF) {\n              // *message = \"After a first byte of F1, F2, or F3, expecting a 2nd byte between 80 and BF.\";\n              // *faulty_bytes = 2;\n              return false;\n            }\n\n            if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {\n              // *message = \"After a first byte of F1, F2, or F3, expecting a 3rd byte between 80 and BF.\";\n              // *faulty_bytes = 3;\n              return false;\n            }\n\n            if (u8a[i + 3] < 0x80 || u8a[i + 3] > 0xBF) {\n              // *message = \"After a first byte of F1, F2, or F3, expecting a 4th byte between 80 and BF.\";\n              // *faulty_bytes = 4;\n              return false;\n            }\n          } else {\n          // *message = \"After a first byte of F1, F2, or F3, expecting three following bytes.\";\n          // *faulty_bytes = 1;\n          return false;\n        }\n\n        i += 4;\n      } else if (u8a[i] === 0xF4)\n      /* F4 80..8F 80..BF 80..BF */\n      {\n        if (i + 3 < len)\n          /* Expect a 2nd, 3rd 3th byte */\n          {\n            if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0x8F) {\n              // *message = \"After a first byte of F4, expecting 2nd byte between 80 and 8F.\";\n              // *faulty_bytes = 2;\n              return false;\n            }\n\n            if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {\n              // *message = \"After a first byte of F4, expecting 3rd byte between 80 and BF.\";\n              // *faulty_bytes = 3;\n              return false;\n            }\n\n            if (u8a[i + 3] < 0x80 || u8a[i + 3] > 0xBF) {\n              // *message = \"After a first byte of F4, expecting 4th byte between 80 and BF.\";\n              // *faulty_bytes = 4;\n              return false;\n            }\n          } else {\n          // *message = \"After a first byte of F4, expecting three following bytes.\";\n          // *faulty_bytes = 1;\n          return false;\n        }\n\n        i += 4;\n      } else {\n      // *message = \"Expecting bytes in the following ranges: 00..7F C2..F4.\";\n      // *faulty_bytes = 1;\n      return false;\n    }\n  }\n\n  return true;\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/util/is/utf8.js"],"names":["u8aToU8a","isString","isUtf8","value","u8a","len","length","i"],"mappings":"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","sourcesContent":["// Copyright 2017-2021 @polkadot/util authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n// Adapted from https://github.com/JulienPalard/is_utf8/blob/master/is_utf8.c\nimport { u8aToU8a } from \"../u8a/toU8a.js\";\nimport { isString } from \"./string.js\";\n/**\n * @name isUtf8\n * @summary Tests if the input is valid Utf8\n * @description\n * Checks to see if the input string or Uint8Array is valid Utf8\n */\n\nexport function isUtf8(value) {\n  if (!value) {\n    return isString(value);\n  }\n\n  const u8a = u8aToU8a(value);\n  const len = u8a.length;\n  let i = 0;\n\n  while (i < len) {\n    if (u8a[i] <= 0x7F)\n      /* 00..7F */\n      {\n        i += 1;\n      } else if (u8a[i] >= 0xC2 && u8a[i] <= 0xDF)\n      /* C2..DF 80..BF */\n      {\n        if (i + 1 < len)\n          /* Expect a 2nd byte */\n          {\n            if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0xBF) {\n              // *message = \"After a first byte between C2 and DF, expecting a 2nd byte between 80 and BF\";\n              // *faulty_bytes = 2;\n              return false;\n            }\n          } else {\n          // *message = \"After a first byte between C2 and DF, expecting a 2nd byte.\";\n          // *faulty_bytes = 1;\n          return false;\n        }\n\n        i += 2;\n      } else if (u8a[i] === 0xE0)\n      /* E0 A0..BF 80..BF */\n      {\n        if (i + 2 < len)\n          /* Expect a 2nd and 3rd byte */\n          {\n            if (u8a[i + 1] < 0xA0 || u8a[i + 1] > 0xBF) {\n              // *message = \"After a first byte of E0, expecting a 2nd byte between A0 and BF.\";\n              // *faulty_bytes = 2;\n              return false;\n            }\n\n            if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {\n              // *message = \"After a first byte of E0, expecting a 3nd byte between 80 and BF.\";\n              // *faulty_bytes = 3;\n              return false;\n            }\n          } else {\n          // *message = \"After a first byte of E0, expecting two following bytes.\";\n          // *faulty_bytes = 1;\n          return false;\n        }\n\n        i += 3;\n      } else if (u8a[i] >= 0xE1 && u8a[i] <= 0xEC)\n      /* E1..EC 80..BF 80..BF */\n      {\n        if (i + 2 < len)\n          /* Expect a 2nd and 3rd byte */\n          {\n            if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0xBF) {\n              // *message = \"After a first byte between E1 and EC, expecting the 2nd byte between 80 and BF.\";\n              // *faulty_bytes = 2;\n              return false;\n            }\n\n            if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {\n              // *message = \"After a first byte between E1 and EC, expecting the 3rd byte between 80 and BF.\";\n              // *faulty_bytes = 3;\n              return false;\n            }\n          } else {\n          // *message = \"After a first byte between E1 and EC, expecting two following bytes.\";\n          // *faulty_bytes = 1;\n          return false;\n        }\n\n        i += 3;\n      } else if (u8a[i] === 0xED)\n      /* ED 80..9F 80..BF */\n      {\n        if (i + 2 < len)\n          /* Expect a 2nd and 3rd byte */\n          {\n            if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0x9F) {\n              // *message = \"After a first byte of ED, expecting 2nd byte between 80 and 9F.\";\n              // *faulty_bytes = 2;\n              return false;\n            }\n\n            if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {\n              // *message = \"After a first byte of ED, expecting 3rd byte between 80 and BF.\";\n              // *faulty_bytes = 3;\n              return false;\n            }\n          } else {\n          // *message = \"After a first byte of ED, expecting two following bytes.\";\n          // *faulty_bytes = 1;\n          return false;\n        }\n\n        i += 3;\n      } else if (u8a[i] >= 0xEE && u8a[i] <= 0xEF)\n      /* EE..EF 80..BF 80..BF */\n      {\n        if (i + 2 < len)\n          /* Expect a 2nd and 3rd byte */\n          {\n            if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0xBF) {\n              // *message = \"After a first byte between EE and EF, expecting 2nd byte between 80 and BF.\";\n              // *faulty_bytes = 2;\n              return false;\n            }\n\n            if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {\n              // *message = \"After a first byte between EE and EF, expecting 3rd byte between 80 and BF.\";\n              // *faulty_bytes = 3;\n              return false;\n            }\n          } else {\n          // *message = \"After a first byte between EE and EF, two following bytes.\";\n          // *faulty_bytes = 1;\n          return false;\n        }\n\n        i += 3;\n      } else if (u8a[i] === 0xF0)\n      /* F0 90..BF 80..BF 80..BF */\n      {\n        if (i + 3 < len)\n          /* Expect a 2nd, 3rd 3th byte */\n          {\n            if (u8a[i + 1] < 0x90 || u8a[i + 1] > 0xBF) {\n              // *message = \"After a first byte of F0, expecting 2nd byte between 90 and BF.\";\n              // *faulty_bytes = 2;\n              return false;\n            }\n\n            if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {\n              // *message = \"After a first byte of F0, expecting 3rd byte between 80 and BF.\";\n              // *faulty_bytes = 3;\n              return false;\n            }\n\n            if (u8a[i + 3] < 0x80 || u8a[i + 3] > 0xBF) {\n              // *message = \"After a first byte of F0, expecting 4th byte between 80 and BF.\";\n              // *faulty_bytes = 4;\n              return false;\n            }\n          } else {\n          // *message = \"After a first byte of F0, expecting three following bytes.\";\n          // *faulty_bytes = 1;\n          return false;\n        }\n\n        i += 4;\n      } else if (u8a[i] >= 0xF1 && u8a[i] <= 0xF3)\n      /* F1..F3 80..BF 80..BF 80..BF */\n      {\n        if (i + 3 < len)\n          /* Expect a 2nd, 3rd 3th byte */\n          {\n            if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0xBF) {\n              // *message = \"After a first byte of F1, F2, or F3, expecting a 2nd byte between 80 and BF.\";\n              // *faulty_bytes = 2;\n              return false;\n            }\n\n            if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {\n              // *message = \"After a first byte of F1, F2, or F3, expecting a 3rd byte between 80 and BF.\";\n              // *faulty_bytes = 3;\n              return false;\n            }\n\n            if (u8a[i + 3] < 0x80 || u8a[i + 3] > 0xBF) {\n              // *message = \"After a first byte of F1, F2, or F3, expecting a 4th byte between 80 and BF.\";\n              // *faulty_bytes = 4;\n              return false;\n            }\n          } else {\n          // *message = \"After a first byte of F1, F2, or F3, expecting three following bytes.\";\n          // *faulty_bytes = 1;\n          return false;\n        }\n\n        i += 4;\n      } else if (u8a[i] === 0xF4)\n      /* F4 80..8F 80..BF 80..BF */\n      {\n        if (i + 3 < len)\n          /* Expect a 2nd, 3rd 3th byte */\n          {\n            if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0x8F) {\n              // *message = \"After a first byte of F4, expecting 2nd byte between 80 and 8F.\";\n              // *faulty_bytes = 2;\n              return false;\n            }\n\n            if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {\n              // *message = \"After a first byte of F4, expecting 3rd byte between 80 and BF.\";\n              // *faulty_bytes = 3;\n              return false;\n            }\n\n            if (u8a[i + 3] < 0x80 || u8a[i + 3] > 0xBF) {\n              // *message = \"After a first byte of F4, expecting 4th byte between 80 and BF.\";\n              // *faulty_bytes = 4;\n              return false;\n            }\n          } else {\n          // *message = \"After a first byte of F4, expecting three following bytes.\";\n          // *faulty_bytes = 1;\n          return false;\n        }\n\n        i += 4;\n      } else {\n      // *message = \"Expecting bytes in the following ranges: 00..7F C2..F4.\";\n      // *faulty_bytes = 1;\n      return false;\n    }\n  }\n\n  return true;\n}"]},"metadata":{},"sourceType":"module"}