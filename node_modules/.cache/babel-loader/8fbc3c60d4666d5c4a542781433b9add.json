{"ast":null,"code":"// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { hexToU8a, isHex, isString, isU8a, u8aToU8a } from '@polkadot/util';\nimport { ethereumEncode, isEthereumAddress } from '@polkadot/util-crypto';\nimport { U8aFixed } from \"../codec/U8aFixed.js\";\n/** @internal */\n\nfunction decodeAccountId(value) {\n  if (isU8a(value) || Array.isArray(value)) {\n    return u8aToU8a(value);\n  } else if (isHex(value) || isEthereumAddress(value)) {\n    return hexToU8a(value);\n  } else if (isString(value)) {\n    return u8aToU8a(value);\n  }\n\n  return value;\n}\n/**\n * @name GenericEthereumAccountId\n * @description\n * A wrapper around an Ethereum-compatible AccountId. Since we are dealing with\n * underlying addresses (20 bytes in length), we extend from U8aFixed which is\n * just a Uint8Array wrapper with a fixed length.\n */\n\n\nexport class GenericEthereumAccountId extends U8aFixed {\n  constructor(registry, value = new Uint8Array()) {\n    super(registry, decodeAccountId(value), 160);\n  }\n\n  static encode(value) {\n    return ethereumEncode(value);\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n\n\n  eq(other) {\n    return super.eq(decodeAccountId(other));\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman() {\n    return this.toJSON();\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n\n\n  toJSON() {\n    return this.toString();\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n\n\n  toString() {\n    return GenericEthereumAccountId.encode(this);\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return 'AccountId';\n  }\n\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/types/ethereum/AccountId.js"],"names":["hexToU8a","isHex","isString","isU8a","u8aToU8a","ethereumEncode","isEthereumAddress","U8aFixed","decodeAccountId","value","Array","isArray","GenericEthereumAccountId","constructor","registry","Uint8Array","encode","eq","other","toHuman","toJSON","toString","toRawType"],"mappings":"AAAA;AACA;AACA,SAASA,QAAT,EAAmBC,KAAnB,EAA0BC,QAA1B,EAAoCC,KAApC,EAA2CC,QAA3C,QAA2D,gBAA3D;AACA,SAASC,cAAT,EAAyBC,iBAAzB,QAAkD,uBAAlD;AACA,SAASC,QAAT,QAAyB,sBAAzB;AACA;;AAEA,SAASC,eAAT,CAAyBC,KAAzB,EAAgC;AAC9B,MAAIN,KAAK,CAACM,KAAD,CAAL,IAAgBC,KAAK,CAACC,OAAN,CAAcF,KAAd,CAApB,EAA0C;AACxC,WAAOL,QAAQ,CAACK,KAAD,CAAf;AACD,GAFD,MAEO,IAAIR,KAAK,CAACQ,KAAD,CAAL,IAAgBH,iBAAiB,CAACG,KAAD,CAArC,EAA8C;AACnD,WAAOT,QAAQ,CAACS,KAAD,CAAf;AACD,GAFM,MAEA,IAAIP,QAAQ,CAACO,KAAD,CAAZ,EAAqB;AAC1B,WAAOL,QAAQ,CAACK,KAAD,CAAf;AACD;;AAED,SAAOA,KAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,OAAO,MAAMG,wBAAN,SAAuCL,QAAvC,CAAgD;AACrDM,EAAAA,WAAW,CAACC,QAAD,EAAWL,KAAK,GAAG,IAAIM,UAAJ,EAAnB,EAAqC;AAC9C,UAAMD,QAAN,EAAgBN,eAAe,CAACC,KAAD,CAA/B,EAAwC,GAAxC;AACD;;AAEY,SAANO,MAAM,CAACP,KAAD,EAAQ;AACnB,WAAOJ,cAAc,CAACI,KAAD,CAArB;AACD;AACD;AACF;AACA;;;AAGEQ,EAAAA,EAAE,CAACC,KAAD,EAAQ;AACR,WAAO,MAAMD,EAAN,CAAST,eAAe,CAACU,KAAD,CAAxB,CAAP;AACD;AACD;AACF;AACA;;;AAGEC,EAAAA,OAAO,GAAG;AACR,WAAO,KAAKC,MAAL,EAAP;AACD;AACD;AACF;AACA;;;AAGEA,EAAAA,MAAM,GAAG;AACP,WAAO,KAAKC,QAAL,EAAP;AACD;AACD;AACF;AACA;;;AAGEA,EAAAA,QAAQ,GAAG;AACT,WAAOT,wBAAwB,CAACI,MAAzB,CAAgC,IAAhC,CAAP;AACD;AACD;AACF;AACA;;;AAGEM,EAAAA,SAAS,GAAG;AACV,WAAO,WAAP;AACD;;AA/CoD","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { hexToU8a, isHex, isString, isU8a, u8aToU8a } from '@polkadot/util';\nimport { ethereumEncode, isEthereumAddress } from '@polkadot/util-crypto';\nimport { U8aFixed } from \"../codec/U8aFixed.js\";\n/** @internal */\n\nfunction decodeAccountId(value) {\n  if (isU8a(value) || Array.isArray(value)) {\n    return u8aToU8a(value);\n  } else if (isHex(value) || isEthereumAddress(value)) {\n    return hexToU8a(value);\n  } else if (isString(value)) {\n    return u8aToU8a(value);\n  }\n\n  return value;\n}\n/**\n * @name GenericEthereumAccountId\n * @description\n * A wrapper around an Ethereum-compatible AccountId. Since we are dealing with\n * underlying addresses (20 bytes in length), we extend from U8aFixed which is\n * just a Uint8Array wrapper with a fixed length.\n */\n\n\nexport class GenericEthereumAccountId extends U8aFixed {\n  constructor(registry, value = new Uint8Array()) {\n    super(registry, decodeAccountId(value), 160);\n  }\n\n  static encode(value) {\n    return ethereumEncode(value);\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n\n\n  eq(other) {\n    return super.eq(decodeAccountId(other));\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman() {\n    return this.toJSON();\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n\n\n  toJSON() {\n    return this.toString();\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n\n\n  toString() {\n    return GenericEthereumAccountId.encode(this);\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return 'AccountId';\n  }\n\n}"]},"metadata":{},"sourceType":"module"}