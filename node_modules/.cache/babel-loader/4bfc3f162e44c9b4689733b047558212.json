{"ast":null,"code":"var typeforce = require('typeforce');\n\nvar types = require('./types');\n\nvar BigInteger = require('bigi');\n\nvar ECSignature = require('./ecsignature');\n\nvar crypto = require('./crypto');\n\nvar ecurve = require('ecurve');\n\nvar secp256k1 = ecurve.getCurveByName('secp256k1');\n\nvar deterministicGenerateK = require('./rfc6979').deterministicGenerateK;\n\nvar USE_RFC6979 = true;\n\nfunction sign(h, x) {\n  typeforce(types.tuple(types.BufferN(32), types.BigInt), arguments);\n  var n = secp256k1.n;\n  var G = secp256k1.G;\n\n  if (x.compareTo(BigInteger.ZERO) <= 0 || x.compareTo(n) >= 0) {\n    throw new Error('Private key x not in range');\n  }\n\n  var P = G.multiply(x);\n  var r, s;\n\n  function signWithK(k) {\n    var R = G.multiply(k); // sign chosen so that the Y coordinate of R has Jacobi symbol 1\n\n    if (jacobi(R.affineY, secp256k1.p) != 1) {\n      k = n.subtract(k);\n      R = G.multiply(k);\n    }\n\n    r = R.affineX.mod(n);\n    var BP = toCompressedPoint(P);\n    var Br = r.toBuffer(32);\n    var eh = crypto.sha256(Buffer.concat([Br, BP, h]));\n    var e = BigInteger.fromBuffer(eh).mod(n);\n    s = k.add(e.multiply(x)).mod(n);\n    return true;\n  }\n\n  if (USE_RFC6979) {\n    deterministicGenerateK(h, x.toBuffer(32), signWithK, Buffer.from('Schnorr+SHA256  ', 'ascii'));\n  } else {\n    var kh = crypto.sha256(Buffer.concat([x.toBuffer(32), h]));\n    var k = BigInteger.fromBuffer(kh).mod(n);\n    signWithK(k);\n  }\n\n  return new ECSignature(r, s);\n} // https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/2019-05-15-schnorr.md#signature-verification-algorithm\n\n\nfunction verify(h, signature, P) {\n  typeforce(types.tuple(types.BufferN(32), types.ECSignature, types.ECPoint), arguments);\n  var n = secp256k1.n;\n  var G = secp256k1.G;\n  var r = signature.r;\n  var s = signature.s; // 1. Fail if point P is not actually on the curve, or if it is the point at infinity.\n\n  if (!secp256k1.isOnCurve(P)) return false;\n  if (secp256k1.isInfinity(P)) return false; // 2. Fail if r >= p, where p is the field size used in secp256k1.\n\n  if (r.compareTo(secp256k1.p) >= 0) return false; // 3. Fail if s >= n, where n is the order of the secp256k1 curve.\n\n  if (s.compareTo(n) >= 0) return false; // 4. Let BP be the 33-byte encoding of P as a compressed point.\n\n  var BP = toCompressedPoint(P); // 5. Let Br be the 32-byte encoding of r as an unsigned big-endian 256-bit integer.\n\n  var Br = r.toBuffer(32); // 6. Compute integer e = H(Br | BP | h) mod n.\n\n  var h = crypto.sha256(Buffer.concat([Br, BP, h]));\n  var e = BigInteger.fromBuffer(h).mod(n); // 7. Compute elliptic curve point R' = sG + (-e)P, where G is the secp256k1 generator point.\n\n  var R = G.multiply(s).add(P.multiply(n.subtract(e))); // 8. Fail if R' is the point at infinity.\n\n  if (secp256k1.isInfinity(R)) return false; // 9. Fail if the X coordinate of R' is not equal to r.\n\n  if (R.affineX.compareTo(r) != 0) return false; // 10. Fail if the Jacobi symbol of the Y coordinate of R' is not 1.\n\n  if (jacobi(R.affineY, secp256k1.p) != 1) return false; // 11. Otherwise, the signature is valid\n\n  return true;\n}\n\nfunction jacobi(a, p) {\n  return a.modPow(p.subtract(BigInteger.ONE).divide(BigInteger.valueOf(2)), p).intValue();\n}\n\nfunction toCompressedPoint(P) {\n  typeforce(types.tuple(types.ECPoint), arguments);\n  return Buffer.concat([Buffer.from([P.affineY.isEven() ? 0x02 : 0x03]), P.affineX.toBuffer(32)]);\n}\n\nfunction fromCompressedPoint(buffer) {\n  typeforce(types.tuple(types.BufferN(33)), arguments);\n  if (buffer.length !== 33) throw new Error('Invalid length of buffer');\n  if (buffer[0] !== 0x2 && buffer[0] !== 0x3) throw new Error('Invalid signum byte');\n  var isOdd = buffer[0] === 0x3;\n  var x = BigInteger.fromBuffer(buffer.slice(1, 33));\n  return secp256k1.pointFromX(isOdd, x);\n}\n\nmodule.exports = {\n  deterministicGenerateK: deterministicGenerateK,\n  sign: sign,\n  verify: verify,\n  jacobi: jacobi,\n  toCompressedPoint: toCompressedPoint,\n  fromCompressedPoint: fromCompressedPoint,\n  // TODO: remove\n  __curve: secp256k1,\n  __useRFC6979: function (use) {\n    USE_RFC6979 = use;\n  }\n};","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@psf/bitcoincashjs-lib/src/schnorr.js"],"names":["typeforce","require","types","BigInteger","ECSignature","crypto","ecurve","secp256k1","getCurveByName","deterministicGenerateK","USE_RFC6979","sign","h","x","tuple","BufferN","BigInt","arguments","n","G","compareTo","ZERO","Error","P","multiply","r","s","signWithK","k","R","jacobi","affineY","p","subtract","affineX","mod","BP","toCompressedPoint","Br","toBuffer","eh","sha256","Buffer","concat","e","fromBuffer","add","from","kh","verify","signature","ECPoint","isOnCurve","isInfinity","a","modPow","ONE","divide","valueOf","intValue","isEven","fromCompressedPoint","buffer","length","isOdd","slice","pointFromX","module","exports","__curve","__useRFC6979","use"],"mappings":"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","sourcesContent":["var typeforce = require('typeforce')\nvar types = require('./types')\n\nvar BigInteger = require('bigi')\nvar ECSignature = require('./ecsignature')\nvar crypto = require('./crypto')\n\nvar ecurve = require('ecurve')\nvar secp256k1 = ecurve.getCurveByName('secp256k1')\n\nvar deterministicGenerateK = require('./rfc6979').deterministicGenerateK\n\nvar USE_RFC6979 = true\nfunction sign(h, x) {\n  typeforce(types.tuple(\n    types.BufferN(32),\n    types.BigInt\n  ), arguments)\n\n  var n = secp256k1.n\n  var G = secp256k1.G\n\n  if(x.compareTo(BigInteger.ZERO) <= 0 || x.compareTo(n) >= 0){\n    throw new Error('Private key x not in range')\n  }\n\n  var P = G.multiply(x);\n\n  var r, s\n  function signWithK(k){\n    var R = G.multiply(k)\n\n    // sign chosen so that the Y coordinate of R has Jacobi symbol 1\n    if(jacobi(R.affineY, secp256k1.p) != 1){\n      k = n.subtract(k)\n      R = G.multiply(k)\n    }\n\n    r = R.affineX.mod(n)\n\n    var BP = toCompressedPoint(P)\n    var Br = r.toBuffer(32)\n\n    var eh = crypto.sha256(Buffer.concat([Br, BP, h]))\n    var e = BigInteger.fromBuffer(eh).mod(n)\n\n    s = k.add(e.multiply(x)).mod(n)\n\n    return true\n  }\n\n  if(USE_RFC6979){\n    deterministicGenerateK(h, x.toBuffer(32), signWithK, Buffer.from('Schnorr+SHA256  ', 'ascii'))\n  } else {\n    var kh = crypto.sha256(Buffer.concat([x.toBuffer(32), h]))\n    var k = BigInteger.fromBuffer(kh).mod(n)\n    signWithK(k)\n  }\n\n  return new ECSignature(r, s)\n}\n\n// https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/2019-05-15-schnorr.md#signature-verification-algorithm\nfunction verify (h, signature, P) {\n  typeforce(types.tuple(\n    types.BufferN(32),\n    types.ECSignature,\n    types.ECPoint\n  ), arguments)\n\n  var n = secp256k1.n\n  var G = secp256k1.G\n\n  var r = signature.r\n  var s = signature.s\n\n  // 1. Fail if point P is not actually on the curve, or if it is the point at infinity.\n  if(!secp256k1.isOnCurve(P)) return false\n  if(secp256k1.isInfinity(P)) return false\n\n  // 2. Fail if r >= p, where p is the field size used in secp256k1.\n  if(r.compareTo(secp256k1.p) >= 0) return false\n\n  // 3. Fail if s >= n, where n is the order of the secp256k1 curve.\n  if(s.compareTo(n) >= 0) return false\n\n  // 4. Let BP be the 33-byte encoding of P as a compressed point.\n  var BP = toCompressedPoint(P)\n\n  // 5. Let Br be the 32-byte encoding of r as an unsigned big-endian 256-bit integer.\n  var Br = r.toBuffer(32)\n\n  // 6. Compute integer e = H(Br | BP | h) mod n.\n  var h = crypto.sha256(Buffer.concat([Br, BP, h]))\n  var e = BigInteger.fromBuffer(h).mod(n)\n\n  // 7. Compute elliptic curve point R' = sG + (-e)P, where G is the secp256k1 generator point.\n  var R = G.multiply(s).add(P.multiply(n.subtract(e)))\n\n  // 8. Fail if R' is the point at infinity.\n  if(secp256k1.isInfinity(R)) return false\n\n  // 9. Fail if the X coordinate of R' is not equal to r.\n  if(R.affineX.compareTo(r) != 0) return false\n\n  // 10. Fail if the Jacobi symbol of the Y coordinate of R' is not 1.\n  if(jacobi(R.affineY, secp256k1.p) != 1) return false\n\n  // 11. Otherwise, the signature is valid\n  return true\n}\n\nfunction jacobi(a, p){\n  return a.modPow(p.subtract(BigInteger.ONE).divide(BigInteger.valueOf(2)), p).intValue();\n}\n\nfunction toCompressedPoint(P){\n  typeforce(types.tuple(\n    types.ECPoint\n  ), arguments)\n\n  return Buffer.concat([Buffer.from([P.affineY.isEven() ? 0x02 : 0x03]), P.affineX.toBuffer(32)]);\n}\n\nfunction fromCompressedPoint(buffer){\n  typeforce(types.tuple(\n    types.BufferN(33)\n  ), arguments)\n\n  if(buffer.length !== 33) throw new Error('Invalid length of buffer')\n  if(buffer[0] !== 0x2 && buffer[0] !== 0x3) throw new Error('Invalid signum byte')\n\n  var isOdd = buffer[0] === 0x3\n  var x = BigInteger.fromBuffer(buffer.slice(1, 33))\n\n  return secp256k1.pointFromX(isOdd, x)\n}\n\nmodule.exports = {\n  deterministicGenerateK: deterministicGenerateK,\n  sign: sign,\n  verify: verify,\n\n  jacobi: jacobi,\n  toCompressedPoint: toCompressedPoint,\n  fromCompressedPoint: fromCompressedPoint,\n\n  // TODO: remove\n  __curve: secp256k1,\n  __useRFC6979: function(use){\n    USE_RFC6979 = use\n  }\n}\n"]},"metadata":{},"sourceType":"script"}