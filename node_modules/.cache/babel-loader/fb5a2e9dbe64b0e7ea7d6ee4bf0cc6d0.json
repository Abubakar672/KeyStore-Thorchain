{"ast":null,"code":"import _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\"; // Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\nimport { compactFromU8a, compactToU8a, isHex, isObject, isU8a, logger, stringify, u8aConcat, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { AbstractArray } from \"./AbstractArray.js\";\nimport { Enum } from \"./Enum.js\";\nimport { Struct } from \"./Struct.js\";\nimport { compareMap, decodeU8a, sortMap, typeToConstructor } from \"./utils/index.js\";\nconst l = logger('Map');\n/** @internal */\n\nfunction decodeMapFromU8a(registry, KeyClass, ValClass, u8a) {\n  const output = new Map();\n  const [offset, length] = compactFromU8a(u8a);\n  const types = [];\n\n  for (let i = 0; i < length.toNumber(); i++) {\n    types.push(KeyClass, ValClass);\n  }\n\n  const values = decodeU8a(registry, u8a.subarray(offset), types);\n\n  for (let i = 0; i < values.length; i += 2) {\n    output.set(values[i], values[i + 1]);\n  }\n\n  return output;\n}\n/** @internal */\n\n\nfunction decodeMapFromMap(registry, KeyClass, ValClass, value) {\n  const output = new Map();\n  value.forEach((val, key) => {\n    const isComplex = KeyClass.prototype instanceof AbstractArray || KeyClass.prototype instanceof Struct || KeyClass.prototype instanceof Enum;\n\n    try {\n      output.set(key instanceof KeyClass ? key : new KeyClass(registry, isComplex ? JSON.parse(key) : key), val instanceof ValClass ? val : new ValClass(registry, val));\n    } catch (error) {\n      l.error('Failed to decode key or value:', error.message);\n      throw error;\n    }\n  });\n  return output;\n}\n/**\n * Decode input to pass into constructor.\n *\n * @param KeyClass - Type of the map key\n * @param ValClass - Type of the map value\n * @param value - Value to decode, one of:\n * - null\n * - undefined\n * - hex\n * - Uint8Array\n * - Map<any, any>, where both key and value types are either\n *   constructors or decodeable values for their types.\n * @param jsonMap\n * @internal\n */\n\n\nfunction decodeMap(registry, keyType, valType, value) {\n  const KeyClass = typeToConstructor(registry, keyType);\n  const ValClass = typeToConstructor(registry, valType);\n\n  if (!value) {\n    return new Map();\n  } else if (isU8a(value) || isHex(value)) {\n    return decodeMapFromU8a(registry, KeyClass, ValClass, u8aToU8a(value));\n  } else if (value instanceof Map) {\n    return decodeMapFromMap(registry, KeyClass, ValClass, value);\n  } else if (isObject(value)) {\n    return decodeMapFromMap(registry, KeyClass, ValClass, new Map(Object.entries(value)));\n  }\n\n  throw new Error('Map: cannot decode type');\n}\n\nvar _KeyClass = /*#__PURE__*/_classPrivateFieldLooseKey(\"KeyClass\");\n\nvar _ValClass = /*#__PURE__*/_classPrivateFieldLooseKey(\"ValClass\");\n\nvar _type = /*#__PURE__*/_classPrivateFieldLooseKey(\"type\");\n\nexport class CodecMap extends Map {\n  constructor(registry, keyType, valType, rawValue, type = 'HashMap') {\n    const decoded = decodeMap(registry, keyType, valType, rawValue);\n    super(type === 'BTreeMap' ? sortMap(decoded) : decoded);\n    this.registry = void 0;\n    this.createdAtHash = void 0;\n    Object.defineProperty(this, _KeyClass, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _ValClass, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _type, {\n      writable: true,\n      value: void 0\n    });\n    this.registry = registry;\n    _classPrivateFieldLooseBase(this, _KeyClass)[_KeyClass] = typeToConstructor(registry, keyType);\n    _classPrivateFieldLooseBase(this, _ValClass)[_ValClass] = typeToConstructor(registry, valType);\n    _classPrivateFieldLooseBase(this, _type)[_type] = type;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    let len = compactToU8a(this.size).length;\n    this.forEach((v, k) => {\n      len += v.encodedLength + k.encodedLength;\n    });\n    return len;\n  }\n  /**\n   * @description Returns a hash of the value\n   */\n\n\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Checks if the value is an empty value\n   */\n\n\n  get isEmpty() {\n    return this.size === 0;\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n\n\n  eq(other) {\n    return compareMap(this, other);\n  }\n  /**\n   * @description Returns a hex string representation of the value. isLe returns a LE (number-only) representation\n   */\n\n\n  toHex() {\n    return u8aToHex(this.toU8a());\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman(isExtended) {\n    const json = {};\n    this.forEach((v, k) => {\n      json[k.toString()] = v.toHuman(isExtended);\n    });\n    return json;\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n\n\n  toJSON() {\n    const json = {};\n    this.forEach((v, k) => {\n      json[k.toString()] = v.toJSON();\n    });\n    return json;\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return `${_classPrivateFieldLooseBase(this, _type)[_type]}<${this.registry.getClassName(_classPrivateFieldLooseBase(this, _KeyClass)[_KeyClass]) || new (_classPrivateFieldLooseBase(this, _KeyClass)[_KeyClass])(this.registry).toRawType()},${this.registry.getClassName(_classPrivateFieldLooseBase(this, _ValClass)[_ValClass]) || new (_classPrivateFieldLooseBase(this, _ValClass)[_ValClass])(this.registry).toRawType()}>`;\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n\n\n  toString() {\n    return stringify(this.toJSON());\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    const encoded = new Array();\n\n    if (!isBare) {\n      encoded.push(compactToU8a(this.size));\n    }\n\n    this.forEach((v, k) => {\n      encoded.push(k.toU8a(isBare), v.toU8a(isBare));\n    });\n    return u8aConcat(...encoded);\n  }\n\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/types/codec/Map.js"],"names":["_classPrivateFieldLooseBase","_classPrivateFieldLooseKey","compactFromU8a","compactToU8a","isHex","isObject","isU8a","logger","stringify","u8aConcat","u8aToHex","u8aToU8a","AbstractArray","Enum","Struct","compareMap","decodeU8a","sortMap","typeToConstructor","l","decodeMapFromU8a","registry","KeyClass","ValClass","u8a","output","Map","offset","length","types","i","toNumber","push","values","subarray","set","decodeMapFromMap","value","forEach","val","key","isComplex","prototype","JSON","parse","error","message","decodeMap","keyType","valType","Object","entries","Error","_KeyClass","_ValClass","_type","CodecMap","constructor","rawValue","type","decoded","createdAtHash","defineProperty","writable","encodedLength","len","size","v","k","hash","toU8a","isEmpty","eq","other","toHex","toHuman","isExtended","json","toString","toJSON","toRawType","getClassName","isBare","encoded","Array"],"mappings":"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","sourcesContent":["import _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { compactFromU8a, compactToU8a, isHex, isObject, isU8a, logger, stringify, u8aConcat, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { AbstractArray } from \"./AbstractArray.js\";\nimport { Enum } from \"./Enum.js\";\nimport { Struct } from \"./Struct.js\";\nimport { compareMap, decodeU8a, sortMap, typeToConstructor } from \"./utils/index.js\";\nconst l = logger('Map');\n/** @internal */\n\nfunction decodeMapFromU8a(registry, KeyClass, ValClass, u8a) {\n  const output = new Map();\n  const [offset, length] = compactFromU8a(u8a);\n  const types = [];\n\n  for (let i = 0; i < length.toNumber(); i++) {\n    types.push(KeyClass, ValClass);\n  }\n\n  const values = decodeU8a(registry, u8a.subarray(offset), types);\n\n  for (let i = 0; i < values.length; i += 2) {\n    output.set(values[i], values[i + 1]);\n  }\n\n  return output;\n}\n/** @internal */\n\n\nfunction decodeMapFromMap(registry, KeyClass, ValClass, value) {\n  const output = new Map();\n  value.forEach((val, key) => {\n    const isComplex = KeyClass.prototype instanceof AbstractArray || KeyClass.prototype instanceof Struct || KeyClass.prototype instanceof Enum;\n\n    try {\n      output.set(key instanceof KeyClass ? key : new KeyClass(registry, isComplex ? JSON.parse(key) : key), val instanceof ValClass ? val : new ValClass(registry, val));\n    } catch (error) {\n      l.error('Failed to decode key or value:', error.message);\n      throw error;\n    }\n  });\n  return output;\n}\n/**\n * Decode input to pass into constructor.\n *\n * @param KeyClass - Type of the map key\n * @param ValClass - Type of the map value\n * @param value - Value to decode, one of:\n * - null\n * - undefined\n * - hex\n * - Uint8Array\n * - Map<any, any>, where both key and value types are either\n *   constructors or decodeable values for their types.\n * @param jsonMap\n * @internal\n */\n\n\nfunction decodeMap(registry, keyType, valType, value) {\n  const KeyClass = typeToConstructor(registry, keyType);\n  const ValClass = typeToConstructor(registry, valType);\n\n  if (!value) {\n    return new Map();\n  } else if (isU8a(value) || isHex(value)) {\n    return decodeMapFromU8a(registry, KeyClass, ValClass, u8aToU8a(value));\n  } else if (value instanceof Map) {\n    return decodeMapFromMap(registry, KeyClass, ValClass, value);\n  } else if (isObject(value)) {\n    return decodeMapFromMap(registry, KeyClass, ValClass, new Map(Object.entries(value)));\n  }\n\n  throw new Error('Map: cannot decode type');\n}\n\nvar _KeyClass = /*#__PURE__*/_classPrivateFieldLooseKey(\"KeyClass\");\n\nvar _ValClass = /*#__PURE__*/_classPrivateFieldLooseKey(\"ValClass\");\n\nvar _type = /*#__PURE__*/_classPrivateFieldLooseKey(\"type\");\n\nexport class CodecMap extends Map {\n  constructor(registry, keyType, valType, rawValue, type = 'HashMap') {\n    const decoded = decodeMap(registry, keyType, valType, rawValue);\n    super(type === 'BTreeMap' ? sortMap(decoded) : decoded);\n    this.registry = void 0;\n    this.createdAtHash = void 0;\n    Object.defineProperty(this, _KeyClass, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _ValClass, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _type, {\n      writable: true,\n      value: void 0\n    });\n    this.registry = registry;\n    _classPrivateFieldLooseBase(this, _KeyClass)[_KeyClass] = typeToConstructor(registry, keyType);\n    _classPrivateFieldLooseBase(this, _ValClass)[_ValClass] = typeToConstructor(registry, valType);\n    _classPrivateFieldLooseBase(this, _type)[_type] = type;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    let len = compactToU8a(this.size).length;\n    this.forEach((v, k) => {\n      len += v.encodedLength + k.encodedLength;\n    });\n    return len;\n  }\n  /**\n   * @description Returns a hash of the value\n   */\n\n\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Checks if the value is an empty value\n   */\n\n\n  get isEmpty() {\n    return this.size === 0;\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n\n\n  eq(other) {\n    return compareMap(this, other);\n  }\n  /**\n   * @description Returns a hex string representation of the value. isLe returns a LE (number-only) representation\n   */\n\n\n  toHex() {\n    return u8aToHex(this.toU8a());\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman(isExtended) {\n    const json = {};\n    this.forEach((v, k) => {\n      json[k.toString()] = v.toHuman(isExtended);\n    });\n    return json;\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n\n\n  toJSON() {\n    const json = {};\n    this.forEach((v, k) => {\n      json[k.toString()] = v.toJSON();\n    });\n    return json;\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return `${_classPrivateFieldLooseBase(this, _type)[_type]}<${this.registry.getClassName(_classPrivateFieldLooseBase(this, _KeyClass)[_KeyClass]) || new (_classPrivateFieldLooseBase(this, _KeyClass)[_KeyClass])(this.registry).toRawType()},${this.registry.getClassName(_classPrivateFieldLooseBase(this, _ValClass)[_ValClass]) || new (_classPrivateFieldLooseBase(this, _ValClass)[_ValClass])(this.registry).toRawType()}>`;\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n\n\n  toString() {\n    return stringify(this.toJSON());\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    const encoded = new Array();\n\n    if (!isBare) {\n      encoded.push(compactToU8a(this.size));\n    }\n\n    this.forEach((v, k) => {\n      encoded.push(k.toU8a(isBare), v.toU8a(isBare));\n    });\n    return u8aConcat(...encoded);\n  }\n\n}"]},"metadata":{},"sourceType":"module"}