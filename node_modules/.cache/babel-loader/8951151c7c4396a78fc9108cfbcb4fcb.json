{"ast":null,"code":"// Copyright 2017-2021 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, bnToU8a, stringToU8a, u8aConcat } from '@polkadot/util';\nimport { hmacSha512 } from \"../../hmac/index.js\";\nimport { secp256k1KeypairFromSeed, secp256k1PrivateKeyTweakAdd } from \"../../secp256k1/index.js\";\nimport { HARDENED, hdValidatePath } from \"../validatePath.js\";\nconst MASTER_SECRET = stringToU8a('Bitcoin seed');\n\nfunction createCoded(secretKey, chainCode) {\n  return {\n    chainCode,\n    publicKey: secp256k1KeypairFromSeed(secretKey).publicKey,\n    secretKey\n  };\n}\n\nfunction deriveChild(hd, index) {\n  const indexBuffer = bnToU8a(index, {\n    bitLength: 32,\n    isLe: false\n  });\n  const data = index >= HARDENED ? u8aConcat(new Uint8Array(1), hd.secretKey, indexBuffer) : u8aConcat(hd.publicKey, indexBuffer);\n\n  try {\n    const I = hmacSha512(hd.chainCode, data);\n    return createCoded(secp256k1PrivateKeyTweakAdd(hd.secretKey, I.slice(0, 32)), I.slice(32));\n  } catch (err) {\n    // In case parse256(IL) >= n or ki == 0, proceed with the next value for i\n    return deriveChild(hd, index + 1);\n  }\n}\n\nexport function hdEthereum(seed, path = '') {\n  const I = hmacSha512(MASTER_SECRET, seed);\n  const hd = createCoded(I.slice(0, 32), I.slice(32));\n\n  if (!path || path === 'm' || path === 'M' || path === \"m'\" || path === \"M'\") {\n    return hd;\n  }\n\n  assert(hdValidatePath(path), 'Invalid derivation path');\n  return path.split('/').slice(1).reduce((hd, c) => deriveChild(hd, parseInt(c, 10) + (c.length > 1 && c.endsWith(\"'\") ? HARDENED : 0)), hd);\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/util-crypto/hd/ethereum/index.js"],"names":["assert","bnToU8a","stringToU8a","u8aConcat","hmacSha512","secp256k1KeypairFromSeed","secp256k1PrivateKeyTweakAdd","HARDENED","hdValidatePath","MASTER_SECRET","createCoded","secretKey","chainCode","publicKey","deriveChild","hd","index","indexBuffer","bitLength","isLe","data","Uint8Array","I","slice","err","hdEthereum","seed","path","split","reduce","c","parseInt","length","endsWith"],"mappings":"AAAA;AACA;AACA,SAASA,MAAT,EAAiBC,OAAjB,EAA0BC,WAA1B,EAAuCC,SAAvC,QAAwD,gBAAxD;AACA,SAASC,UAAT,QAA2B,qBAA3B;AACA,SAASC,wBAAT,EAAmCC,2BAAnC,QAAsE,0BAAtE;AACA,SAASC,QAAT,EAAmBC,cAAnB,QAAyC,oBAAzC;AACA,MAAMC,aAAa,GAAGP,WAAW,CAAC,cAAD,CAAjC;;AAEA,SAASQ,WAAT,CAAqBC,SAArB,EAAgCC,SAAhC,EAA2C;AACzC,SAAO;AACLA,IAAAA,SADK;AAELC,IAAAA,SAAS,EAAER,wBAAwB,CAACM,SAAD,CAAxB,CAAoCE,SAF1C;AAGLF,IAAAA;AAHK,GAAP;AAKD;;AAED,SAASG,WAAT,CAAqBC,EAArB,EAAyBC,KAAzB,EAAgC;AAC9B,QAAMC,WAAW,GAAGhB,OAAO,CAACe,KAAD,EAAQ;AACjCE,IAAAA,SAAS,EAAE,EADsB;AAEjCC,IAAAA,IAAI,EAAE;AAF2B,GAAR,CAA3B;AAIA,QAAMC,IAAI,GAAGJ,KAAK,IAAIT,QAAT,GAAoBJ,SAAS,CAAC,IAAIkB,UAAJ,CAAe,CAAf,CAAD,EAAoBN,EAAE,CAACJ,SAAvB,EAAkCM,WAAlC,CAA7B,GAA8Ed,SAAS,CAACY,EAAE,CAACF,SAAJ,EAAeI,WAAf,CAApG;;AAEA,MAAI;AACF,UAAMK,CAAC,GAAGlB,UAAU,CAACW,EAAE,CAACH,SAAJ,EAAeQ,IAAf,CAApB;AACA,WAAOV,WAAW,CAACJ,2BAA2B,CAACS,EAAE,CAACJ,SAAJ,EAAeW,CAAC,CAACC,KAAF,CAAQ,CAAR,EAAW,EAAX,CAAf,CAA5B,EAA4DD,CAAC,CAACC,KAAF,CAAQ,EAAR,CAA5D,CAAlB;AACD,GAHD,CAGE,OAAOC,GAAP,EAAY;AACZ;AACA,WAAOV,WAAW,CAACC,EAAD,EAAKC,KAAK,GAAG,CAAb,CAAlB;AACD;AACF;;AAED,OAAO,SAASS,UAAT,CAAoBC,IAApB,EAA0BC,IAAI,GAAG,EAAjC,EAAqC;AAC1C,QAAML,CAAC,GAAGlB,UAAU,CAACK,aAAD,EAAgBiB,IAAhB,CAApB;AACA,QAAMX,EAAE,GAAGL,WAAW,CAACY,CAAC,CAACC,KAAF,CAAQ,CAAR,EAAW,EAAX,CAAD,EAAiBD,CAAC,CAACC,KAAF,CAAQ,EAAR,CAAjB,CAAtB;;AAEA,MAAI,CAACI,IAAD,IAASA,IAAI,KAAK,GAAlB,IAAyBA,IAAI,KAAK,GAAlC,IAAyCA,IAAI,KAAK,IAAlD,IAA0DA,IAAI,KAAK,IAAvE,EAA6E;AAC3E,WAAOZ,EAAP;AACD;;AAEDf,EAAAA,MAAM,CAACQ,cAAc,CAACmB,IAAD,CAAf,EAAuB,yBAAvB,CAAN;AACA,SAAOA,IAAI,CAACC,KAAL,CAAW,GAAX,EAAgBL,KAAhB,CAAsB,CAAtB,EAAyBM,MAAzB,CAAgC,CAACd,EAAD,EAAKe,CAAL,KAAWhB,WAAW,CAACC,EAAD,EAAKgB,QAAQ,CAACD,CAAD,EAAI,EAAJ,CAAR,IAAmBA,CAAC,CAACE,MAAF,GAAW,CAAX,IAAgBF,CAAC,CAACG,QAAF,CAAW,GAAX,CAAhB,GAAkC1B,QAAlC,GAA6C,CAAhE,CAAL,CAAtD,EAAgIQ,EAAhI,CAAP;AACD","sourcesContent":["// Copyright 2017-2021 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, bnToU8a, stringToU8a, u8aConcat } from '@polkadot/util';\nimport { hmacSha512 } from \"../../hmac/index.js\";\nimport { secp256k1KeypairFromSeed, secp256k1PrivateKeyTweakAdd } from \"../../secp256k1/index.js\";\nimport { HARDENED, hdValidatePath } from \"../validatePath.js\";\nconst MASTER_SECRET = stringToU8a('Bitcoin seed');\n\nfunction createCoded(secretKey, chainCode) {\n  return {\n    chainCode,\n    publicKey: secp256k1KeypairFromSeed(secretKey).publicKey,\n    secretKey\n  };\n}\n\nfunction deriveChild(hd, index) {\n  const indexBuffer = bnToU8a(index, {\n    bitLength: 32,\n    isLe: false\n  });\n  const data = index >= HARDENED ? u8aConcat(new Uint8Array(1), hd.secretKey, indexBuffer) : u8aConcat(hd.publicKey, indexBuffer);\n\n  try {\n    const I = hmacSha512(hd.chainCode, data);\n    return createCoded(secp256k1PrivateKeyTweakAdd(hd.secretKey, I.slice(0, 32)), I.slice(32));\n  } catch (err) {\n    // In case parse256(IL) >= n or ki == 0, proceed with the next value for i\n    return deriveChild(hd, index + 1);\n  }\n}\n\nexport function hdEthereum(seed, path = '') {\n  const I = hmacSha512(MASTER_SECRET, seed);\n  const hd = createCoded(I.slice(0, 32), I.slice(32));\n\n  if (!path || path === 'm' || path === 'M' || path === \"m'\" || path === \"M'\") {\n    return hd;\n  }\n\n  assert(hdValidatePath(path), 'Invalid derivation path');\n  return path.split('/').slice(1).reduce((hd, c) => deriveChild(hd, parseInt(c, 10) + (c.length > 1 && c.endsWith(\"'\") ? HARDENED : 0)), hd);\n}"]},"metadata":{},"sourceType":"module"}