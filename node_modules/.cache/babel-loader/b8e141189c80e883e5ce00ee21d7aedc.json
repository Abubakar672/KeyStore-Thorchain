{"ast":null,"code":"// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { isHex, isU8a, u8aToU8a } from '@polkadot/util';\nimport { MetadataVersioned } from \"./MetadataVersioned.js\"; // magic u32 preceding the version id\n\nconst VERSION_IDX = 4; // magic + lowest supported version\n\nconst EMPTY_METADATA = new Uint8Array([0x6d, 0x65, 0x74, 0x61, 9]);\nconst EMPTY_U8A = new Uint8Array();\n\nfunction toU8a(value = EMPTY_U8A) {\n  if (isHex(value)) {\n    return toU8a(u8aToU8a(value));\n  } else if (isU8a(value)) {\n    return value.length === 0 ? EMPTY_METADATA : value;\n  }\n\n  throw new Error('Invalid type passed to Metadata constructor');\n}\n\nfunction decodeMetadata(registry, _value) {\n  if (!_value || isU8a(_value) || isHex(_value)) {\n    const value = toU8a(_value);\n    const version = value[VERSION_IDX];\n\n    try {\n      return new MetadataVersioned(registry, value);\n    } catch (error) {\n      // This is an f-ing hack as a follow-up to another ugly hack\n      // https://github.com/polkadot-js/api/commit/a9211690be6b68ad6c6dad7852f1665cadcfa5b2\n      // when we fail on V9, try to re-parse it as v10... yes... HACK\n      if (version === 9) {\n        value[VERSION_IDX] = 10;\n        return decodeMetadata(registry, value);\n      }\n\n      throw error;\n    }\n  }\n\n  return new MetadataVersioned(registry, _value);\n}\n/**\n * @name Metadata\n * @description\n * The versioned runtime metadata as a decoded structure\n */\n\n\nexport class Metadata extends MetadataVersioned {\n  constructor(registry, value) {\n    super(registry, decodeMetadata(registry, value));\n  }\n\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/types/metadata/Metadata.js"],"names":["isHex","isU8a","u8aToU8a","MetadataVersioned","VERSION_IDX","EMPTY_METADATA","Uint8Array","EMPTY_U8A","toU8a","value","length","Error","decodeMetadata","registry","_value","version","error","Metadata","constructor"],"mappings":"AAAA;AACA;AACA,SAASA,KAAT,EAAgBC,KAAhB,EAAuBC,QAAvB,QAAuC,gBAAvC;AACA,SAASC,iBAAT,QAAkC,wBAAlC,C,CAA4D;;AAE5D,MAAMC,WAAW,GAAG,CAApB,C,CAAuB;;AAEvB,MAAMC,cAAc,GAAG,IAAIC,UAAJ,CAAe,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,EAAyB,CAAzB,CAAf,CAAvB;AACA,MAAMC,SAAS,GAAG,IAAID,UAAJ,EAAlB;;AAEA,SAASE,KAAT,CAAeC,KAAK,GAAGF,SAAvB,EAAkC;AAChC,MAAIP,KAAK,CAACS,KAAD,CAAT,EAAkB;AAChB,WAAOD,KAAK,CAACN,QAAQ,CAACO,KAAD,CAAT,CAAZ;AACD,GAFD,MAEO,IAAIR,KAAK,CAACQ,KAAD,CAAT,EAAkB;AACvB,WAAOA,KAAK,CAACC,MAAN,KAAiB,CAAjB,GAAqBL,cAArB,GAAsCI,KAA7C;AACD;;AAED,QAAM,IAAIE,KAAJ,CAAU,6CAAV,CAAN;AACD;;AAED,SAASC,cAAT,CAAwBC,QAAxB,EAAkCC,MAAlC,EAA0C;AACxC,MAAI,CAACA,MAAD,IAAWb,KAAK,CAACa,MAAD,CAAhB,IAA4Bd,KAAK,CAACc,MAAD,CAArC,EAA+C;AAC7C,UAAML,KAAK,GAAGD,KAAK,CAACM,MAAD,CAAnB;AACA,UAAMC,OAAO,GAAGN,KAAK,CAACL,WAAD,CAArB;;AAEA,QAAI;AACF,aAAO,IAAID,iBAAJ,CAAsBU,QAAtB,EAAgCJ,KAAhC,CAAP;AACD,KAFD,CAEE,OAAOO,KAAP,EAAc;AACd;AACA;AACA;AACA,UAAID,OAAO,KAAK,CAAhB,EAAmB;AACjBN,QAAAA,KAAK,CAACL,WAAD,CAAL,GAAqB,EAArB;AACA,eAAOQ,cAAc,CAACC,QAAD,EAAWJ,KAAX,CAArB;AACD;;AAED,YAAMO,KAAN;AACD;AACF;;AAED,SAAO,IAAIb,iBAAJ,CAAsBU,QAAtB,EAAgCC,MAAhC,CAAP;AACD;AACD;AACA;AACA;AACA;AACA;;;AAGA,OAAO,MAAMG,QAAN,SAAuBd,iBAAvB,CAAyC;AAC9Ce,EAAAA,WAAW,CAACL,QAAD,EAAWJ,KAAX,EAAkB;AAC3B,UAAMI,QAAN,EAAgBD,cAAc,CAACC,QAAD,EAAWJ,KAAX,CAA9B;AACD;;AAH6C","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { isHex, isU8a, u8aToU8a } from '@polkadot/util';\nimport { MetadataVersioned } from \"./MetadataVersioned.js\"; // magic u32 preceding the version id\n\nconst VERSION_IDX = 4; // magic + lowest supported version\n\nconst EMPTY_METADATA = new Uint8Array([0x6d, 0x65, 0x74, 0x61, 9]);\nconst EMPTY_U8A = new Uint8Array();\n\nfunction toU8a(value = EMPTY_U8A) {\n  if (isHex(value)) {\n    return toU8a(u8aToU8a(value));\n  } else if (isU8a(value)) {\n    return value.length === 0 ? EMPTY_METADATA : value;\n  }\n\n  throw new Error('Invalid type passed to Metadata constructor');\n}\n\nfunction decodeMetadata(registry, _value) {\n  if (!_value || isU8a(_value) || isHex(_value)) {\n    const value = toU8a(_value);\n    const version = value[VERSION_IDX];\n\n    try {\n      return new MetadataVersioned(registry, value);\n    } catch (error) {\n      // This is an f-ing hack as a follow-up to another ugly hack\n      // https://github.com/polkadot-js/api/commit/a9211690be6b68ad6c6dad7852f1665cadcfa5b2\n      // when we fail on V9, try to re-parse it as v10... yes... HACK\n      if (version === 9) {\n        value[VERSION_IDX] = 10;\n        return decodeMetadata(registry, value);\n      }\n\n      throw error;\n    }\n  }\n\n  return new MetadataVersioned(registry, _value);\n}\n/**\n * @name Metadata\n * @description\n * The versioned runtime metadata as a decoded structure\n */\n\n\nexport class Metadata extends MetadataVersioned {\n  constructor(registry, value) {\n    super(registry, decodeMetadata(registry, value));\n  }\n\n}"]},"metadata":{},"sourceType":"module"}