{"ast":null,"code":"// Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { combineLatest, map, of, switchMap } from 'rxjs';\nimport { BN_ZERO } from '@polkadot/util';\nimport { memo } from \"../util/index.js\";\n\nfunction mapResult([result, validators, heartbeats, numBlocks]) {\n  validators.forEach((validator, index) => {\n    const validatorId = validator.toString();\n    const blockCount = numBlocks[index];\n    const hasMessage = !heartbeats[index].isEmpty;\n    const prev = result[validatorId];\n\n    if (!prev || prev.hasMessage !== hasMessage || !prev.blockCount.eq(blockCount)) {\n      result[validatorId] = {\n        blockCount,\n        hasMessage,\n        isOnline: hasMessage || blockCount.gt(BN_ZERO)\n      };\n    }\n  });\n  return result;\n}\n/**\n * @description Return a boolean array indicating whether the passed accounts had received heartbeats in the current session\n */\n\n\nexport function receivedHeartbeats(instanceId, api) {\n  return memo(instanceId, () => {\n    var _api$query$imOnline;\n\n    return (_api$query$imOnline = api.query.imOnline) !== null && _api$query$imOnline !== void 0 && _api$query$imOnline.receivedHeartbeats ? api.derive.staking.overview().pipe(switchMap(({\n      currentIndex,\n      validators\n    }) => combineLatest([of({}), of(validators), api.query.imOnline.receivedHeartbeats.multi(validators.map((_address, index) => [currentIndex, index])), api.query.imOnline.authoredBlocks.multi(validators.map(address => [currentIndex, address]))])), map(mapResult)) : of({});\n  });\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/api-derive/imOnline/receivedHeartbeats.js"],"names":["combineLatest","map","of","switchMap","BN_ZERO","memo","mapResult","result","validators","heartbeats","numBlocks","forEach","validator","index","validatorId","toString","blockCount","hasMessage","isEmpty","prev","eq","isOnline","gt","receivedHeartbeats","instanceId","api","_api$query$imOnline","query","imOnline","derive","staking","overview","pipe","currentIndex","multi","_address","authoredBlocks","address"],"mappings":"AAAA;AACA;AACA,SAASA,aAAT,EAAwBC,GAAxB,EAA6BC,EAA7B,EAAiCC,SAAjC,QAAkD,MAAlD;AACA,SAASC,OAAT,QAAwB,gBAAxB;AACA,SAASC,IAAT,QAAqB,kBAArB;;AAEA,SAASC,SAAT,CAAmB,CAACC,MAAD,EAASC,UAAT,EAAqBC,UAArB,EAAiCC,SAAjC,CAAnB,EAAgE;AAC9DF,EAAAA,UAAU,CAACG,OAAX,CAAmB,CAACC,SAAD,EAAYC,KAAZ,KAAsB;AACvC,UAAMC,WAAW,GAAGF,SAAS,CAACG,QAAV,EAApB;AACA,UAAMC,UAAU,GAAGN,SAAS,CAACG,KAAD,CAA5B;AACA,UAAMI,UAAU,GAAG,CAACR,UAAU,CAACI,KAAD,CAAV,CAAkBK,OAAtC;AACA,UAAMC,IAAI,GAAGZ,MAAM,CAACO,WAAD,CAAnB;;AAEA,QAAI,CAACK,IAAD,IAASA,IAAI,CAACF,UAAL,KAAoBA,UAA7B,IAA2C,CAACE,IAAI,CAACH,UAAL,CAAgBI,EAAhB,CAAmBJ,UAAnB,CAAhD,EAAgF;AAC9ET,MAAAA,MAAM,CAACO,WAAD,CAAN,GAAsB;AACpBE,QAAAA,UADoB;AAEpBC,QAAAA,UAFoB;AAGpBI,QAAAA,QAAQ,EAAEJ,UAAU,IAAID,UAAU,CAACM,EAAX,CAAclB,OAAd;AAHJ,OAAtB;AAKD;AACF,GAbD;AAcA,SAAOG,MAAP;AACD;AACD;AACA;AACA;;;AAGA,OAAO,SAASgB,kBAAT,CAA4BC,UAA5B,EAAwCC,GAAxC,EAA6C;AAClD,SAAOpB,IAAI,CAACmB,UAAD,EAAa,MAAM;AAC5B,QAAIE,mBAAJ;;AAEA,WAAO,CAACA,mBAAmB,GAAGD,GAAG,CAACE,KAAJ,CAAUC,QAAjC,MAA+C,IAA/C,IAAuDF,mBAAmB,KAAK,KAAK,CAApF,IAAyFA,mBAAmB,CAACH,kBAA7G,GAAkIE,GAAG,CAACI,MAAJ,CAAWC,OAAX,CAAmBC,QAAnB,GAA8BC,IAA9B,CAAmC7B,SAAS,CAAC,CAAC;AACrL8B,MAAAA,YADqL;AAErLzB,MAAAA;AAFqL,KAAD,KAGhLR,aAAa,CAAC,CAACE,EAAE,CAAC,EAAD,CAAH,EAASA,EAAE,CAACM,UAAD,CAAX,EAAyBiB,GAAG,CAACE,KAAJ,CAAUC,QAAV,CAAmBL,kBAAnB,CAAsCW,KAAtC,CAA4C1B,UAAU,CAACP,GAAX,CAAe,CAACkC,QAAD,EAAWtB,KAAX,KAAqB,CAACoB,YAAD,EAAepB,KAAf,CAApC,CAA5C,CAAzB,EAAkIY,GAAG,CAACE,KAAJ,CAAUC,QAAV,CAAmBQ,cAAnB,CAAkCF,KAAlC,CAAwC1B,UAAU,CAACP,GAAX,CAAeoC,OAAO,IAAI,CAACJ,YAAD,EAAeI,OAAf,CAA1B,CAAxC,CAAlI,CAAD,CAHkK,CAA5C,EAG6GpC,GAAG,CAACK,SAAD,CAHhH,CAAlI,GAGiQJ,EAAE,CAAC,EAAD,CAH1Q;AAID,GAPU,CAAX;AAQD","sourcesContent":["// Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { combineLatest, map, of, switchMap } from 'rxjs';\nimport { BN_ZERO } from '@polkadot/util';\nimport { memo } from \"../util/index.js\";\n\nfunction mapResult([result, validators, heartbeats, numBlocks]) {\n  validators.forEach((validator, index) => {\n    const validatorId = validator.toString();\n    const blockCount = numBlocks[index];\n    const hasMessage = !heartbeats[index].isEmpty;\n    const prev = result[validatorId];\n\n    if (!prev || prev.hasMessage !== hasMessage || !prev.blockCount.eq(blockCount)) {\n      result[validatorId] = {\n        blockCount,\n        hasMessage,\n        isOnline: hasMessage || blockCount.gt(BN_ZERO)\n      };\n    }\n  });\n  return result;\n}\n/**\n * @description Return a boolean array indicating whether the passed accounts had received heartbeats in the current session\n */\n\n\nexport function receivedHeartbeats(instanceId, api) {\n  return memo(instanceId, () => {\n    var _api$query$imOnline;\n\n    return (_api$query$imOnline = api.query.imOnline) !== null && _api$query$imOnline !== void 0 && _api$query$imOnline.receivedHeartbeats ? api.derive.staking.overview().pipe(switchMap(({\n      currentIndex,\n      validators\n    }) => combineLatest([of({}), of(validators), api.query.imOnline.receivedHeartbeats.multi(validators.map((_address, index) => [currentIndex, index])), api.query.imOnline.authoredBlocks.multi(validators.map(address => [currentIndex, address]))])), map(mapResult)) : of({});\n  });\n}"]},"metadata":{},"sourceType":"module"}