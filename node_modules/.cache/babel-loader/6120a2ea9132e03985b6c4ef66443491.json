{"ast":null,"code":"// Copyright 2019-2021 @polkadot/wasm-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n// MIT License\n//\n// Copyright (c) 2020 Arjun Barrett\n//\n// Copied from https://github.com/101arrowz/fflate/blob/73c737941ec89d85cdf0ad39ee6f26c5fdc95fd7/src/index.ts\n// This only contains the unzlibSync function, no compression, no async, no workers\n//\n// These 2 issues are addressed as a short-term, stop-gap solution\n//   - https://github.com/polkadot-js/api/issues/2963\n//   - https://github.com/101arrowz/fflate/issues/17\n//\n// Only tweaks make here are some TS adjustments (we use strict null checks), the code is otherwise as-is with\n// only the single required function provided (compression is still being done in the build with fflate)\n\n/* eslint-disable */\n// inflate state\n// aliases for shorter compressed code (most minifers don't do this)\nconst u8 = Uint8Array,\n      u16 = Uint16Array,\n      u32 = Uint32Array; // code length index map\n\nconst clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]); // fixed length extra bits\n\nconst fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0,\n/* unused */\n0, 0,\n/* impossible */\n0]); // fixed distance extra bits\n// see fleb note\n\nconst fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13,\n/* unused */\n0, 0]); // get base, reverse index map from extra bits\n\nconst freb = (eb, start) => {\n  const b = new u16(31);\n\n  for (let i = 0; i < 31; ++i) {\n    b[i] = start += 1 << eb[i - 1];\n  } // numbers here are at max 18 bits\n\n\n  const r = new u32(b[30]);\n\n  for (let i = 1; i < 30; ++i) {\n    for (let j = b[i]; j < b[i + 1]; ++j) {\n      r[j] = j - b[i] << 5 | i;\n    }\n  }\n\n  return [b, r];\n};\n\nconst [fl, revfl] = freb(fleb, 2); // we can ignore the fact that the other numbers are wrong; they never happen anyway\n\nfl[28] = 258, revfl[258] = 28;\nconst [fd] = freb(fdeb, 0); // map of value to reverse (assuming 16 bits)\n\nconst rev = new u16(32768);\n\nfor (let i = 0; i < 32768; ++i) {\n  // reverse table algorithm from SO\n  let x = (i & 0xAAAA) >>> 1 | (i & 0x5555) << 1;\n  x = (x & 0xCCCC) >>> 2 | (x & 0x3333) << 2;\n  x = (x & 0xF0F0) >>> 4 | (x & 0x0F0F) << 4;\n  rev[i] = ((x & 0xFF00) >>> 8 | (x & 0x00FF) << 8) >>> 1;\n} // create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\n\n\nconst hMap = (cd, mb, r) => {\n  const s = cd.length; // index\n\n  let i = 0; // u16 \"map\": index -> # of codes with bit length = index\n\n  const l = new u16(mb); // length of cd must be 288 (total # of codes)\n\n  for (; i < s; ++i) ++l[cd[i] - 1]; // u16 \"map\": index -> minimum code for bit length = index\n\n\n  const le = new u16(mb);\n\n  for (i = 0; i < mb; ++i) {\n    le[i] = le[i - 1] + l[i - 1] << 1;\n  }\n\n  let co;\n\n  if (r) {\n    // u16 \"map\": index -> number of actual bits, symbol for code\n    co = new u16(1 << mb); // bits to remove for reverser\n\n    const rvb = 15 - mb;\n\n    for (i = 0; i < s; ++i) {\n      // ignore 0 lengths\n      if (cd[i]) {\n        // num encoding both symbol and bits read\n        const sv = i << 4 | cd[i]; // free bits\n\n        const r = mb - cd[i]; // start value\n\n        let v = le[cd[i] - 1]++ << r; // m is end value\n\n        for (const m = v | (1 << r) - 1; v <= m; ++v) {\n          // every 16 bit value starting with the code yields the same result\n          co[rev[v] >>> rvb] = sv;\n        }\n      }\n    }\n  } else {\n    co = new u16(s);\n\n    for (i = 0; i < s; ++i) co[i] = rev[le[cd[i] - 1]++] >>> 15 - cd[i];\n  }\n\n  return co;\n}; // fixed length tree\n\n\nconst flt = new u8(288);\n\nfor (let i = 0; i < 144; ++i) flt[i] = 8;\n\nfor (let i = 144; i < 256; ++i) flt[i] = 9;\n\nfor (let i = 256; i < 280; ++i) flt[i] = 7;\n\nfor (let i = 280; i < 288; ++i) flt[i] = 8; // fixed distance tree\n\n\nconst fdt = new u8(32);\n\nfor (let i = 0; i < 32; ++i) fdt[i] = 5; // fixed length map\n\n\nconst flrm = hMap(flt, 9, 1); // fixed distance map\n\nconst fdrm = hMap(fdt, 5, 1); // read d, starting at bit p and mask with m\n\nconst bits = (d, p, m) => {\n  const o = p >>> 3;\n  return (d[o] | d[o + 1] << 8) >>> (p & 7) & m;\n}; // read d, starting at bit p continuing for at least 16 bits\n\n\nconst bits16 = (d, p) => {\n  const o = p >>> 3;\n  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >>> (p & 7);\n}; // get end of byte\n\n\nconst shft = p => (p >>> 3) + (p & 7 && 1); // typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\n\n\nconst slc = (v, s, e) => {\n  if (s == null || s < 0) s = 0;\n  if (e == null || e > v.length) e = v.length; // can't use .constructor in case user-supplied\n\n  const n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);\n  n.set(v.subarray(s, e));\n  return n;\n}; // find max of array\n\n\nconst max = a => {\n  let m = a[0];\n\n  for (let i = 1; i < a.length; ++i) {\n    if (a[i] > m) m = a[i];\n  }\n\n  return m;\n}; // expands raw DEFLATE data\n\n\nconst inflt = (dat, buf, st) => {\n  const noSt = !st || st.i;\n  if (!st) st = {}; // source length\n\n  const sl = dat.length; // have to estimate size\n\n  const noBuf = !buf || !noSt; // Assumes roughly 33% compression ratio average\n\n  if (!buf) buf = new u8(sl * 3); // ensure buffer can fit at least l elements\n\n  const cbuf = l => {\n    let bl = buf.length; // need to increase size to fit\n\n    if (l > bl) {\n      // Double or set to necessary, whichever is greater\n      const nbuf = new u8(Math.max(bl << 1, l));\n      nbuf.set(buf);\n      buf = nbuf;\n    }\n  }; //  last chunk         bitpos           bytes\n\n\n  let final = st.f || 0,\n      pos = st.p || 0,\n      bt = st.b || 0,\n      lm = st.l,\n      dm = st.d,\n      lbt = st.m,\n      dbt = st.n;\n  if (final && !lm) return buf; // total bits\n\n  const tbts = sl << 3;\n\n  do {\n    if (!lm) {\n      // BFINAL - this is only 1 when last chunk is next\n      st.f = final = bits(dat, pos, 1); // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n\n      const type = bits(dat, pos + 1, 3);\n      pos += 3;\n\n      if (!type) {\n        // go to end of byte boundary\n        const s = shft(pos) + 4,\n              l = dat[s - 4] | dat[s - 3] << 8,\n              t = s + l;\n\n        if (t > sl) {\n          if (noSt) throw 'unexpected EOF';\n          break;\n        } // ensure size\n\n\n        if (noBuf) cbuf(bt + l); // Copy over uncompressed data\n\n        buf.set(dat.subarray(s, t), bt); // Get new bitpos, update byte count\n\n        st.b = bt += l, st.p = pos = t << 3;\n        continue;\n      } else if (type == 1) lm = flrm, dm = fdrm, lbt = 9, dbt = 5;else if (type == 2) {\n        //  literal                            lengths\n        const hLit = bits(dat, pos, 31) + 257,\n              hcLen = bits(dat, pos + 10, 15) + 4;\n        const tl = hLit + bits(dat, pos + 5, 31) + 1;\n        pos += 14; // length+distance tree\n\n        const ldt = new u8(tl); // code length tree\n\n        const clt = new u8(19);\n\n        for (let i = 0; i < hcLen; ++i) {\n          // use index map to get real code\n          clt[clim[i]] = bits(dat, pos + i * 3, 7);\n        }\n\n        pos += hcLen * 3; // code lengths bits\n\n        const clb = max(clt),\n              clbmsk = (1 << clb) - 1;\n        if (!noSt && pos + tl * (clb + 7) > tbts) break; // code lengths map\n\n        const clm = hMap(clt, clb, 1);\n\n        for (let i = 0; i < tl;) {\n          const r = clm[bits(dat, pos, clbmsk)]; // bits read\n\n          pos += r & 15; // symbol\n\n          const s = r >>> 4; // code length to copy\n\n          if (s < 16) {\n            ldt[i++] = s;\n          } else {\n            //  copy   count\n            let c = 0,\n                n = 0;\n            if (s == 16) n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];else if (s == 17) n = 3 + bits(dat, pos, 7), pos += 3;else if (s == 18) n = 11 + bits(dat, pos, 127), pos += 7;\n\n            while (n--) ldt[i++] = c;\n          }\n        } //    length tree                 distance tree\n\n\n        const lt = ldt.subarray(0, hLit),\n              dt = ldt.subarray(hLit); // max length bits\n\n        lbt = max(lt); // max dist bits\n\n        dbt = max(dt);\n        lm = hMap(lt, lbt, 1);\n        dm = hMap(dt, dbt, 1);\n      } else throw 'invalid block type';\n\n      if (pos > tbts) throw 'unexpected EOF';\n    } // Make sure the buffer can hold this + the largest possible addition\n    // maximum chunk size (practically, theoretically infinite) is 2^17;\n\n\n    if (noBuf) cbuf(bt + 131072);\n    const lms = (1 << lbt) - 1,\n          dms = (1 << dbt) - 1;\n    const mxa = lbt + dbt + 18;\n\n    while (noSt || pos + mxa < tbts) {\n      // bits read, code\n      const c = lm[bits16(dat, pos) & lms],\n            sym = c >>> 4;\n      pos += c & 15;\n      if (pos > tbts) throw 'unexpected EOF';\n      if (!c) throw 'invalid length/literal';\n      if (sym < 256) buf[bt++] = sym;else if (sym == 256) {\n        lm = undefined;\n        break;\n      } else {\n        let add = sym - 254; // no extra bits needed if less\n\n        if (sym > 264) {\n          // index\n          const i = sym - 257,\n                b = fleb[i];\n          add = bits(dat, pos, (1 << b) - 1) + fl[i];\n          pos += b;\n        } // dist\n\n\n        const d = dm[bits16(dat, pos) & dms],\n              dsym = d >>> 4;\n        if (!d) throw 'invalid distance';\n        pos += d & 15;\n        let dt = fd[dsym];\n\n        if (dsym > 3) {\n          const b = fdeb[dsym];\n          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n        }\n\n        if (pos > tbts) throw 'unexpected EOF';\n        if (noBuf) cbuf(bt + 131072);\n        const end = bt + add;\n\n        for (; bt < end; bt += 4) {\n          buf[bt] = buf[bt - dt];\n          buf[bt + 1] = buf[bt + 1 - dt];\n          buf[bt + 2] = buf[bt + 2 - dt];\n          buf[bt + 3] = buf[bt + 3 - dt];\n        }\n\n        bt = end;\n      }\n    }\n\n    st.l = lm, st.p = pos, st.b = bt;\n    if (lm) final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n  } while (!final);\n\n  return bt == buf.length ? buf : slc(buf, 0, bt);\n}; // zlib valid\n\n\nconst zlv = d => {\n  if ((d[0] & 15) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31) throw 'invalid zlib data';\n  if (d[1] & 32) throw 'invalid zlib data: preset dictionaries not supported';\n};\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\n\n\nexport function unzlibSync(data, out) {\n  return inflt((zlv(data), data.subarray(2, -4)), out);\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/wasm-crypto-wasm/fflate.js"],"names":["u8","Uint8Array","u16","Uint16Array","u32","Uint32Array","clim","fleb","fdeb","freb","eb","start","b","i","r","j","fl","revfl","fd","rev","x","hMap","cd","mb","s","length","l","le","co","rvb","sv","v","m","flt","fdt","flrm","fdrm","bits","d","p","o","bits16","shft","slc","e","n","set","subarray","max","a","inflt","dat","buf","st","noSt","sl","noBuf","cbuf","bl","nbuf","Math","final","f","pos","bt","lm","dm","lbt","dbt","tbts","type","t","hLit","hcLen","tl","ldt","clt","clb","clbmsk","clm","c","lt","dt","lms","dms","mxa","sym","undefined","add","dsym","end","zlv","unzlibSync","data","out"],"mappings":"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","sourcesContent":["// Copyright 2019-2021 @polkadot/wasm-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n// MIT License\n//\n// Copyright (c) 2020 Arjun Barrett\n//\n// Copied from https://github.com/101arrowz/fflate/blob/73c737941ec89d85cdf0ad39ee6f26c5fdc95fd7/src/index.ts\n// This only contains the unzlibSync function, no compression, no async, no workers\n//\n// These 2 issues are addressed as a short-term, stop-gap solution\n//   - https://github.com/polkadot-js/api/issues/2963\n//   - https://github.com/101arrowz/fflate/issues/17\n//\n// Only tweaks make here are some TS adjustments (we use strict null checks), the code is otherwise as-is with\n// only the single required function provided (compression is still being done in the build with fflate)\n\n/* eslint-disable */\n// inflate state\n// aliases for shorter compressed code (most minifers don't do this)\nconst u8 = Uint8Array,\n      u16 = Uint16Array,\n      u32 = Uint32Array; // code length index map\n\nconst clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]); // fixed length extra bits\n\nconst fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0,\n/* unused */\n0, 0,\n/* impossible */\n0]); // fixed distance extra bits\n// see fleb note\n\nconst fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13,\n/* unused */\n0, 0]); // get base, reverse index map from extra bits\n\nconst freb = (eb, start) => {\n  const b = new u16(31);\n\n  for (let i = 0; i < 31; ++i) {\n    b[i] = start += 1 << eb[i - 1];\n  } // numbers here are at max 18 bits\n\n\n  const r = new u32(b[30]);\n\n  for (let i = 1; i < 30; ++i) {\n    for (let j = b[i]; j < b[i + 1]; ++j) {\n      r[j] = j - b[i] << 5 | i;\n    }\n  }\n\n  return [b, r];\n};\n\nconst [fl, revfl] = freb(fleb, 2); // we can ignore the fact that the other numbers are wrong; they never happen anyway\n\nfl[28] = 258, revfl[258] = 28;\nconst [fd] = freb(fdeb, 0); // map of value to reverse (assuming 16 bits)\n\nconst rev = new u16(32768);\n\nfor (let i = 0; i < 32768; ++i) {\n  // reverse table algorithm from SO\n  let x = (i & 0xAAAA) >>> 1 | (i & 0x5555) << 1;\n  x = (x & 0xCCCC) >>> 2 | (x & 0x3333) << 2;\n  x = (x & 0xF0F0) >>> 4 | (x & 0x0F0F) << 4;\n  rev[i] = ((x & 0xFF00) >>> 8 | (x & 0x00FF) << 8) >>> 1;\n} // create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\n\n\nconst hMap = (cd, mb, r) => {\n  const s = cd.length; // index\n\n  let i = 0; // u16 \"map\": index -> # of codes with bit length = index\n\n  const l = new u16(mb); // length of cd must be 288 (total # of codes)\n\n  for (; i < s; ++i) ++l[cd[i] - 1]; // u16 \"map\": index -> minimum code for bit length = index\n\n\n  const le = new u16(mb);\n\n  for (i = 0; i < mb; ++i) {\n    le[i] = le[i - 1] + l[i - 1] << 1;\n  }\n\n  let co;\n\n  if (r) {\n    // u16 \"map\": index -> number of actual bits, symbol for code\n    co = new u16(1 << mb); // bits to remove for reverser\n\n    const rvb = 15 - mb;\n\n    for (i = 0; i < s; ++i) {\n      // ignore 0 lengths\n      if (cd[i]) {\n        // num encoding both symbol and bits read\n        const sv = i << 4 | cd[i]; // free bits\n\n        const r = mb - cd[i]; // start value\n\n        let v = le[cd[i] - 1]++ << r; // m is end value\n\n        for (const m = v | (1 << r) - 1; v <= m; ++v) {\n          // every 16 bit value starting with the code yields the same result\n          co[rev[v] >>> rvb] = sv;\n        }\n      }\n    }\n  } else {\n    co = new u16(s);\n\n    for (i = 0; i < s; ++i) co[i] = rev[le[cd[i] - 1]++] >>> 15 - cd[i];\n  }\n\n  return co;\n}; // fixed length tree\n\n\nconst flt = new u8(288);\n\nfor (let i = 0; i < 144; ++i) flt[i] = 8;\n\nfor (let i = 144; i < 256; ++i) flt[i] = 9;\n\nfor (let i = 256; i < 280; ++i) flt[i] = 7;\n\nfor (let i = 280; i < 288; ++i) flt[i] = 8; // fixed distance tree\n\n\nconst fdt = new u8(32);\n\nfor (let i = 0; i < 32; ++i) fdt[i] = 5; // fixed length map\n\n\nconst flrm = hMap(flt, 9, 1); // fixed distance map\n\nconst fdrm = hMap(fdt, 5, 1); // read d, starting at bit p and mask with m\n\nconst bits = (d, p, m) => {\n  const o = p >>> 3;\n  return (d[o] | d[o + 1] << 8) >>> (p & 7) & m;\n}; // read d, starting at bit p continuing for at least 16 bits\n\n\nconst bits16 = (d, p) => {\n  const o = p >>> 3;\n  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >>> (p & 7);\n}; // get end of byte\n\n\nconst shft = p => (p >>> 3) + (p & 7 && 1); // typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\n\n\nconst slc = (v, s, e) => {\n  if (s == null || s < 0) s = 0;\n  if (e == null || e > v.length) e = v.length; // can't use .constructor in case user-supplied\n\n  const n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);\n  n.set(v.subarray(s, e));\n  return n;\n}; // find max of array\n\n\nconst max = a => {\n  let m = a[0];\n\n  for (let i = 1; i < a.length; ++i) {\n    if (a[i] > m) m = a[i];\n  }\n\n  return m;\n}; // expands raw DEFLATE data\n\n\nconst inflt = (dat, buf, st) => {\n  const noSt = !st || st.i;\n  if (!st) st = {}; // source length\n\n  const sl = dat.length; // have to estimate size\n\n  const noBuf = !buf || !noSt; // Assumes roughly 33% compression ratio average\n\n  if (!buf) buf = new u8(sl * 3); // ensure buffer can fit at least l elements\n\n  const cbuf = l => {\n    let bl = buf.length; // need to increase size to fit\n\n    if (l > bl) {\n      // Double or set to necessary, whichever is greater\n      const nbuf = new u8(Math.max(bl << 1, l));\n      nbuf.set(buf);\n      buf = nbuf;\n    }\n  }; //  last chunk         bitpos           bytes\n\n\n  let final = st.f || 0,\n      pos = st.p || 0,\n      bt = st.b || 0,\n      lm = st.l,\n      dm = st.d,\n      lbt = st.m,\n      dbt = st.n;\n  if (final && !lm) return buf; // total bits\n\n  const tbts = sl << 3;\n\n  do {\n    if (!lm) {\n      // BFINAL - this is only 1 when last chunk is next\n      st.f = final = bits(dat, pos, 1); // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n\n      const type = bits(dat, pos + 1, 3);\n      pos += 3;\n\n      if (!type) {\n        // go to end of byte boundary\n        const s = shft(pos) + 4,\n              l = dat[s - 4] | dat[s - 3] << 8,\n              t = s + l;\n\n        if (t > sl) {\n          if (noSt) throw 'unexpected EOF';\n          break;\n        } // ensure size\n\n\n        if (noBuf) cbuf(bt + l); // Copy over uncompressed data\n\n        buf.set(dat.subarray(s, t), bt); // Get new bitpos, update byte count\n\n        st.b = bt += l, st.p = pos = t << 3;\n        continue;\n      } else if (type == 1) lm = flrm, dm = fdrm, lbt = 9, dbt = 5;else if (type == 2) {\n        //  literal                            lengths\n        const hLit = bits(dat, pos, 31) + 257,\n              hcLen = bits(dat, pos + 10, 15) + 4;\n        const tl = hLit + bits(dat, pos + 5, 31) + 1;\n        pos += 14; // length+distance tree\n\n        const ldt = new u8(tl); // code length tree\n\n        const clt = new u8(19);\n\n        for (let i = 0; i < hcLen; ++i) {\n          // use index map to get real code\n          clt[clim[i]] = bits(dat, pos + i * 3, 7);\n        }\n\n        pos += hcLen * 3; // code lengths bits\n\n        const clb = max(clt),\n              clbmsk = (1 << clb) - 1;\n        if (!noSt && pos + tl * (clb + 7) > tbts) break; // code lengths map\n\n        const clm = hMap(clt, clb, 1);\n\n        for (let i = 0; i < tl;) {\n          const r = clm[bits(dat, pos, clbmsk)]; // bits read\n\n          pos += r & 15; // symbol\n\n          const s = r >>> 4; // code length to copy\n\n          if (s < 16) {\n            ldt[i++] = s;\n          } else {\n            //  copy   count\n            let c = 0,\n                n = 0;\n            if (s == 16) n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];else if (s == 17) n = 3 + bits(dat, pos, 7), pos += 3;else if (s == 18) n = 11 + bits(dat, pos, 127), pos += 7;\n\n            while (n--) ldt[i++] = c;\n          }\n        } //    length tree                 distance tree\n\n\n        const lt = ldt.subarray(0, hLit),\n              dt = ldt.subarray(hLit); // max length bits\n\n        lbt = max(lt); // max dist bits\n\n        dbt = max(dt);\n        lm = hMap(lt, lbt, 1);\n        dm = hMap(dt, dbt, 1);\n      } else throw 'invalid block type';\n\n      if (pos > tbts) throw 'unexpected EOF';\n    } // Make sure the buffer can hold this + the largest possible addition\n    // maximum chunk size (practically, theoretically infinite) is 2^17;\n\n\n    if (noBuf) cbuf(bt + 131072);\n    const lms = (1 << lbt) - 1,\n          dms = (1 << dbt) - 1;\n    const mxa = lbt + dbt + 18;\n\n    while (noSt || pos + mxa < tbts) {\n      // bits read, code\n      const c = lm[bits16(dat, pos) & lms],\n            sym = c >>> 4;\n      pos += c & 15;\n      if (pos > tbts) throw 'unexpected EOF';\n      if (!c) throw 'invalid length/literal';\n      if (sym < 256) buf[bt++] = sym;else if (sym == 256) {\n        lm = undefined;\n        break;\n      } else {\n        let add = sym - 254; // no extra bits needed if less\n\n        if (sym > 264) {\n          // index\n          const i = sym - 257,\n                b = fleb[i];\n          add = bits(dat, pos, (1 << b) - 1) + fl[i];\n          pos += b;\n        } // dist\n\n\n        const d = dm[bits16(dat, pos) & dms],\n              dsym = d >>> 4;\n        if (!d) throw 'invalid distance';\n        pos += d & 15;\n        let dt = fd[dsym];\n\n        if (dsym > 3) {\n          const b = fdeb[dsym];\n          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n        }\n\n        if (pos > tbts) throw 'unexpected EOF';\n        if (noBuf) cbuf(bt + 131072);\n        const end = bt + add;\n\n        for (; bt < end; bt += 4) {\n          buf[bt] = buf[bt - dt];\n          buf[bt + 1] = buf[bt + 1 - dt];\n          buf[bt + 2] = buf[bt + 2 - dt];\n          buf[bt + 3] = buf[bt + 3 - dt];\n        }\n\n        bt = end;\n      }\n    }\n\n    st.l = lm, st.p = pos, st.b = bt;\n    if (lm) final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n  } while (!final);\n\n  return bt == buf.length ? buf : slc(buf, 0, bt);\n}; // zlib valid\n\n\nconst zlv = d => {\n  if ((d[0] & 15) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31) throw 'invalid zlib data';\n  if (d[1] & 32) throw 'invalid zlib data: preset dictionaries not supported';\n};\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\n\n\nexport function unzlibSync(data, out) {\n  return inflt((zlv(data), data.subarray(2, -4)), out);\n}"]},"metadata":{},"sourceType":"module"}