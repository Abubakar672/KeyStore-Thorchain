{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { isHex, isObject, isU8a, u8aToU8a } from '@polkadot/util';\nimport { Struct } from \"../codec/Struct.js\";\nimport { U8aFixed } from \"../codec/U8aFixed.js\";\n/**\n * Get a mapping of `argument name -> argument type` for the function, from\n * its metadata.\n *\n * @param meta - The function metadata used to get the definition.\n * @internal\n */\n\nfunction getArgsDef(registry, meta) {\n  return meta.fields.reduce((result, {\n    name,\n    type\n  }, index) => {\n    result[name.unwrapOr(`param${index}`).toString()] = registry.createLookupType(type);\n    return result;\n  }, {});\n}\n/** @internal */\n\n\nfunction decodeCallViaObject(registry, value, _meta) {\n  // we only pass args/methodsIndex out\n  const {\n    args,\n    callIndex\n  } = value; // Get the correct lookupIndex\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n  const lookupIndex = callIndex instanceof GenericCallIndex ? callIndex.toU8a() : callIndex; // Find metadata with callIndex\n\n  const meta = _meta || registry.findMetaCall(lookupIndex).meta;\n\n  return {\n    args,\n    argsDef: getArgsDef(registry, meta),\n    callIndex,\n    meta\n  };\n}\n/** @internal */\n\n\nfunction decodeCallViaU8a(registry, value, _meta) {\n  // We need 2 bytes for the callIndex\n  const callIndex = new Uint8Array(2);\n  callIndex.set(value.subarray(0, 2), 0); // Find metadata with callIndex\n\n  const meta = _meta || registry.findMetaCall(callIndex).meta;\n\n  return {\n    args: value.subarray(2),\n    argsDef: getArgsDef(registry, meta),\n    callIndex,\n    meta\n  };\n}\n/**\n * Decode input to pass into constructor.\n *\n * @param value - Value to decode, one of:\n * - hex\n * - Uint8Array\n * - {@see DecodeMethodInput}\n * @param _meta - Metadata to use, so that `injectMethods` lookup is not\n * necessary.\n * @internal\n */\n\n\nfunction decodeCall(registry, value = new Uint8Array(), _meta) {\n  if (isHex(value) || isU8a(value)) {\n    return decodeCallViaU8a(registry, u8aToU8a(value), _meta);\n  } else if (isObject(value) && value.callIndex && value.args) {\n    return decodeCallViaObject(registry, value, _meta);\n  }\n\n  throw new Error(`Call: Cannot decode value '${value}' of type ${typeof value}`);\n}\n/**\n * @name GenericCallIndex\n * @description\n * A wrapper around the `[sectionIndex, methodIndex]` value that uniquely identifies a method\n */\n\n\nexport class GenericCallIndex extends U8aFixed {\n  constructor(registry, value) {\n    super(registry, value, 16);\n  }\n\n}\n/**\n * @name GenericCall\n * @description\n * Extrinsic function descriptor\n */\n\nexport class GenericCall extends Struct {\n  constructor(registry, value, meta) {\n    const decoded = decodeCall(registry, value, meta);\n\n    try {\n      super(registry, {\n        callIndex: GenericCallIndex,\n        // eslint-disable-next-line sort-keys\n        args: Struct.with(decoded.argsDef)\n      }, decoded);\n      this._meta = void 0;\n    } catch (error) {\n      let method = 'unknown.unknown';\n\n      try {\n        const c = registry.findMetaCall(decoded.callIndex);\n        method = `${c.section}.${c.method}`;\n      } catch (error) {// ignore\n      }\n\n      throw new Error(`Call: failed decoding ${method}:: ${error.message}`);\n    }\n\n    this._meta = decoded.meta;\n  }\n  /**\n   * @description The arguments for the function call\n   */\n\n\n  get args() {\n    // FIXME This should return a Struct instead of an Array\n    return [...this.get('args').values()];\n  }\n  /**\n   * @description The argument definitions\n   */\n\n\n  get argsDef() {\n    return getArgsDef(this.registry, this.meta);\n  }\n  /**\n   * @description The encoded `[sectionIndex, methodIndex]` identifier\n   */\n\n\n  get callIndex() {\n    return this.get('callIndex').toU8a();\n  }\n  /**\n   * @description The encoded data\n   */\n\n\n  get data() {\n    return this.get('args').toU8a();\n  }\n  /**\n   * @description The [[FunctionMetadata]]\n   */\n\n\n  get meta() {\n    return this._meta;\n  }\n  /**\n   * @description Returns the name of the method\n   */\n\n\n  get method() {\n    return this.registry.findMetaCall(this.callIndex).method;\n  }\n  /**\n   * @description Returns the module containing the method\n   */\n\n\n  get section() {\n    return this.registry.findMetaCall(this.callIndex).section;\n  }\n  /**\n   * @description Checks if the source matches this in type\n   */\n\n\n  is(other) {\n    return other.callIndex[0] === this.callIndex[0] && other.callIndex[1] === this.callIndex[1];\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman(isExpanded) {\n    var _call, _call2;\n\n    let call;\n\n    try {\n      call = this.registry.findMetaCall(this.callIndex);\n    } catch (error) {// swallow\n    }\n\n    return _objectSpread({\n      args: this.args.map(arg => arg.toHuman(isExpanded)),\n      // args: this.args.map((arg, index) => call\n      //   ? { [call.meta.args[index].name.toString()]: arg.toHuman(isExpanded) }\n      //   : arg.toHuman(isExpanded)\n      // ),\n      // callIndex: u8aToHex(this.callIndex),\n      method: (_call = call) === null || _call === void 0 ? void 0 : _call.method,\n      section: (_call2 = call) === null || _call2 === void 0 ? void 0 : _call2.section\n    }, isExpanded && call ? {\n      docs: call.meta.docs.map(d => d.toString())\n    } : {});\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return 'Call';\n  }\n\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/types/generic/Call.js"],"names":["_defineProperty","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","isHex","isObject","isU8a","u8aToU8a","Struct","U8aFixed","getArgsDef","registry","meta","fields","reduce","result","name","type","index","unwrapOr","toString","createLookupType","decodeCallViaObject","value","_meta","args","callIndex","lookupIndex","GenericCallIndex","toU8a","findMetaCall","argsDef","decodeCallViaU8a","Uint8Array","set","subarray","decodeCall","Error","constructor","GenericCall","decoded","with","error","method","c","section","message","get","values","data","is","other","toHuman","isExpanded","_call","_call2","call","map","arg","docs","d","toRawType"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { isHex, isObject, isU8a, u8aToU8a } from '@polkadot/util';\nimport { Struct } from \"../codec/Struct.js\";\nimport { U8aFixed } from \"../codec/U8aFixed.js\";\n\n/**\n * Get a mapping of `argument name -> argument type` for the function, from\n * its metadata.\n *\n * @param meta - The function metadata used to get the definition.\n * @internal\n */\nfunction getArgsDef(registry, meta) {\n  return meta.fields.reduce((result, {\n    name,\n    type\n  }, index) => {\n    result[name.unwrapOr(`param${index}`).toString()] = registry.createLookupType(type);\n    return result;\n  }, {});\n}\n/** @internal */\n\n\nfunction decodeCallViaObject(registry, value, _meta) {\n  // we only pass args/methodsIndex out\n  const {\n    args,\n    callIndex\n  } = value; // Get the correct lookupIndex\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n  const lookupIndex = callIndex instanceof GenericCallIndex ? callIndex.toU8a() : callIndex; // Find metadata with callIndex\n\n  const meta = _meta || registry.findMetaCall(lookupIndex).meta;\n\n  return {\n    args,\n    argsDef: getArgsDef(registry, meta),\n    callIndex,\n    meta\n  };\n}\n/** @internal */\n\n\nfunction decodeCallViaU8a(registry, value, _meta) {\n  // We need 2 bytes for the callIndex\n  const callIndex = new Uint8Array(2);\n  callIndex.set(value.subarray(0, 2), 0); // Find metadata with callIndex\n\n  const meta = _meta || registry.findMetaCall(callIndex).meta;\n\n  return {\n    args: value.subarray(2),\n    argsDef: getArgsDef(registry, meta),\n    callIndex,\n    meta\n  };\n}\n/**\n * Decode input to pass into constructor.\n *\n * @param value - Value to decode, one of:\n * - hex\n * - Uint8Array\n * - {@see DecodeMethodInput}\n * @param _meta - Metadata to use, so that `injectMethods` lookup is not\n * necessary.\n * @internal\n */\n\n\nfunction decodeCall(registry, value = new Uint8Array(), _meta) {\n  if (isHex(value) || isU8a(value)) {\n    return decodeCallViaU8a(registry, u8aToU8a(value), _meta);\n  } else if (isObject(value) && value.callIndex && value.args) {\n    return decodeCallViaObject(registry, value, _meta);\n  }\n\n  throw new Error(`Call: Cannot decode value '${value}' of type ${typeof value}`);\n}\n/**\n * @name GenericCallIndex\n * @description\n * A wrapper around the `[sectionIndex, methodIndex]` value that uniquely identifies a method\n */\n\n\nexport class GenericCallIndex extends U8aFixed {\n  constructor(registry, value) {\n    super(registry, value, 16);\n  }\n\n}\n/**\n * @name GenericCall\n * @description\n * Extrinsic function descriptor\n */\n\nexport class GenericCall extends Struct {\n  constructor(registry, value, meta) {\n    const decoded = decodeCall(registry, value, meta);\n\n    try {\n      super(registry, {\n        callIndex: GenericCallIndex,\n        // eslint-disable-next-line sort-keys\n        args: Struct.with(decoded.argsDef)\n      }, decoded);\n      this._meta = void 0;\n    } catch (error) {\n      let method = 'unknown.unknown';\n\n      try {\n        const c = registry.findMetaCall(decoded.callIndex);\n        method = `${c.section}.${c.method}`;\n      } catch (error) {// ignore\n      }\n\n      throw new Error(`Call: failed decoding ${method}:: ${error.message}`);\n    }\n\n    this._meta = decoded.meta;\n  }\n  /**\n   * @description The arguments for the function call\n   */\n\n\n  get args() {\n    // FIXME This should return a Struct instead of an Array\n    return [...this.get('args').values()];\n  }\n  /**\n   * @description The argument definitions\n   */\n\n\n  get argsDef() {\n    return getArgsDef(this.registry, this.meta);\n  }\n  /**\n   * @description The encoded `[sectionIndex, methodIndex]` identifier\n   */\n\n\n  get callIndex() {\n    return this.get('callIndex').toU8a();\n  }\n  /**\n   * @description The encoded data\n   */\n\n\n  get data() {\n    return this.get('args').toU8a();\n  }\n  /**\n   * @description The [[FunctionMetadata]]\n   */\n\n\n  get meta() {\n    return this._meta;\n  }\n  /**\n   * @description Returns the name of the method\n   */\n\n\n  get method() {\n    return this.registry.findMetaCall(this.callIndex).method;\n  }\n  /**\n   * @description Returns the module containing the method\n   */\n\n\n  get section() {\n    return this.registry.findMetaCall(this.callIndex).section;\n  }\n  /**\n   * @description Checks if the source matches this in type\n   */\n\n\n  is(other) {\n    return other.callIndex[0] === this.callIndex[0] && other.callIndex[1] === this.callIndex[1];\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman(isExpanded) {\n    var _call, _call2;\n\n    let call;\n\n    try {\n      call = this.registry.findMetaCall(this.callIndex);\n    } catch (error) {// swallow\n    }\n\n    return _objectSpread({\n      args: this.args.map(arg => arg.toHuman(isExpanded)),\n      // args: this.args.map((arg, index) => call\n      //   ? { [call.meta.args[index].name.toString()]: arg.toHuman(isExpanded) }\n      //   : arg.toHuman(isExpanded)\n      // ),\n      // callIndex: u8aToHex(this.callIndex),\n      method: (_call = call) === null || _call === void 0 ? void 0 : _call.method,\n      section: (_call2 = call) === null || _call2 === void 0 ? void 0 : _call2.section\n    }, isExpanded && call ? {\n      docs: call.meta.docs.map(d => d.toString())\n    } : {});\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return 'Call';\n  }\n\n}"]},"metadata":{},"sourceType":"module"}