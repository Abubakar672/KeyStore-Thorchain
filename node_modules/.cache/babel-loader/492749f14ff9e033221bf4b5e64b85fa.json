{"ast":null,"code":"// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { compactToU8a, u8aConcat, u8aToHex } from '@polkadot/util';\nimport { compareArray } from \"./utils/compareArray.js\";\n/**\n * @name AbstractArray\n * @description\n * This manages codec arrays. It is an extension to Array, providing\n * specific encoding/decoding on top of the base type.\n * @noInheritDoc\n */\n\nexport class AbstractArray extends Array {\n  constructor(registry, values) {\n    super(values.length);\n    this.registry = void 0;\n    this.createdAtHash = void 0;\n\n    for (let i = 0; i < values.length; i++) {\n      this[i] = values[i];\n    }\n\n    this.registry = registry;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return this.reduce((total, entry) => total + entry.encodedLength, compactToU8a(this.length).length);\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n\n\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Checks if the value is an empty value\n   */\n\n\n  get isEmpty() {\n    return this.length === 0;\n  }\n  /**\n   * @description The length of the value\n   */\n\n\n  get length() {\n    // only included here since we ignore inherited docs\n    return super.length;\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n\n\n  eq(other) {\n    return compareArray(this, other);\n  }\n  /**\n   * @description Converts the Object to an standard JavaScript Array\n   */\n\n\n  toArray() {\n    return Array.from(this);\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n\n\n  toHex() {\n    return u8aToHex(this.toU8a());\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman(isExtended) {\n    return this.map(entry => entry.toHuman(isExtended));\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n\n\n  toJSON() {\n    return this.map(entry => entry.toJSON());\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n  /**\n   * @description Returns the string representation of the value\n   */\n\n\n  toString() {\n    // Overwrite the default toString representation of Array.\n    const data = this.map(entry => entry.toString());\n    return `[${data.join(', ')}]`;\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    const encoded = this.map(entry => entry.toU8a(isBare));\n    return isBare ? u8aConcat(...encoded) : u8aConcat(compactToU8a(this.length), ...encoded);\n  } // Below are methods that we override. When we do a `new Vec(...).map()`,\n  // we want it to return an Array. We only override the methods that return a\n  // new instance.\n\n  /**\n   * @description Concatenates two arrays\n   */\n\n\n  concat(other) {\n    return this.toArray().concat(other instanceof AbstractArray ? other.toArray() : other);\n  }\n  /**\n   * @description Filters the array with the callback\n   */\n\n\n  filter(callbackfn, thisArg) {\n    return this.toArray().filter(callbackfn, thisArg);\n  }\n  /**\n   * @description Maps the array with the callback\n   */\n\n\n  map(callbackfn, thisArg) {\n    return this.toArray().map(callbackfn, thisArg);\n  }\n  /**\n   * @description Checks if the array includes a specific value\n   */\n\n\n  includes(check) {\n    return this.some(value => value.eq(check));\n  }\n  /**\n   * @description Returns a slice of an array\n   */\n\n\n  slice(start, end) {\n    return this.toArray().slice(start, end);\n  }\n\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/types/codec/AbstractArray.js"],"names":["compactToU8a","u8aConcat","u8aToHex","compareArray","AbstractArray","Array","constructor","registry","values","length","createdAtHash","i","encodedLength","reduce","total","entry","hash","toU8a","isEmpty","eq","other","toArray","from","toHex","toHuman","isExtended","map","toJSON","toString","data","join","isBare","encoded","concat","filter","callbackfn","thisArg","includes","check","some","value","slice","start","end"],"mappings":"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","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { compactToU8a, u8aConcat, u8aToHex } from '@polkadot/util';\nimport { compareArray } from \"./utils/compareArray.js\";\n/**\n * @name AbstractArray\n * @description\n * This manages codec arrays. It is an extension to Array, providing\n * specific encoding/decoding on top of the base type.\n * @noInheritDoc\n */\n\nexport class AbstractArray extends Array {\n  constructor(registry, values) {\n    super(values.length);\n    this.registry = void 0;\n    this.createdAtHash = void 0;\n\n    for (let i = 0; i < values.length; i++) {\n      this[i] = values[i];\n    }\n\n    this.registry = registry;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return this.reduce((total, entry) => total + entry.encodedLength, compactToU8a(this.length).length);\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n\n\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Checks if the value is an empty value\n   */\n\n\n  get isEmpty() {\n    return this.length === 0;\n  }\n  /**\n   * @description The length of the value\n   */\n\n\n  get length() {\n    // only included here since we ignore inherited docs\n    return super.length;\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n\n\n  eq(other) {\n    return compareArray(this, other);\n  }\n  /**\n   * @description Converts the Object to an standard JavaScript Array\n   */\n\n\n  toArray() {\n    return Array.from(this);\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n\n\n  toHex() {\n    return u8aToHex(this.toU8a());\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman(isExtended) {\n    return this.map(entry => entry.toHuman(isExtended));\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n\n\n  toJSON() {\n    return this.map(entry => entry.toJSON());\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  /**\n   * @description Returns the string representation of the value\n   */\n  toString() {\n    // Overwrite the default toString representation of Array.\n    const data = this.map(entry => entry.toString());\n    return `[${data.join(', ')}]`;\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    const encoded = this.map(entry => entry.toU8a(isBare));\n    return isBare ? u8aConcat(...encoded) : u8aConcat(compactToU8a(this.length), ...encoded);\n  } // Below are methods that we override. When we do a `new Vec(...).map()`,\n  // we want it to return an Array. We only override the methods that return a\n  // new instance.\n\n  /**\n   * @description Concatenates two arrays\n   */\n\n\n  concat(other) {\n    return this.toArray().concat(other instanceof AbstractArray ? other.toArray() : other);\n  }\n  /**\n   * @description Filters the array with the callback\n   */\n\n\n  filter(callbackfn, thisArg) {\n    return this.toArray().filter(callbackfn, thisArg);\n  }\n  /**\n   * @description Maps the array with the callback\n   */\n\n\n  map(callbackfn, thisArg) {\n    return this.toArray().map(callbackfn, thisArg);\n  }\n  /**\n   * @description Checks if the array includes a specific value\n   */\n\n\n  includes(check) {\n    return this.some(value => value.eq(check));\n  }\n  /**\n   * @description Returns a slice of an array\n   */\n\n\n  slice(start, end) {\n    return this.toArray().slice(start, end);\n  }\n\n}"]},"metadata":{},"sourceType":"module"}