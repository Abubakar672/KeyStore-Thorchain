{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/api authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { firstValueFrom, map, of, switchMap } from 'rxjs';\nimport { Metadata, TypeRegistry } from '@polkadot/types';\nimport { getSpecAlias, getSpecExtensions, getSpecHasher, getSpecRpc, getSpecTypes, getUpgradeVersion } from '@polkadot/types-known';\nimport { assert, BN_ZERO, logger, stringify, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\nimport { detectedCapabilities } from \"./capabilities.js\";\nimport { Decorate } from \"./Decorate.js\";\nconst KEEPALIVE_INTERVAL = 10000;\nconst l = logger('api/init');\n\nvar _healthTimer = /*#__PURE__*/_classPrivateFieldLooseKey(\"healthTimer\");\n\nvar _registries = /*#__PURE__*/_classPrivateFieldLooseKey(\"registries\");\n\nvar _updateSub = /*#__PURE__*/_classPrivateFieldLooseKey(\"updateSub\");\n\nvar _onProviderConnect = /*#__PURE__*/_classPrivateFieldLooseKey(\"onProviderConnect\");\n\nvar _onProviderDisconnect = /*#__PURE__*/_classPrivateFieldLooseKey(\"onProviderDisconnect\");\n\nvar _onProviderError = /*#__PURE__*/_classPrivateFieldLooseKey(\"onProviderError\");\n\nexport class Init extends Decorate {\n  constructor(options, type, decorateMethod) {\n    super(options, type, decorateMethod); // all injected types added to the registry for overrides\n\n    Object.defineProperty(this, _healthTimer, {\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, _registries, {\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, _updateSub, {\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, _onProviderConnect, {\n      writable: true,\n      value: async () => {\n        this._isConnected.next(true);\n\n        this.emit('connected');\n\n        try {\n          const [hasMeta, cryptoReady] = await Promise.all([this._loadMeta(), this._options.initWasm === false ? Promise.resolve(true) : cryptoWaitReady()]);\n\n          this._subscribeHealth();\n\n          if (hasMeta && !this._isReady && cryptoReady) {\n            this._isReady = true;\n            this.emit('ready', this);\n          }\n        } catch (_error) {\n          const error = new Error(`FATAL: Unable to initialize the API: ${_error.message}`);\n          l.error(error);\n          this.emit('error', error);\n        }\n      }\n    });\n    Object.defineProperty(this, _onProviderDisconnect, {\n      writable: true,\n      value: () => {\n        this._isConnected.next(false);\n\n        this._unsubscribeHealth();\n\n        this.emit('disconnected');\n      }\n    });\n    Object.defineProperty(this, _onProviderError, {\n      writable: true,\n      value: error => {\n        this.emit('error', error);\n      }\n    });\n    this.registry.setKnownTypes(options); // We only register the types (global) if this is not a cloned instance.\n    // Do right up-front, so we get in the user types before we are actually\n    // doing anything on-chain, this ensures we have the overrides in-place\n\n    if (!options.source) {\n      this.registerTypes(options.types);\n    } else {\n      _classPrivateFieldLooseBase(this, _registries)[_registries] = _classPrivateFieldLooseBase(options.source, _registries)[_registries];\n    }\n\n    this._rpc = this._decorateRpc(this._rpcCore, this._decorateMethod);\n    this._rx.rpc = this._decorateRpc(this._rpcCore, this._rxDecorateMethod);\n\n    if (this.supportMulti) {\n      this._queryMulti = this._decorateMulti(this._decorateMethod);\n      this._rx.queryMulti = this._decorateMulti(this._rxDecorateMethod);\n    }\n\n    this._rx.signer = options.signer;\n\n    this._rpcCore.setRegistrySwap(blockHash => this.getBlockRegistry(blockHash));\n\n    if (this.hasSubscriptions) {\n      this._rpcCore.provider.on('disconnected', _classPrivateFieldLooseBase(this, _onProviderDisconnect)[_onProviderDisconnect]);\n\n      this._rpcCore.provider.on('error', _classPrivateFieldLooseBase(this, _onProviderError)[_onProviderError]);\n\n      this._rpcCore.provider.on('connected', _classPrivateFieldLooseBase(this, _onProviderConnect)[_onProviderConnect]);\n    } else {\n      l.warn('Api will be available in a limited mode since the provider does not support subscriptions');\n    } // If the provider was instantiated earlier, and has already emitted a\n    // 'connected' event, then the `on('connected')` won't fire anymore. To\n    // cater for this case, we call manually `this._onProviderConnect`.\n\n\n    if (this._rpcCore.provider.isConnected) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      _classPrivateFieldLooseBase(this, _onProviderConnect)[_onProviderConnect]();\n    }\n  }\n  /**\n   * @description Decorates a registry based on the runtime version\n   */\n\n\n  _initRegistry(registry, chain, version, metadata, chainProps) {\n    registry.setChainProperties(chainProps || this.registry.getChainProperties());\n    registry.setKnownTypes(this._options);\n    registry.register(getSpecTypes(registry, chain, version.specName, version.specVersion));\n    registry.setHasher(getSpecHasher(registry, chain, version.specName)); // for bundled types, pull through the aliases defined\n\n    if (registry.knownTypes.typesBundle) {\n      registry.knownTypes.typesAlias = getSpecAlias(registry, chain, version.specName);\n    }\n\n    registry.setMetadata(metadata, undefined, _objectSpread(_objectSpread({}, getSpecExtensions(registry, chain, version.specName)), this._options.signedExtensions || {}));\n  }\n  /**\n   * @description Returns the default versioned registry\n   */\n\n\n  _getDefaultRegistry() {\n    // get the default registry version\n    const thisRegistry = _classPrivateFieldLooseBase(this, _registries)[_registries].find(({\n      isDefault\n    }) => isDefault);\n\n    assert(thisRegistry, 'Initialization error, cannot find the default registry');\n    return thisRegistry;\n  }\n  /**\n   * @description Returns a decorated API instance at a specific point in time\n   */\n\n\n  async at(blockHash) {\n    const u8aHash = u8aToU8a(blockHash);\n    const registry = await this.getBlockRegistry(u8aHash); // always create a new decoration for this specific hash\n\n    return this._createDecorated(registry, true, u8aHash).decoratedApi;\n  }\n  /**\n   * @description Sets up a registry based on the block hash defined\n   */\n\n\n  async getBlockRegistry(blockHash) {\n    const existingViaHash = _classPrivateFieldLooseBase(this, _registries)[_registries].find(({\n      lastBlockHash\n    }) => lastBlockHash && u8aEq(lastBlockHash, blockHash));\n\n    if (existingViaHash) {\n      return existingViaHash;\n    } // ensure we have everything required\n\n\n    assert(this._genesisHash && this._runtimeVersion, 'Cannot retrieve data on an uninitialized chain'); // We have to assume that on the RPC layer the calls used here does not call back into\n    // the registry swap, so getHeader & getRuntimeVersion should not be historic\n\n    const header = this.registry.createType('HeaderPartial', this._genesisHash.eq(blockHash) ? {\n      number: BN_ZERO,\n      parentHash: this._genesisHash\n    } : await firstValueFrom(this._rpcCore.chain.getHeader.json(blockHash)));\n    assert(!header.parentHash.isEmpty, 'Unable to retrieve header and parent from supplied hash'); // get the runtime version, either on-chain or via an known upgrade history\n\n    const [firstVersion, lastVersion] = getUpgradeVersion(this._genesisHash, header.number);\n    const version = this.registry.createType('RuntimeVersionPartial', firstVersion && (lastVersion || firstVersion.specVersion.eq(this._runtimeVersion.specVersion)) ? {\n      specName: this._runtimeVersion.specName,\n      specVersion: firstVersion.specVersion\n    } : await firstValueFrom(this._rpcCore.state.getRuntimeVersion.json(header.parentHash))); // check for pre-existing registries. We also check specName, e.g. it\n    // could be changed like in Westmint with upgrade from  shell -> westmint\n\n    const existingViaVersion = _classPrivateFieldLooseBase(this, _registries)[_registries].find(({\n      specName,\n      specVersion\n    }) => specName.eq(version.specName) && specVersion.eq(version.specVersion));\n\n    if (existingViaVersion) {\n      existingViaVersion.lastBlockHash = blockHash;\n      return existingViaVersion;\n    } // nothing has been found, construct new\n\n\n    const registry = new TypeRegistry(blockHash);\n    const metadata = new Metadata(registry, await firstValueFrom(this._rpcCore.state.getMetadata.raw(header.parentHash)));\n\n    this._initRegistry(registry, this._runtimeChain, version, metadata); // add our new registry\n\n\n    const result = {\n      lastBlockHash: blockHash,\n      metadata,\n      registry,\n      specName: version.specName,\n      specVersion: version.specVersion\n    };\n\n    _classPrivateFieldLooseBase(this, _registries)[_registries].push(result); // TODO This could be useful for historic, disabled due to cross-looping, i.e. .at queries\n    // this._detectCapabilities(registry, blockHash);\n\n\n    return result;\n  }\n\n  async _loadMeta() {\n    var _this$_options$source; // on re-connection to the same chain, we don't want to re-do everything from chain again\n\n\n    if (this._isReady) {\n      return true;\n    }\n\n    this._unsubscribeUpdates(); // only load from on-chain if we are not a clone (default path), alternatively\n    // just use the values from the source instance provided\n\n\n    [this._genesisHash, this._runtimeMetadata] = (_this$_options$source = this._options.source) !== null && _this$_options$source !== void 0 && _this$_options$source._isReady ? await this._metaFromSource(this._options.source) : await this._metaFromChain(this._options.metadata);\n    return this._initFromMeta(this._runtimeMetadata);\n  } // eslint-disable-next-line @typescript-eslint/require-await\n\n\n  async _metaFromSource(source) {\n    this._extrinsicType = source.extrinsicVersion;\n    this._runtimeChain = source.runtimeChain;\n    this._runtimeVersion = source.runtimeVersion;\n    const methods = []; // manually build a list of all available methods in this RPC, we are\n    // going to filter on it to align the cloned RPC without making a call\n\n    Object.keys(source.rpc).forEach(section => {\n      Object.keys(source.rpc[section]).forEach(method => {\n        methods.push(`${section}_${method}`);\n      });\n    });\n\n    this._filterRpc(methods, getSpecRpc(this.registry, source.runtimeChain, source.runtimeVersion.specName));\n\n    return [source.genesisHash, source.runtimeMetadata];\n  }\n\n  _detectCapabilities(registry, blockHash) {\n    firstValueFrom(detectedCapabilities(this._rx, blockHash)).then(types => {\n      if (Object.keys(types).length) {\n        registry.register(types);\n        l.debug(() => `Capabilities detected${blockHash ? ` (${u8aToHex(u8aToU8a(blockHash))})` : ''}: ${stringify(types)}`);\n      }\n    }).catch(undefined);\n    return true;\n  } // subscribe to metadata updates, inject the types on changes\n\n\n  _subscribeUpdates() {\n    if (_classPrivateFieldLooseBase(this, _updateSub)[_updateSub] || !this.hasSubscriptions) {\n      return;\n    }\n\n    _classPrivateFieldLooseBase(this, _updateSub)[_updateSub] = this._rpcCore.state.subscribeRuntimeVersion().pipe(switchMap(version => {\n      var _this$_runtimeVersion;\n\n      return (// only retrieve the metadata when the on-chain version has been changed\n        (_this$_runtimeVersion = this._runtimeVersion) !== null && _this$_runtimeVersion !== void 0 && _this$_runtimeVersion.specVersion.eq(version.specVersion) ? of(false) : this._rpcCore.state.getMetadata().pipe(map(metadata => {\n          l.log(`Runtime version updated to spec=${version.specVersion.toString()}, tx=${version.transactionVersion.toString()}`);\n          this._runtimeMetadata = metadata;\n          this._runtimeVersion = version;\n          this._rx.runtimeVersion = version; // update the default registry version\n\n          const thisRegistry = this._getDefaultRegistry(); // setup the data as per the current versions\n\n\n          thisRegistry.metadata = metadata;\n          thisRegistry.specVersion = version.specVersion; // clear the registry types to ensure that we override correctly\n\n          this._initRegistry(thisRegistry.registry.init(), this._runtimeChain, version, metadata);\n\n          this._injectMetadata(thisRegistry, false);\n\n          return this._detectCapabilities(thisRegistry.registry);\n        }))\n      );\n    })).subscribe();\n  }\n\n  async _metaFromChain(optMetadata) {\n    const [genesisHash, runtimeVersion, chain, chainProps, rpcMethods, chainMetadata] = await Promise.all([firstValueFrom(this._rpcCore.chain.getBlockHash(0)), firstValueFrom(this._rpcCore.state.getRuntimeVersion()), firstValueFrom(this._rpcCore.system.chain()), firstValueFrom(this._rpcCore.system.properties()), firstValueFrom(this._rpcCore.rpc.methods()), optMetadata ? Promise.resolve(null) : firstValueFrom(this._rpcCore.state.getMetadata())]); // set our chain version & genesisHash as returned\n\n    this._runtimeChain = chain;\n    this._runtimeVersion = runtimeVersion;\n    this._rx.runtimeVersion = runtimeVersion; // retrieve metadata, either from chain  or as pass-in via options\n\n    const metadataKey = `${genesisHash.toHex() || '0x'}-${runtimeVersion.specVersion.toString()}`;\n    const metadata = chainMetadata || (optMetadata && optMetadata[metadataKey] ? new Metadata(this.registry, optMetadata[metadataKey]) : await firstValueFrom(this._rpcCore.state.getMetadata())); // initializes the registry & RPC\n\n    this._initRegistry(this.registry, chain, runtimeVersion, metadata, chainProps);\n\n    this._filterRpc(rpcMethods.methods.map(t => t.toString()), getSpecRpc(this.registry, chain, runtimeVersion.specName));\n\n    this._subscribeUpdates(); // setup the initial registry, when we have none\n\n\n    if (!_classPrivateFieldLooseBase(this, _registries)[_registries].length) {\n      _classPrivateFieldLooseBase(this, _registries)[_registries].push({\n        isDefault: true,\n        metadata,\n        registry: this.registry,\n        specName: runtimeVersion.specName,\n        specVersion: runtimeVersion.specVersion\n      });\n    } // get unique types & validate\n\n\n    metadata.getUniqTypes(this._options.throwOnUnknown || false);\n    return [genesisHash, metadata];\n  }\n\n  _initFromMeta(metadata) {\n    this._extrinsicType = metadata.asLatest.extrinsic.version.toNumber();\n    this._rx.extrinsicType = this._extrinsicType;\n    this._rx.genesisHash = this._genesisHash;\n    this._rx.runtimeVersion = this._runtimeVersion; // must be set here\n    // inject metadata and adjust the types as detected\n\n    this._injectMetadata(this._getDefaultRegistry(), true); // derive is last, since it uses the decorated rx\n\n\n    this._rx.derive = this._decorateDeriveRx(this._rxDecorateMethod);\n    this._derive = this._decorateDerive(this._decorateMethod); // detect the on-chain capabilities\n\n    this._detectCapabilities(this.registry);\n\n    return true;\n  }\n\n  _subscribeHealth() {\n    // Only enable the health keepalive on WS, not needed on HTTP\n    _classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer] = this.hasSubscriptions ? setInterval(() => {\n      firstValueFrom(this._rpcCore.system.health()).catch(() => undefined);\n    }, KEEPALIVE_INTERVAL) : null;\n  }\n\n  _unsubscribeHealth() {\n    if (_classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer]) {\n      clearInterval(_classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer]);\n      _classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer] = null;\n    }\n  }\n\n  _unsubscribeUpdates() {\n    if (_classPrivateFieldLooseBase(this, _updateSub)[_updateSub]) {\n      _classPrivateFieldLooseBase(this, _updateSub)[_updateSub].unsubscribe();\n\n      _classPrivateFieldLooseBase(this, _updateSub)[_updateSub] = null;\n    }\n  }\n\n  _unsubscribe() {\n    this._unsubscribeHealth();\n\n    this._unsubscribeUpdates();\n  }\n\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/api/base/Init.js"],"names":["_defineProperty","_classPrivateFieldLooseBase","_classPrivateFieldLooseKey","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","firstValueFrom","map","of","switchMap","Metadata","TypeRegistry","getSpecAlias","getSpecExtensions","getSpecHasher","getSpecRpc","getSpecTypes","getUpgradeVersion","assert","BN_ZERO","logger","stringify","u8aEq","u8aToHex","u8aToU8a","cryptoWaitReady","detectedCapabilities","Decorate","KEEPALIVE_INTERVAL","l","_healthTimer","_registries","_updateSub","_onProviderConnect","_onProviderDisconnect","_onProviderError","Init","constructor","options","type","decorateMethod","writable","value","_isConnected","next","emit","hasMeta","cryptoReady","Promise","all","_loadMeta","_options","initWasm","resolve","_subscribeHealth","_isReady","_error","error","Error","message","_unsubscribeHealth","registry","setKnownTypes","registerTypes","types","_rpc","_decorateRpc","_rpcCore","_decorateMethod","_rx","rpc","_rxDecorateMethod","supportMulti","_queryMulti","_decorateMulti","queryMulti","signer","setRegistrySwap","blockHash","getBlockRegistry","hasSubscriptions","provider","on","warn","isConnected","_initRegistry","chain","version","metadata","chainProps","setChainProperties","getChainProperties","register","specName","specVersion","setHasher","knownTypes","typesBundle","typesAlias","setMetadata","undefined","signedExtensions","_getDefaultRegistry","thisRegistry","find","isDefault","at","u8aHash","_createDecorated","decoratedApi","existingViaHash","lastBlockHash","_genesisHash","_runtimeVersion","header","createType","eq","number","parentHash","getHeader","json","isEmpty","firstVersion","lastVersion","state","getRuntimeVersion","existingViaVersion","getMetadata","raw","_runtimeChain","result","_this$_options$source","_unsubscribeUpdates","_runtimeMetadata","_metaFromSource","_metaFromChain","_initFromMeta","_extrinsicType","extrinsicVersion","runtimeChain","runtimeVersion","methods","section","method","_filterRpc","genesisHash","runtimeMetadata","_detectCapabilities","then","debug","catch","_subscribeUpdates","subscribeRuntimeVersion","pipe","_this$_runtimeVersion","log","toString","transactionVersion","init","_injectMetadata","subscribe","optMetadata","rpcMethods","chainMetadata","getBlockHash","system","properties","metadataKey","toHex","t","getUniqTypes","throwOnUnknown","asLatest","extrinsic","toNumber","extrinsicType","derive","_decorateDeriveRx","_derive","_decorateDerive","setInterval","health","clearInterval","unsubscribe","_unsubscribe"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/api authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { firstValueFrom, map, of, switchMap } from 'rxjs';\nimport { Metadata, TypeRegistry } from '@polkadot/types';\nimport { getSpecAlias, getSpecExtensions, getSpecHasher, getSpecRpc, getSpecTypes, getUpgradeVersion } from '@polkadot/types-known';\nimport { assert, BN_ZERO, logger, stringify, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\nimport { detectedCapabilities } from \"./capabilities.js\";\nimport { Decorate } from \"./Decorate.js\";\nconst KEEPALIVE_INTERVAL = 10000;\nconst l = logger('api/init');\n\nvar _healthTimer = /*#__PURE__*/_classPrivateFieldLooseKey(\"healthTimer\");\n\nvar _registries = /*#__PURE__*/_classPrivateFieldLooseKey(\"registries\");\n\nvar _updateSub = /*#__PURE__*/_classPrivateFieldLooseKey(\"updateSub\");\n\nvar _onProviderConnect = /*#__PURE__*/_classPrivateFieldLooseKey(\"onProviderConnect\");\n\nvar _onProviderDisconnect = /*#__PURE__*/_classPrivateFieldLooseKey(\"onProviderDisconnect\");\n\nvar _onProviderError = /*#__PURE__*/_classPrivateFieldLooseKey(\"onProviderError\");\n\nexport class Init extends Decorate {\n  constructor(options, type, decorateMethod) {\n    super(options, type, decorateMethod); // all injected types added to the registry for overrides\n\n    Object.defineProperty(this, _healthTimer, {\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, _registries, {\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, _updateSub, {\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, _onProviderConnect, {\n      writable: true,\n      value: async () => {\n        this._isConnected.next(true);\n\n        this.emit('connected');\n\n        try {\n          const [hasMeta, cryptoReady] = await Promise.all([this._loadMeta(), this._options.initWasm === false ? Promise.resolve(true) : cryptoWaitReady()]);\n\n          this._subscribeHealth();\n\n          if (hasMeta && !this._isReady && cryptoReady) {\n            this._isReady = true;\n            this.emit('ready', this);\n          }\n        } catch (_error) {\n          const error = new Error(`FATAL: Unable to initialize the API: ${_error.message}`);\n          l.error(error);\n          this.emit('error', error);\n        }\n      }\n    });\n    Object.defineProperty(this, _onProviderDisconnect, {\n      writable: true,\n      value: () => {\n        this._isConnected.next(false);\n\n        this._unsubscribeHealth();\n\n        this.emit('disconnected');\n      }\n    });\n    Object.defineProperty(this, _onProviderError, {\n      writable: true,\n      value: error => {\n        this.emit('error', error);\n      }\n    });\n    this.registry.setKnownTypes(options); // We only register the types (global) if this is not a cloned instance.\n    // Do right up-front, so we get in the user types before we are actually\n    // doing anything on-chain, this ensures we have the overrides in-place\n\n    if (!options.source) {\n      this.registerTypes(options.types);\n    } else {\n      _classPrivateFieldLooseBase(this, _registries)[_registries] = _classPrivateFieldLooseBase(options.source, _registries)[_registries];\n    }\n\n    this._rpc = this._decorateRpc(this._rpcCore, this._decorateMethod);\n    this._rx.rpc = this._decorateRpc(this._rpcCore, this._rxDecorateMethod);\n\n    if (this.supportMulti) {\n      this._queryMulti = this._decorateMulti(this._decorateMethod);\n      this._rx.queryMulti = this._decorateMulti(this._rxDecorateMethod);\n    }\n\n    this._rx.signer = options.signer;\n\n    this._rpcCore.setRegistrySwap(blockHash => this.getBlockRegistry(blockHash));\n\n    if (this.hasSubscriptions) {\n      this._rpcCore.provider.on('disconnected', _classPrivateFieldLooseBase(this, _onProviderDisconnect)[_onProviderDisconnect]);\n\n      this._rpcCore.provider.on('error', _classPrivateFieldLooseBase(this, _onProviderError)[_onProviderError]);\n\n      this._rpcCore.provider.on('connected', _classPrivateFieldLooseBase(this, _onProviderConnect)[_onProviderConnect]);\n    } else {\n      l.warn('Api will be available in a limited mode since the provider does not support subscriptions');\n    } // If the provider was instantiated earlier, and has already emitted a\n    // 'connected' event, then the `on('connected')` won't fire anymore. To\n    // cater for this case, we call manually `this._onProviderConnect`.\n\n\n    if (this._rpcCore.provider.isConnected) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      _classPrivateFieldLooseBase(this, _onProviderConnect)[_onProviderConnect]();\n    }\n  }\n  /**\n   * @description Decorates a registry based on the runtime version\n   */\n\n\n  _initRegistry(registry, chain, version, metadata, chainProps) {\n    registry.setChainProperties(chainProps || this.registry.getChainProperties());\n    registry.setKnownTypes(this._options);\n    registry.register(getSpecTypes(registry, chain, version.specName, version.specVersion));\n    registry.setHasher(getSpecHasher(registry, chain, version.specName)); // for bundled types, pull through the aliases defined\n\n    if (registry.knownTypes.typesBundle) {\n      registry.knownTypes.typesAlias = getSpecAlias(registry, chain, version.specName);\n    }\n\n    registry.setMetadata(metadata, undefined, _objectSpread(_objectSpread({}, getSpecExtensions(registry, chain, version.specName)), this._options.signedExtensions || {}));\n  }\n  /**\n   * @description Returns the default versioned registry\n   */\n\n\n  _getDefaultRegistry() {\n    // get the default registry version\n    const thisRegistry = _classPrivateFieldLooseBase(this, _registries)[_registries].find(({\n      isDefault\n    }) => isDefault);\n\n    assert(thisRegistry, 'Initialization error, cannot find the default registry');\n    return thisRegistry;\n  }\n  /**\n   * @description Returns a decorated API instance at a specific point in time\n   */\n\n\n  async at(blockHash) {\n    const u8aHash = u8aToU8a(blockHash);\n    const registry = await this.getBlockRegistry(u8aHash); // always create a new decoration for this specific hash\n\n    return this._createDecorated(registry, true, u8aHash).decoratedApi;\n  }\n  /**\n   * @description Sets up a registry based on the block hash defined\n   */\n\n\n  async getBlockRegistry(blockHash) {\n    const existingViaHash = _classPrivateFieldLooseBase(this, _registries)[_registries].find(({\n      lastBlockHash\n    }) => lastBlockHash && u8aEq(lastBlockHash, blockHash));\n\n    if (existingViaHash) {\n      return existingViaHash;\n    } // ensure we have everything required\n\n\n    assert(this._genesisHash && this._runtimeVersion, 'Cannot retrieve data on an uninitialized chain'); // We have to assume that on the RPC layer the calls used here does not call back into\n    // the registry swap, so getHeader & getRuntimeVersion should not be historic\n\n    const header = this.registry.createType('HeaderPartial', this._genesisHash.eq(blockHash) ? {\n      number: BN_ZERO,\n      parentHash: this._genesisHash\n    } : await firstValueFrom(this._rpcCore.chain.getHeader.json(blockHash)));\n    assert(!header.parentHash.isEmpty, 'Unable to retrieve header and parent from supplied hash'); // get the runtime version, either on-chain or via an known upgrade history\n\n    const [firstVersion, lastVersion] = getUpgradeVersion(this._genesisHash, header.number);\n    const version = this.registry.createType('RuntimeVersionPartial', firstVersion && (lastVersion || firstVersion.specVersion.eq(this._runtimeVersion.specVersion)) ? {\n      specName: this._runtimeVersion.specName,\n      specVersion: firstVersion.specVersion\n    } : await firstValueFrom(this._rpcCore.state.getRuntimeVersion.json(header.parentHash))); // check for pre-existing registries. We also check specName, e.g. it\n    // could be changed like in Westmint with upgrade from  shell -> westmint\n\n    const existingViaVersion = _classPrivateFieldLooseBase(this, _registries)[_registries].find(({\n      specName,\n      specVersion\n    }) => specName.eq(version.specName) && specVersion.eq(version.specVersion));\n\n    if (existingViaVersion) {\n      existingViaVersion.lastBlockHash = blockHash;\n      return existingViaVersion;\n    } // nothing has been found, construct new\n\n\n    const registry = new TypeRegistry(blockHash);\n    const metadata = new Metadata(registry, await firstValueFrom(this._rpcCore.state.getMetadata.raw(header.parentHash)));\n\n    this._initRegistry(registry, this._runtimeChain, version, metadata); // add our new registry\n\n\n    const result = {\n      lastBlockHash: blockHash,\n      metadata,\n      registry,\n      specName: version.specName,\n      specVersion: version.specVersion\n    };\n\n    _classPrivateFieldLooseBase(this, _registries)[_registries].push(result); // TODO This could be useful for historic, disabled due to cross-looping, i.e. .at queries\n    // this._detectCapabilities(registry, blockHash);\n\n\n    return result;\n  }\n\n  async _loadMeta() {\n    var _this$_options$source;\n\n    // on re-connection to the same chain, we don't want to re-do everything from chain again\n    if (this._isReady) {\n      return true;\n    }\n\n    this._unsubscribeUpdates(); // only load from on-chain if we are not a clone (default path), alternatively\n    // just use the values from the source instance provided\n\n\n    [this._genesisHash, this._runtimeMetadata] = (_this$_options$source = this._options.source) !== null && _this$_options$source !== void 0 && _this$_options$source._isReady ? await this._metaFromSource(this._options.source) : await this._metaFromChain(this._options.metadata);\n    return this._initFromMeta(this._runtimeMetadata);\n  } // eslint-disable-next-line @typescript-eslint/require-await\n\n\n  async _metaFromSource(source) {\n    this._extrinsicType = source.extrinsicVersion;\n    this._runtimeChain = source.runtimeChain;\n    this._runtimeVersion = source.runtimeVersion;\n    const methods = []; // manually build a list of all available methods in this RPC, we are\n    // going to filter on it to align the cloned RPC without making a call\n\n    Object.keys(source.rpc).forEach(section => {\n      Object.keys(source.rpc[section]).forEach(method => {\n        methods.push(`${section}_${method}`);\n      });\n    });\n\n    this._filterRpc(methods, getSpecRpc(this.registry, source.runtimeChain, source.runtimeVersion.specName));\n\n    return [source.genesisHash, source.runtimeMetadata];\n  }\n\n  _detectCapabilities(registry, blockHash) {\n    firstValueFrom(detectedCapabilities(this._rx, blockHash)).then(types => {\n      if (Object.keys(types).length) {\n        registry.register(types);\n        l.debug(() => `Capabilities detected${blockHash ? ` (${u8aToHex(u8aToU8a(blockHash))})` : ''}: ${stringify(types)}`);\n      }\n    }).catch(undefined);\n    return true;\n  } // subscribe to metadata updates, inject the types on changes\n\n\n  _subscribeUpdates() {\n    if (_classPrivateFieldLooseBase(this, _updateSub)[_updateSub] || !this.hasSubscriptions) {\n      return;\n    }\n\n    _classPrivateFieldLooseBase(this, _updateSub)[_updateSub] = this._rpcCore.state.subscribeRuntimeVersion().pipe(switchMap(version => {\n      var _this$_runtimeVersion;\n\n      return (// only retrieve the metadata when the on-chain version has been changed\n        (_this$_runtimeVersion = this._runtimeVersion) !== null && _this$_runtimeVersion !== void 0 && _this$_runtimeVersion.specVersion.eq(version.specVersion) ? of(false) : this._rpcCore.state.getMetadata().pipe(map(metadata => {\n          l.log(`Runtime version updated to spec=${version.specVersion.toString()}, tx=${version.transactionVersion.toString()}`);\n          this._runtimeMetadata = metadata;\n          this._runtimeVersion = version;\n          this._rx.runtimeVersion = version; // update the default registry version\n\n          const thisRegistry = this._getDefaultRegistry(); // setup the data as per the current versions\n\n\n          thisRegistry.metadata = metadata;\n          thisRegistry.specVersion = version.specVersion; // clear the registry types to ensure that we override correctly\n\n          this._initRegistry(thisRegistry.registry.init(), this._runtimeChain, version, metadata);\n\n          this._injectMetadata(thisRegistry, false);\n\n          return this._detectCapabilities(thisRegistry.registry);\n        }))\n      );\n    })).subscribe();\n  }\n\n  async _metaFromChain(optMetadata) {\n    const [genesisHash, runtimeVersion, chain, chainProps, rpcMethods, chainMetadata] = await Promise.all([firstValueFrom(this._rpcCore.chain.getBlockHash(0)), firstValueFrom(this._rpcCore.state.getRuntimeVersion()), firstValueFrom(this._rpcCore.system.chain()), firstValueFrom(this._rpcCore.system.properties()), firstValueFrom(this._rpcCore.rpc.methods()), optMetadata ? Promise.resolve(null) : firstValueFrom(this._rpcCore.state.getMetadata())]); // set our chain version & genesisHash as returned\n\n    this._runtimeChain = chain;\n    this._runtimeVersion = runtimeVersion;\n    this._rx.runtimeVersion = runtimeVersion; // retrieve metadata, either from chain  or as pass-in via options\n\n    const metadataKey = `${genesisHash.toHex() || '0x'}-${runtimeVersion.specVersion.toString()}`;\n    const metadata = chainMetadata || (optMetadata && optMetadata[metadataKey] ? new Metadata(this.registry, optMetadata[metadataKey]) : await firstValueFrom(this._rpcCore.state.getMetadata())); // initializes the registry & RPC\n\n    this._initRegistry(this.registry, chain, runtimeVersion, metadata, chainProps);\n\n    this._filterRpc(rpcMethods.methods.map(t => t.toString()), getSpecRpc(this.registry, chain, runtimeVersion.specName));\n\n    this._subscribeUpdates(); // setup the initial registry, when we have none\n\n\n    if (!_classPrivateFieldLooseBase(this, _registries)[_registries].length) {\n      _classPrivateFieldLooseBase(this, _registries)[_registries].push({\n        isDefault: true,\n        metadata,\n        registry: this.registry,\n        specName: runtimeVersion.specName,\n        specVersion: runtimeVersion.specVersion\n      });\n    } // get unique types & validate\n\n\n    metadata.getUniqTypes(this._options.throwOnUnknown || false);\n    return [genesisHash, metadata];\n  }\n\n  _initFromMeta(metadata) {\n    this._extrinsicType = metadata.asLatest.extrinsic.version.toNumber();\n    this._rx.extrinsicType = this._extrinsicType;\n    this._rx.genesisHash = this._genesisHash;\n    this._rx.runtimeVersion = this._runtimeVersion; // must be set here\n    // inject metadata and adjust the types as detected\n\n    this._injectMetadata(this._getDefaultRegistry(), true); // derive is last, since it uses the decorated rx\n\n\n    this._rx.derive = this._decorateDeriveRx(this._rxDecorateMethod);\n    this._derive = this._decorateDerive(this._decorateMethod); // detect the on-chain capabilities\n\n    this._detectCapabilities(this.registry);\n\n    return true;\n  }\n\n  _subscribeHealth() {\n    // Only enable the health keepalive on WS, not needed on HTTP\n    _classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer] = this.hasSubscriptions ? setInterval(() => {\n      firstValueFrom(this._rpcCore.system.health()).catch(() => undefined);\n    }, KEEPALIVE_INTERVAL) : null;\n  }\n\n  _unsubscribeHealth() {\n    if (_classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer]) {\n      clearInterval(_classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer]);\n      _classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer] = null;\n    }\n  }\n\n  _unsubscribeUpdates() {\n    if (_classPrivateFieldLooseBase(this, _updateSub)[_updateSub]) {\n      _classPrivateFieldLooseBase(this, _updateSub)[_updateSub].unsubscribe();\n\n      _classPrivateFieldLooseBase(this, _updateSub)[_updateSub] = null;\n    }\n  }\n\n  _unsubscribe() {\n    this._unsubscribeHealth();\n\n    this._unsubscribeUpdates();\n  }\n\n}"]},"metadata":{},"sourceType":"module"}