{"ast":null,"code":"// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { isFunction, isHex, isString, isU8a, stringify, u8aConcat, u8aToU8a } from '@polkadot/util';\nimport { AbstractArray } from \"./AbstractArray.js\";\nimport { decodeU8a, mapToTypeMap, typeToConstructor } from \"./utils/index.js\";\n/** @internal */\n\nfunction decodeTuple(registry, _Types, value) {\n  if (isU8a(value) || isHex(value)) {\n    return decodeU8a(registry, u8aToU8a(value), _Types);\n  }\n\n  const Types = Array.isArray(_Types) ? _Types : Object.values(_Types);\n  return Types.map((Type, index) => {\n    try {\n      const entry = value === null || value === void 0 ? void 0 : value[index];\n\n      if (entry instanceof Type) {\n        return entry;\n      }\n\n      return new Type(registry, entry);\n    } catch (error) {\n      throw new Error(`Tuple: failed on ${index}:: ${error.message}`);\n    }\n  });\n}\n/**\n * @name Tuple\n * @description\n * A Tuple defines an anonymous fixed-length array, where each element has its\n * own type. It extends the base JS `Array` object.\n */\n\n\nexport class Tuple extends AbstractArray {\n  constructor(registry, Types, value) {\n    const Clazzes = Array.isArray(Types) ? Types.map(t => typeToConstructor(registry, t)) : isFunction(Types) || isString(Types) ? [typeToConstructor(registry, Types)] : mapToTypeMap(registry, Types);\n    super(registry, decodeTuple(registry, Clazzes, value));\n    this._Types = void 0;\n    this._Types = Clazzes;\n  }\n\n  static with(Types) {\n    return class extends Tuple {\n      constructor(registry, value) {\n        super(registry, Types, value);\n      }\n\n    };\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return this.reduce((total, entry) => total + entry.encodedLength, 0);\n  }\n  /**\n   * @description The types definition of the tuple\n   */\n\n\n  get Types() {\n    return Array.isArray(this._Types) ? this._Types.map(Type => new Type(this.registry).toRawType()) : Object.keys(this._Types);\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    const types = (Array.isArray(this._Types) ? this._Types : Object.values(this._Types)).map(Type => this.registry.getClassName(Type) || new Type(this.registry).toRawType());\n    return `(${types.join(',')})`;\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n\n\n  toString() {\n    // Overwrite the default toString representation of Array.\n    return stringify(this.toJSON());\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    return u8aConcat(...this.map(entry => entry.toU8a(isBare)));\n  }\n\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/types/codec/Tuple.js"],"names":["isFunction","isHex","isString","isU8a","stringify","u8aConcat","u8aToU8a","AbstractArray","decodeU8a","mapToTypeMap","typeToConstructor","decodeTuple","registry","_Types","value","Types","Array","isArray","Object","values","map","Type","index","entry","error","Error","message","Tuple","constructor","Clazzes","t","with","encodedLength","reduce","total","toRawType","keys","types","getClassName","join","toString","toJSON","toU8a","isBare"],"mappings":"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","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { isFunction, isHex, isString, isU8a, stringify, u8aConcat, u8aToU8a } from '@polkadot/util';\nimport { AbstractArray } from \"./AbstractArray.js\";\nimport { decodeU8a, mapToTypeMap, typeToConstructor } from \"./utils/index.js\";\n\n/** @internal */\nfunction decodeTuple(registry, _Types, value) {\n  if (isU8a(value) || isHex(value)) {\n    return decodeU8a(registry, u8aToU8a(value), _Types);\n  }\n\n  const Types = Array.isArray(_Types) ? _Types : Object.values(_Types);\n  return Types.map((Type, index) => {\n    try {\n      const entry = value === null || value === void 0 ? void 0 : value[index];\n\n      if (entry instanceof Type) {\n        return entry;\n      }\n\n      return new Type(registry, entry);\n    } catch (error) {\n      throw new Error(`Tuple: failed on ${index}:: ${error.message}`);\n    }\n  });\n}\n/**\n * @name Tuple\n * @description\n * A Tuple defines an anonymous fixed-length array, where each element has its\n * own type. It extends the base JS `Array` object.\n */\n\n\nexport class Tuple extends AbstractArray {\n  constructor(registry, Types, value) {\n    const Clazzes = Array.isArray(Types) ? Types.map(t => typeToConstructor(registry, t)) : isFunction(Types) || isString(Types) ? [typeToConstructor(registry, Types)] : mapToTypeMap(registry, Types);\n    super(registry, decodeTuple(registry, Clazzes, value));\n    this._Types = void 0;\n    this._Types = Clazzes;\n  }\n\n  static with(Types) {\n    return class extends Tuple {\n      constructor(registry, value) {\n        super(registry, Types, value);\n      }\n\n    };\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return this.reduce((total, entry) => total + entry.encodedLength, 0);\n  }\n  /**\n   * @description The types definition of the tuple\n   */\n\n\n  get Types() {\n    return Array.isArray(this._Types) ? this._Types.map(Type => new Type(this.registry).toRawType()) : Object.keys(this._Types);\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    const types = (Array.isArray(this._Types) ? this._Types : Object.values(this._Types)).map(Type => this.registry.getClassName(Type) || new Type(this.registry).toRawType());\n    return `(${types.join(',')})`;\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n\n\n  toString() {\n    // Overwrite the default toString representation of Array.\n    return stringify(this.toJSON());\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    return u8aConcat(...this.map(entry => entry.toU8a(isBare)));\n  }\n\n}"]},"metadata":{},"sourceType":"module"}