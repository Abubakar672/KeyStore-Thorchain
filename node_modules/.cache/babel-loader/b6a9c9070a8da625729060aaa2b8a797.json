{"ast":null,"code":"// Copyright 2017-2021 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n// Original implementation: https://github.com/paritytech/polka-ui/blob/4858c094684769080f5811f32b081dd7780b0880/src/polkadot.js#L6\nimport { assert, isHex, isU8a, u8aToU8a } from '@polkadot/util';\nimport { base58Decode } from \"../base58/decode.js\";\nimport { checkAddressChecksum } from \"./checksum.js\";\nimport { defaults } from \"./defaults.js\";\nexport function decodeAddress(encoded, ignoreChecksum, ss58Format = -1) {\n  assert(encoded, 'Invalid empty address passed');\n\n  if (isU8a(encoded) || isHex(encoded)) {\n    return u8aToU8a(encoded);\n  }\n\n  try {\n    const decoded = base58Decode(encoded);\n    assert(defaults.allowedEncodedLengths.includes(decoded.length), 'Invalid decoded address length');\n    const [isValid, endPos, ss58Length, ss58Decoded] = checkAddressChecksum(decoded);\n    assert(ignoreChecksum || isValid, 'Invalid decoded address checksum');\n    assert([-1, ss58Decoded].includes(ss58Format), () => `Expected ss58Format ${ss58Format}, received ${ss58Decoded}`);\n    return decoded.slice(ss58Length, endPos);\n  } catch (error) {\n    throw new Error(`Decoding ${encoded}: ${error.message}`);\n  }\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/util-crypto/address/decode.js"],"names":["assert","isHex","isU8a","u8aToU8a","base58Decode","checkAddressChecksum","defaults","decodeAddress","encoded","ignoreChecksum","ss58Format","decoded","allowedEncodedLengths","includes","length","isValid","endPos","ss58Length","ss58Decoded","slice","error","Error","message"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,MAAT,EAAiBC,KAAjB,EAAwBC,KAAxB,EAA+BC,QAA/B,QAA+C,gBAA/C;AACA,SAASC,YAAT,QAA6B,qBAA7B;AACA,SAASC,oBAAT,QAAqC,eAArC;AACA,SAASC,QAAT,QAAyB,eAAzB;AACA,OAAO,SAASC,aAAT,CAAuBC,OAAvB,EAAgCC,cAAhC,EAAgDC,UAAU,GAAG,CAAC,CAA9D,EAAiE;AACtEV,EAAAA,MAAM,CAACQ,OAAD,EAAU,8BAAV,CAAN;;AAEA,MAAIN,KAAK,CAACM,OAAD,CAAL,IAAkBP,KAAK,CAACO,OAAD,CAA3B,EAAsC;AACpC,WAAOL,QAAQ,CAACK,OAAD,CAAf;AACD;;AAED,MAAI;AACF,UAAMG,OAAO,GAAGP,YAAY,CAACI,OAAD,CAA5B;AACAR,IAAAA,MAAM,CAACM,QAAQ,CAACM,qBAAT,CAA+BC,QAA/B,CAAwCF,OAAO,CAACG,MAAhD,CAAD,EAA0D,gCAA1D,CAAN;AACA,UAAM,CAACC,OAAD,EAAUC,MAAV,EAAkBC,UAAlB,EAA8BC,WAA9B,IAA6Cb,oBAAoB,CAACM,OAAD,CAAvE;AACAX,IAAAA,MAAM,CAACS,cAAc,IAAIM,OAAnB,EAA4B,kCAA5B,CAAN;AACAf,IAAAA,MAAM,CAAC,CAAC,CAAC,CAAF,EAAKkB,WAAL,EAAkBL,QAAlB,CAA2BH,UAA3B,CAAD,EAAyC,MAAO,uBAAsBA,UAAW,cAAaQ,WAAY,EAA1G,CAAN;AACA,WAAOP,OAAO,CAACQ,KAAR,CAAcF,UAAd,EAA0BD,MAA1B,CAAP;AACD,GAPD,CAOE,OAAOI,KAAP,EAAc;AACd,UAAM,IAAIC,KAAJ,CAAW,YAAWb,OAAQ,KAAIY,KAAK,CAACE,OAAQ,EAAhD,CAAN;AACD;AACF","sourcesContent":["// Copyright 2017-2021 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n// Original implementation: https://github.com/paritytech/polka-ui/blob/4858c094684769080f5811f32b081dd7780b0880/src/polkadot.js#L6\nimport { assert, isHex, isU8a, u8aToU8a } from '@polkadot/util';\nimport { base58Decode } from \"../base58/decode.js\";\nimport { checkAddressChecksum } from \"./checksum.js\";\nimport { defaults } from \"./defaults.js\";\nexport function decodeAddress(encoded, ignoreChecksum, ss58Format = -1) {\n  assert(encoded, 'Invalid empty address passed');\n\n  if (isU8a(encoded) || isHex(encoded)) {\n    return u8aToU8a(encoded);\n  }\n\n  try {\n    const decoded = base58Decode(encoded);\n    assert(defaults.allowedEncodedLengths.includes(decoded.length), 'Invalid decoded address length');\n    const [isValid, endPos, ss58Length, ss58Decoded] = checkAddressChecksum(decoded);\n    assert(ignoreChecksum || isValid, 'Invalid decoded address checksum');\n    assert([-1, ss58Decoded].includes(ss58Format), () => `Expected ss58Format ${ss58Format}, received ${ss58Decoded}`);\n    return decoded.slice(ss58Length, endPos);\n  } catch (error) {\n    throw new Error(`Decoding ${encoded}: ${error.message}`);\n  }\n}"]},"metadata":{},"sourceType":"module"}