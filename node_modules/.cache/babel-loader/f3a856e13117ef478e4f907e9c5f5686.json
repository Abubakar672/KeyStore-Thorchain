{"ast":null,"code":"var Buffer = require('safe-buffer').Buffer;\n\nvar bcrypto = require('./crypto');\n\nvar fastMerkleRoot = require('merkle-lib/fastRoot');\n\nvar typeforce = require('typeforce');\n\nvar types = require('./types');\n\nvar varuint = require('varuint-bitcoin');\n\nvar Transaction = require('./transaction');\n\nfunction Block() {\n  this.version = 1;\n  this.prevHash = null;\n  this.merkleRoot = null;\n  this.timestamp = 0;\n  this.bits = 0;\n  this.nonce = 0;\n}\n\nBlock.fromBuffer = function (buffer) {\n  if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)');\n  var offset = 0;\n\n  function readSlice(n) {\n    offset += n;\n    return buffer.slice(offset - n, offset);\n  }\n\n  function readUInt32() {\n    var i = buffer.readUInt32LE(offset);\n    offset += 4;\n    return i;\n  }\n\n  function readInt32() {\n    var i = buffer.readInt32LE(offset);\n    offset += 4;\n    return i;\n  }\n\n  var block = new Block();\n  block.version = readInt32();\n  block.prevHash = readSlice(32);\n  block.merkleRoot = readSlice(32);\n  block.timestamp = readUInt32();\n  block.bits = readUInt32();\n  block.nonce = readUInt32();\n  if (buffer.length === 80) return block;\n\n  function readVarInt() {\n    var vi = varuint.decode(buffer, offset);\n    offset += varuint.decode.bytes;\n    return vi;\n  }\n\n  function readTransaction() {\n    var tx = Transaction.fromBuffer(buffer.slice(offset), true);\n    offset += tx.byteLength();\n    return tx;\n  }\n\n  var nTransactions = readVarInt();\n  block.transactions = [];\n\n  for (var i = 0; i < nTransactions; ++i) {\n    var tx = readTransaction();\n    block.transactions.push(tx);\n  }\n\n  return block;\n};\n\nBlock.prototype.byteLength = function (headersOnly) {\n  if (headersOnly || !this.transactions) return 80;\n  return 80 + varuint.encodingLength(this.transactions.length) + this.transactions.reduce(function (a, x) {\n    return a + x.byteLength();\n  }, 0);\n};\n\nBlock.fromHex = function (hex) {\n  return Block.fromBuffer(Buffer.from(hex, 'hex'));\n};\n\nBlock.prototype.getHash = function () {\n  return bcrypto.hash256(this.toBuffer(true));\n};\n\nBlock.prototype.getId = function () {\n  return this.getHash().reverse().toString('hex');\n};\n\nBlock.prototype.getUTCDate = function () {\n  var date = new Date(0); // epoch\n\n  date.setUTCSeconds(this.timestamp);\n  return date;\n}; // TODO: buffer, offset compatibility\n\n\nBlock.prototype.toBuffer = function (headersOnly) {\n  var buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));\n  var offset = 0;\n\n  function writeSlice(slice) {\n    slice.copy(buffer, offset);\n    offset += slice.length;\n  }\n\n  function writeInt32(i) {\n    buffer.writeInt32LE(i, offset);\n    offset += 4;\n  }\n\n  function writeUInt32(i) {\n    buffer.writeUInt32LE(i, offset);\n    offset += 4;\n  }\n\n  writeInt32(this.version);\n  writeSlice(this.prevHash);\n  writeSlice(this.merkleRoot);\n  writeUInt32(this.timestamp);\n  writeUInt32(this.bits);\n  writeUInt32(this.nonce);\n  if (headersOnly || !this.transactions) return buffer;\n  varuint.encode(this.transactions.length, buffer, offset);\n  offset += varuint.encode.bytes;\n  this.transactions.forEach(function (tx) {\n    var txSize = tx.byteLength(); // TODO: extract from toBuffer?\n\n    tx.toBuffer(buffer, offset);\n    offset += txSize;\n  });\n  return buffer;\n};\n\nBlock.prototype.toHex = function (headersOnly) {\n  return this.toBuffer(headersOnly).toString('hex');\n};\n\nBlock.calculateTarget = function (bits) {\n  var exponent = ((bits & 0xff000000) >> 24) - 3;\n  var mantissa = bits & 0x007fffff;\n  var target = Buffer.alloc(32, 0);\n  target.writeUInt32BE(mantissa, 28 - exponent);\n  return target;\n};\n\nBlock.calculateMerkleRoot = function (transactions) {\n  typeforce([{\n    getHash: types.Function\n  }], transactions);\n  if (transactions.length === 0) throw TypeError('Cannot compute merkle root for zero transactions');\n  var hashes = transactions.map(function (transaction) {\n    return transaction.getHash();\n  });\n  return fastMerkleRoot(hashes, bcrypto.hash256);\n};\n\nBlock.prototype.checkMerkleRoot = function () {\n  if (!this.transactions) return false;\n  var actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);\n  return this.merkleRoot.compare(actualMerkleRoot) === 0;\n};\n\nBlock.prototype.checkProofOfWork = function () {\n  var hash = this.getHash().reverse();\n  var target = Block.calculateTarget(this.bits);\n  return hash.compare(target) <= 0;\n};\n\nmodule.exports = Block;","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@psf/bitcoincashjs-lib/src/block.js"],"names":["Buffer","require","bcrypto","fastMerkleRoot","typeforce","types","varuint","Transaction","Block","version","prevHash","merkleRoot","timestamp","bits","nonce","fromBuffer","buffer","length","Error","offset","readSlice","n","slice","readUInt32","i","readUInt32LE","readInt32","readInt32LE","block","readVarInt","vi","decode","bytes","readTransaction","tx","byteLength","nTransactions","transactions","push","prototype","headersOnly","encodingLength","reduce","a","x","fromHex","hex","from","getHash","hash256","toBuffer","getId","reverse","toString","getUTCDate","date","Date","setUTCSeconds","allocUnsafe","writeSlice","copy","writeInt32","writeInt32LE","writeUInt32","writeUInt32LE","encode","forEach","txSize","toHex","calculateTarget","exponent","mantissa","target","alloc","writeUInt32BE","calculateMerkleRoot","Function","TypeError","hashes","map","transaction","checkMerkleRoot","actualMerkleRoot","compare","checkProofOfWork","hash","module","exports"],"mappings":"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","sourcesContent":["var Buffer = require('safe-buffer').Buffer\nvar bcrypto = require('./crypto')\nvar fastMerkleRoot = require('merkle-lib/fastRoot')\nvar typeforce = require('typeforce')\nvar types = require('./types')\nvar varuint = require('varuint-bitcoin')\n\nvar Transaction = require('./transaction')\n\nfunction Block () {\n  this.version = 1\n  this.prevHash = null\n  this.merkleRoot = null\n  this.timestamp = 0\n  this.bits = 0\n  this.nonce = 0\n}\n\nBlock.fromBuffer = function (buffer) {\n  if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)')\n\n  var offset = 0\n  function readSlice (n) {\n    offset += n\n    return buffer.slice(offset - n, offset)\n  }\n\n  function readUInt32 () {\n    var i = buffer.readUInt32LE(offset)\n    offset += 4\n    return i\n  }\n\n  function readInt32 () {\n    var i = buffer.readInt32LE(offset)\n    offset += 4\n    return i\n  }\n\n  var block = new Block()\n  block.version = readInt32()\n  block.prevHash = readSlice(32)\n  block.merkleRoot = readSlice(32)\n  block.timestamp = readUInt32()\n  block.bits = readUInt32()\n  block.nonce = readUInt32()\n\n  if (buffer.length === 80) return block\n\n  function readVarInt () {\n    var vi = varuint.decode(buffer, offset)\n    offset += varuint.decode.bytes\n    return vi\n  }\n\n  function readTransaction () {\n    var tx = Transaction.fromBuffer(buffer.slice(offset), true)\n    offset += tx.byteLength()\n    return tx\n  }\n\n  var nTransactions = readVarInt()\n  block.transactions = []\n\n  for (var i = 0; i < nTransactions; ++i) {\n    var tx = readTransaction()\n    block.transactions.push(tx)\n  }\n\n  return block\n}\n\nBlock.prototype.byteLength = function (headersOnly) {\n  if (headersOnly || !this.transactions) return 80\n\n  return 80 + varuint.encodingLength(this.transactions.length) + this.transactions.reduce(function (a, x) {\n    return a + x.byteLength()\n  }, 0)\n}\n\nBlock.fromHex = function (hex) {\n  return Block.fromBuffer(Buffer.from(hex, 'hex'))\n}\n\nBlock.prototype.getHash = function () {\n  return bcrypto.hash256(this.toBuffer(true))\n}\n\nBlock.prototype.getId = function () {\n  return this.getHash().reverse().toString('hex')\n}\n\nBlock.prototype.getUTCDate = function () {\n  var date = new Date(0) // epoch\n  date.setUTCSeconds(this.timestamp)\n\n  return date\n}\n\n// TODO: buffer, offset compatibility\nBlock.prototype.toBuffer = function (headersOnly) {\n  var buffer = Buffer.allocUnsafe(this.byteLength(headersOnly))\n\n  var offset = 0\n  function writeSlice (slice) {\n    slice.copy(buffer, offset)\n    offset += slice.length\n  }\n\n  function writeInt32 (i) {\n    buffer.writeInt32LE(i, offset)\n    offset += 4\n  }\n  function writeUInt32 (i) {\n    buffer.writeUInt32LE(i, offset)\n    offset += 4\n  }\n\n  writeInt32(this.version)\n  writeSlice(this.prevHash)\n  writeSlice(this.merkleRoot)\n  writeUInt32(this.timestamp)\n  writeUInt32(this.bits)\n  writeUInt32(this.nonce)\n\n  if (headersOnly || !this.transactions) return buffer\n\n  varuint.encode(this.transactions.length, buffer, offset)\n  offset += varuint.encode.bytes\n\n  this.transactions.forEach(function (tx) {\n    var txSize = tx.byteLength() // TODO: extract from toBuffer?\n    tx.toBuffer(buffer, offset)\n    offset += txSize\n  })\n\n  return buffer\n}\n\nBlock.prototype.toHex = function (headersOnly) {\n  return this.toBuffer(headersOnly).toString('hex')\n}\n\nBlock.calculateTarget = function (bits) {\n  var exponent = ((bits & 0xff000000) >> 24) - 3\n  var mantissa = bits & 0x007fffff\n  var target = Buffer.alloc(32, 0)\n  target.writeUInt32BE(mantissa, 28 - exponent)\n  return target\n}\n\nBlock.calculateMerkleRoot = function (transactions) {\n  typeforce([{ getHash: types.Function }], transactions)\n  if (transactions.length === 0) throw TypeError('Cannot compute merkle root for zero transactions')\n\n  var hashes = transactions.map(function (transaction) {\n    return transaction.getHash()\n  })\n\n  return fastMerkleRoot(hashes, bcrypto.hash256)\n}\n\nBlock.prototype.checkMerkleRoot = function () {\n  if (!this.transactions) return false\n\n  var actualMerkleRoot = Block.calculateMerkleRoot(this.transactions)\n  return this.merkleRoot.compare(actualMerkleRoot) === 0\n}\n\nBlock.prototype.checkProofOfWork = function () {\n  var hash = this.getHash().reverse()\n  var target = Block.calculateTarget(this.bits)\n\n  return hash.compare(target) <= 0\n}\n\nmodule.exports = Block\n"]},"metadata":{},"sourceType":"script"}