{"ast":null,"code":"var bip66 = require('bip66');\n\nvar typeforce = require('typeforce');\n\nvar types = require('./types');\n\nvar BigInteger = require('bigi');\n\nfunction ECSignature(r, s) {\n  typeforce(types.tuple(types.BigInt, types.BigInt), arguments);\n  this.r = r;\n  this.s = s;\n}\n\nECSignature.ECDSA = 0x00;\nECSignature.SCHNORR = 0x01;\n\nECSignature.parseCompact = function (buffer) {\n  typeforce(types.BufferN(65), buffer);\n  var flagByte = buffer.readUInt8(0) - 27;\n  if (flagByte !== (flagByte & 7)) throw new Error('Invalid signature parameter');\n  var compressed = !!(flagByte & 4);\n  var recoveryParam = flagByte & 3;\n  var signature = ECSignature.fromRSBuffer(buffer.slice(1));\n  return {\n    compressed: compressed,\n    i: recoveryParam,\n    signature: signature\n  };\n};\n\nECSignature.fromRSBuffer = function (buffer) {\n  typeforce(types.BufferN(64), buffer);\n  var r = BigInteger.fromBuffer(buffer.slice(0, 32));\n  var s = BigInteger.fromBuffer(buffer.slice(32, 64));\n  return new ECSignature(r, s);\n};\n\nECSignature.fromDER = function (buffer) {\n  var decode = bip66.decode(buffer);\n  var r = BigInteger.fromDERInteger(decode.r);\n  var s = BigInteger.fromDERInteger(decode.s);\n  return new ECSignature(r, s);\n}; // BIP62: 1 byte hashType flag (only 0x01, 0x02, 0x03, 0x81, 0x82 and 0x83 are allowed)\n\n\nECSignature.parseScriptSignature = function (buffer) {\n  var hashType = buffer.readUInt8(buffer.length - 1);\n  var hashTypeMod = hashType & ~0xc0;\n  if (hashTypeMod <= 0x00 || hashTypeMod >= 0x04) throw new Error('Invalid hashType ' + hashType);\n  return {\n    signature: ECSignature.fromDER(buffer.slice(0, -1)),\n    hashType: hashType\n  };\n};\n\nECSignature.prototype.toCompact = function (i, compressed) {\n  if (compressed) {\n    i += 4;\n  }\n\n  i += 27;\n  var buffer = Buffer.alloc(65);\n  buffer.writeUInt8(i, 0);\n  this.toRSBuffer(buffer, 1);\n  return buffer;\n};\n\nECSignature.prototype.toDER = function () {\n  var r = Buffer.from(this.r.toDERInteger());\n  var s = Buffer.from(this.s.toDERInteger());\n  return bip66.encode(r, s);\n};\n\nECSignature.prototype.toRSBuffer = function (buffer, offset) {\n  if (!offset) offset = 0;\n  buffer = buffer || Buffer.alloc(64);\n  this.r.toBuffer(32).copy(buffer, offset);\n  this.s.toBuffer(32).copy(buffer, offset + 32);\n  return buffer;\n};\n\nECSignature.prototype.toScriptSignature = function (hashType, signatureAlgorithm) {\n  if (!signatureAlgorithm) signatureAlgorithm = ECSignature.ECDSA;\n  var hashTypeMod = hashType & ~0xc0;\n  if (hashTypeMod <= 0 || hashTypeMod >= 4) throw new Error('Invalid hashType ' + hashType);\n  var hashTypeBuffer = Buffer.alloc(1);\n  hashTypeBuffer.writeUInt8(hashType, 0);\n\n  if (signatureAlgorithm === ECSignature.ECDSA) {\n    return Buffer.concat([this.toDER(), hashTypeBuffer]);\n  } else if (signatureAlgorithm === ECSignature.SCHNORR) {\n    return Buffer.concat([this.toRSBuffer(), hashTypeBuffer]);\n  } else {\n    throw new Error('Invalid signature Algorithm');\n  }\n};\n\nmodule.exports = ECSignature;","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@psf/bitcoincashjs-lib/src/ecsignature.js"],"names":["bip66","require","typeforce","types","BigInteger","ECSignature","r","s","tuple","BigInt","arguments","ECDSA","SCHNORR","parseCompact","buffer","BufferN","flagByte","readUInt8","Error","compressed","recoveryParam","signature","fromRSBuffer","slice","i","fromBuffer","fromDER","decode","fromDERInteger","parseScriptSignature","hashType","length","hashTypeMod","prototype","toCompact","Buffer","alloc","writeUInt8","toRSBuffer","toDER","from","toDERInteger","encode","offset","toBuffer","copy","toScriptSignature","signatureAlgorithm","hashTypeBuffer","concat","module","exports"],"mappings":"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","sourcesContent":["var bip66 = require('bip66')\nvar typeforce = require('typeforce')\nvar types = require('./types')\n\nvar BigInteger = require('bigi')\n\nfunction ECSignature (r, s) {\n  typeforce(types.tuple(types.BigInt, types.BigInt), arguments)\n\n  this.r = r\n  this.s = s\n}\n\nECSignature.ECDSA = 0x00\nECSignature.SCHNORR = 0x01\n\nECSignature.parseCompact = function (buffer) {\n  typeforce(types.BufferN(65), buffer)\n\n  var flagByte = buffer.readUInt8(0) - 27\n  if (flagByte !== (flagByte & 7)) throw new Error('Invalid signature parameter')\n\n  var compressed = !!(flagByte & 4)\n  var recoveryParam = flagByte & 3\n  var signature = ECSignature.fromRSBuffer(buffer.slice(1))\n\n  return {\n    compressed: compressed,\n    i: recoveryParam,\n    signature: signature\n  }\n}\n\nECSignature.fromRSBuffer = function (buffer) {\n  typeforce(types.BufferN(64), buffer)\n\n  var r = BigInteger.fromBuffer(buffer.slice(0, 32))\n  var s = BigInteger.fromBuffer(buffer.slice(32, 64))\n  return new ECSignature(r, s)\n}\n\nECSignature.fromDER = function (buffer) {\n  var decode = bip66.decode(buffer)\n  var r = BigInteger.fromDERInteger(decode.r)\n  var s = BigInteger.fromDERInteger(decode.s)\n\n  return new ECSignature(r, s)\n}\n\n// BIP62: 1 byte hashType flag (only 0x01, 0x02, 0x03, 0x81, 0x82 and 0x83 are allowed)\nECSignature.parseScriptSignature = function (buffer) {\n  var hashType = buffer.readUInt8(buffer.length - 1)\n  var hashTypeMod = hashType & ~0xc0\n\n  if (hashTypeMod <= 0x00 || hashTypeMod >= 0x04) throw new Error('Invalid hashType ' + hashType)\n\n  return {\n    signature: ECSignature.fromDER(buffer.slice(0, -1)),\n    hashType: hashType\n  }\n}\n\nECSignature.prototype.toCompact = function (i, compressed) {\n  if (compressed) {\n    i += 4\n  }\n\n  i += 27\n\n  var buffer = Buffer.alloc(65)\n  buffer.writeUInt8(i, 0)\n  this.toRSBuffer(buffer, 1)\n  return buffer\n}\n\nECSignature.prototype.toDER = function () {\n  var r = Buffer.from(this.r.toDERInteger())\n  var s = Buffer.from(this.s.toDERInteger())\n\n  return bip66.encode(r, s)\n}\n\nECSignature.prototype.toRSBuffer = function (buffer, offset) {\n  if(!offset) offset = 0\n  buffer = buffer || Buffer.alloc(64)\n  this.r.toBuffer(32).copy(buffer, offset)\n  this.s.toBuffer(32).copy(buffer, offset + 32)\n  return buffer\n}\n\nECSignature.prototype.toScriptSignature = function (hashType, signatureAlgorithm) {\n  if(!signatureAlgorithm) signatureAlgorithm = ECSignature.ECDSA\n\n  var hashTypeMod = hashType & ~0xc0\n  if (hashTypeMod <= 0 || hashTypeMod >= 4) throw new Error('Invalid hashType ' + hashType)\n\n  var hashTypeBuffer = Buffer.alloc(1)\n  hashTypeBuffer.writeUInt8(hashType, 0)\n\n  if(signatureAlgorithm === ECSignature.ECDSA){\n    return Buffer.concat([this.toDER(), hashTypeBuffer])\n  } else if(signatureAlgorithm === ECSignature.SCHNORR) {\n    return Buffer.concat([this.toRSBuffer(), hashTypeBuffer])\n  } else {\n    throw new Error('Invalid signature Algorithm')\n  }\n}\n\nmodule.exports = ECSignature\n"]},"metadata":{},"sourceType":"script"}