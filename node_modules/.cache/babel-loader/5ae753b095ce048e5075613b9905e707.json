{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { assert, compactAddLength, compactStripLength, isUndefined, stringCamelCase, stringLowerFirst, u8aConcat, u8aToU8a } from '@polkadot/util';\nimport { xxhashAsU8a } from '@polkadot/util-crypto';\nimport { Raw } from \"../../../codec/index.js\";\nimport { getHasher } from \"./getHasher.js\";\n/** @internal */\n\nfunction createKeyRaw(registry, itemFn, keys, hashers, args) {\n  return u8aConcat(xxhashAsU8a(itemFn.prefix, 128), xxhashAsU8a(itemFn.method, 128), ...keys.map((type, index) => getHasher(hashers[index])(registry.createType(registry.createLookupType(type), args[index]).toU8a())));\n}\n/** @internal */\n\n\nfunction createKey(registry, itemFn, keys, hashers, args) {\n  const {\n    method,\n    section\n  } = itemFn;\n  assert(Array.isArray(args), () => `Call to ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs ${keys.length} arguments`);\n  assert(args.filter(a => !isUndefined(a)).length === keys.length, () => `Call to ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs ${keys.length} arguments, found [${args.join(', ')}]`); // as per createKey, always add the length prefix (underlying it is Bytes)\n\n  return compactAddLength(createKeyRaw(registry, itemFn, keys, hashers, args));\n}\n/** @internal */\n\n\nfunction expandWithMeta({\n  meta,\n  method,\n  prefix,\n  section\n}, _storageFn) {\n  const storageFn = _storageFn;\n  storageFn.meta = meta;\n  storageFn.method = stringLowerFirst(method);\n  storageFn.prefix = prefix;\n  storageFn.section = section; // explicitly add the actual method in the toJSON, this gets used to determine caching and without it\n  // instances (e.g. collective) will not work since it is only matched on param meta\n\n  storageFn.toJSON = () => _objectSpread(_objectSpread({}, meta.toJSON()), {}, {\n    storage: {\n      method,\n      prefix,\n      section\n    }\n  });\n\n  return storageFn;\n}\n/** @internal */\n\n\nfunction extendHeadMeta(registry, {\n  meta: {\n    docs,\n    name,\n    type\n  },\n  section\n}, {\n  method\n}, iterFn) {\n  const outputType = registry.createLookupType(type.asMap.key); // metadata with a fallback value using the type of the key, the normal\n  // meta fallback only applies to actual entry values, create one for head\n\n  iterFn.meta = registry.createType('StorageEntryMetadataLatest', {\n    docs,\n    fallback: registry.createType('Bytes'),\n    modifier: registry.createType('StorageEntryModifierLatest', 1),\n    // required\n    name,\n    // FIXME???\n    type: registry.createType('StorageEntryTypeLatest', outputType, 0)\n  });\n  return (...args) => registry.createType('StorageKey', iterFn(...args), {\n    method,\n    section\n  });\n}\n/** @internal */\n\n\nfunction extendPrefixedMap(registry, itemFn, storageFn) {\n  const {\n    meta: {\n      type\n    },\n    method,\n    section\n  } = itemFn;\n  storageFn.iterKey = extendHeadMeta(registry, itemFn, storageFn, (...args) => {\n    assert(args.length === 0 || type.isMap && args.length < type.asMap.hashers.length, () => `Iteration ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs arguments to be at least one less than the full arguments, found [${args.join(', ')}]`);\n\n    if (args.length) {\n      if (type.isMap) {\n        const {\n          hashers,\n          key\n        } = type.asMap;\n        const keysVec = hashers.length === 1 ? [key] : [...registry.lookup.getSiType(key).def.asTuple.map(t => t)];\n        const hashersVec = [...hashers];\n        return new Raw(registry, createKeyRaw(registry, itemFn, keysVec.slice(0, args.length), hashersVec.slice(0, args.length), args));\n      }\n    }\n\n    return new Raw(registry, createKeyRaw(registry, itemFn, [], [], []));\n  });\n  return storageFn;\n}\n/** @internal */\n\n\nexport function createFunction(registry, itemFn, options) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn; // Can only have zero or one argument:\n  //   - storage.system.account(address)\n  //   - storage.timestamp.blockPeriod()\n  // For higher-map queries the params are passed in as an tuple, [key1, key2]\n\n  const storageFn = expandWithMeta(itemFn, (...args) => {\n    if (type.isPlain) {\n      return options.skipHashing ? compactAddLength(u8aToU8a(options.key)) : createKey(registry, itemFn, [], [], []);\n    }\n\n    const {\n      hashers,\n      key\n    } = type.asMap;\n    return hashers.length === 1 ? createKey(registry, itemFn, [key], hashers, args) : createKey(registry, itemFn, registry.lookup.getSiType(key).def.asTuple.map(t => t), hashers, args);\n  });\n\n  if (type.isMap) {\n    extendPrefixedMap(registry, itemFn, storageFn);\n  }\n\n  storageFn.keyPrefix = (...args) => storageFn.iterKey && storageFn.iterKey(...args) || compactStripLength(storageFn())[1];\n\n  return storageFn;\n}","map":{"version":3,"sources":["/home/abubakar/Desktop/KeyStore-Thorchain/node_modules/@polkadot/types/metadata/decorate/storage/createFunction.js"],"names":["_defineProperty","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","assert","compactAddLength","compactStripLength","isUndefined","stringCamelCase","stringLowerFirst","u8aConcat","u8aToU8a","xxhashAsU8a","Raw","getHasher","createKeyRaw","registry","itemFn","hashers","args","prefix","method","map","type","index","createType","createLookupType","toU8a","createKey","section","Array","isArray","a","join","expandWithMeta","meta","_storageFn","storageFn","toJSON","storage","extendHeadMeta","docs","name","iterFn","outputType","asMap","fallback","modifier","extendPrefixedMap","iterKey","isMap","keysVec","lookup","getSiType","def","asTuple","t","hashersVec","slice","createFunction","options","isPlain","skipHashing","keyPrefix"],"mappings":"AAAA,OAAOA,eAAP,MAA4B,2CAA5B;;AAEA,SAASC,OAAT,CAAiBC,MAAjB,EAAyBC,cAAzB,EAAyC;AAAE,MAAIC,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYF,MAAZ,CAAX;;AAAgC,MAAIG,MAAM,CAACC,qBAAX,EAAkC;AAAE,QAAIC,OAAO,GAAGF,MAAM,CAACC,qBAAP,CAA6BJ,MAA7B,CAAd;;AAAoD,QAAIC,cAAJ,EAAoB;AAAEI,MAAAA,OAAO,GAAGA,OAAO,CAACC,MAAR,CAAe,UAAUC,GAAV,EAAe;AAAE,eAAOJ,MAAM,CAACK,wBAAP,CAAgCR,MAAhC,EAAwCO,GAAxC,EAA6CE,UAApD;AAAiE,OAAjG,CAAV;AAA+G;;AAACP,IAAAA,IAAI,CAACQ,IAAL,CAAUC,KAAV,CAAgBT,IAAhB,EAAsBG,OAAtB;AAAiC;;AAAC,SAAOH,IAAP;AAAc;;AAEzV,SAASU,aAAT,CAAuBC,MAAvB,EAA+B;AAAE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,SAAS,CAACC,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;AAAE,QAAIG,MAAM,GAAGF,SAAS,CAACD,CAAD,CAAT,IAAgB,IAAhB,GAAuBC,SAAS,CAACD,CAAD,CAAhC,GAAsC,EAAnD;;AAAuD,QAAIA,CAAC,GAAG,CAAR,EAAW;AAAEf,MAAAA,OAAO,CAACI,MAAM,CAACc,MAAD,CAAP,EAAiB,IAAjB,CAAP,CAA8BC,OAA9B,CAAsC,UAAUC,GAAV,EAAe;AAAErB,QAAAA,eAAe,CAACe,MAAD,EAASM,GAAT,EAAcF,MAAM,CAACE,GAAD,CAApB,CAAf;AAA4C,OAAnG;AAAuG,KAApH,MAA0H,IAAIhB,MAAM,CAACiB,yBAAX,EAAsC;AAAEjB,MAAAA,MAAM,CAACkB,gBAAP,CAAwBR,MAAxB,EAAgCV,MAAM,CAACiB,yBAAP,CAAiCH,MAAjC,CAAhC;AAA4E,KAApH,MAA0H;AAAElB,MAAAA,OAAO,CAACI,MAAM,CAACc,MAAD,CAAP,CAAP,CAAwBC,OAAxB,CAAgC,UAAUC,GAAV,EAAe;AAAEhB,QAAAA,MAAM,CAACmB,cAAP,CAAsBT,MAAtB,EAA8BM,GAA9B,EAAmChB,MAAM,CAACK,wBAAP,CAAgCS,MAAhC,EAAwCE,GAAxC,CAAnC;AAAmF,OAApI;AAAwI;AAAE;;AAAC,SAAON,MAAP;AAAgB,C,CAEthB;AACA;;;AACA,SAASU,MAAT,EAAiBC,gBAAjB,EAAmCC,kBAAnC,EAAuDC,WAAvD,EAAoEC,eAApE,EAAqFC,gBAArF,EAAuGC,SAAvG,EAAkHC,QAAlH,QAAkI,gBAAlI;AACA,SAASC,WAAT,QAA4B,uBAA5B;AACA,SAASC,GAAT,QAAoB,yBAApB;AACA,SAASC,SAAT,QAA0B,gBAA1B;AAEA;;AACA,SAASC,YAAT,CAAsBC,QAAtB,EAAgCC,MAAhC,EAAwClC,IAAxC,EAA8CmC,OAA9C,EAAuDC,IAAvD,EAA6D;AAC3D,SAAOT,SAAS,CAACE,WAAW,CAACK,MAAM,CAACG,MAAR,EAAgB,GAAhB,CAAZ,EAAkCR,WAAW,CAACK,MAAM,CAACI,MAAR,EAAgB,GAAhB,CAA7C,EAAmE,GAAGtC,IAAI,CAACuC,GAAL,CAAS,CAACC,IAAD,EAAOC,KAAP,KAAiBV,SAAS,CAACI,OAAO,CAACM,KAAD,CAAR,CAAT,CAA0BR,QAAQ,CAACS,UAAT,CAAoBT,QAAQ,CAACU,gBAAT,CAA0BH,IAA1B,CAApB,EAAqDJ,IAAI,CAACK,KAAD,CAAzD,EAAkEG,KAAlE,EAA1B,CAA1B,CAAtE,CAAhB;AACD;AACD;;;AAGA,SAASC,SAAT,CAAmBZ,QAAnB,EAA6BC,MAA7B,EAAqClC,IAArC,EAA2CmC,OAA3C,EAAoDC,IAApD,EAA0D;AACxD,QAAM;AACJE,IAAAA,MADI;AAEJQ,IAAAA;AAFI,MAGFZ,MAHJ;AAIAb,EAAAA,MAAM,CAAC0B,KAAK,CAACC,OAAN,CAAcZ,IAAd,CAAD,EAAsB,MAAO,WAAUX,eAAe,CAACqB,OAAO,IAAI,SAAZ,CAAuB,IAAGrB,eAAe,CAACa,MAAM,IAAI,SAAX,CAAsB,UAAStC,IAAI,CAACc,MAAO,YAA1I,CAAN;AACAO,EAAAA,MAAM,CAACe,IAAI,CAAChC,MAAL,CAAY6C,CAAC,IAAI,CAACzB,WAAW,CAACyB,CAAD,CAA7B,EAAkCnC,MAAlC,KAA6Cd,IAAI,CAACc,MAAnD,EAA2D,MAAO,WAAUW,eAAe,CAACqB,OAAO,IAAI,SAAZ,CAAuB,IAAGrB,eAAe,CAACa,MAAM,IAAI,SAAX,CAAsB,UAAStC,IAAI,CAACc,MAAO,sBAAqBsB,IAAI,CAACc,IAAL,CAAU,IAAV,CAAgB,GAApN,CAAN,CANwD,CAMuK;;AAE/N,SAAO5B,gBAAgB,CAACU,YAAY,CAACC,QAAD,EAAWC,MAAX,EAAmBlC,IAAnB,EAAyBmC,OAAzB,EAAkCC,IAAlC,CAAb,CAAvB;AACD;AACD;;;AAGA,SAASe,cAAT,CAAwB;AACtBC,EAAAA,IADsB;AAEtBd,EAAAA,MAFsB;AAGtBD,EAAAA,MAHsB;AAItBS,EAAAA;AAJsB,CAAxB,EAKGO,UALH,EAKe;AACb,QAAMC,SAAS,GAAGD,UAAlB;AACAC,EAAAA,SAAS,CAACF,IAAV,GAAiBA,IAAjB;AACAE,EAAAA,SAAS,CAAChB,MAAV,GAAmBZ,gBAAgB,CAACY,MAAD,CAAnC;AACAgB,EAAAA,SAAS,CAACjB,MAAV,GAAmBA,MAAnB;AACAiB,EAAAA,SAAS,CAACR,OAAV,GAAoBA,OAApB,CALa,CAKgB;AAC7B;;AAEAQ,EAAAA,SAAS,CAACC,MAAV,GAAmB,MAAM7C,aAAa,CAACA,aAAa,CAAC,EAAD,EAAK0C,IAAI,CAACG,MAAL,EAAL,CAAd,EAAmC,EAAnC,EAAuC;AAC3EC,IAAAA,OAAO,EAAE;AACPlB,MAAAA,MADO;AAEPD,MAAAA,MAFO;AAGPS,MAAAA;AAHO;AADkE,GAAvC,CAAtC;;AAQA,SAAOQ,SAAP;AACD;AACD;;;AAGA,SAASG,cAAT,CAAwBxB,QAAxB,EAAkC;AAChCmB,EAAAA,IAAI,EAAE;AACJM,IAAAA,IADI;AAEJC,IAAAA,IAFI;AAGJnB,IAAAA;AAHI,GAD0B;AAMhCM,EAAAA;AANgC,CAAlC,EAOG;AACDR,EAAAA;AADC,CAPH,EASGsB,MATH,EASW;AACT,QAAMC,UAAU,GAAG5B,QAAQ,CAACU,gBAAT,CAA0BH,IAAI,CAACsB,KAAL,CAAW7C,GAArC,CAAnB,CADS,CACqD;AAC9D;;AAEA2C,EAAAA,MAAM,CAACR,IAAP,GAAcnB,QAAQ,CAACS,UAAT,CAAoB,4BAApB,EAAkD;AAC9DgB,IAAAA,IAD8D;AAE9DK,IAAAA,QAAQ,EAAE9B,QAAQ,CAACS,UAAT,CAAoB,OAApB,CAFoD;AAG9DsB,IAAAA,QAAQ,EAAE/B,QAAQ,CAACS,UAAT,CAAoB,4BAApB,EAAkD,CAAlD,CAHoD;AAI9D;AACAiB,IAAAA,IAL8D;AAM9D;AACAnB,IAAAA,IAAI,EAAEP,QAAQ,CAACS,UAAT,CAAoB,wBAApB,EAA8CmB,UAA9C,EAA0D,CAA1D;AAPwD,GAAlD,CAAd;AASA,SAAO,CAAC,GAAGzB,IAAJ,KAAaH,QAAQ,CAACS,UAAT,CAAoB,YAApB,EAAkCkB,MAAM,CAAC,GAAGxB,IAAJ,CAAxC,EAAmD;AACrEE,IAAAA,MADqE;AAErEQ,IAAAA;AAFqE,GAAnD,CAApB;AAID;AACD;;;AAGA,SAASmB,iBAAT,CAA2BhC,QAA3B,EAAqCC,MAArC,EAA6CoB,SAA7C,EAAwD;AACtD,QAAM;AACJF,IAAAA,IAAI,EAAE;AACJZ,MAAAA;AADI,KADF;AAIJF,IAAAA,MAJI;AAKJQ,IAAAA;AALI,MAMFZ,MANJ;AAOAoB,EAAAA,SAAS,CAACY,OAAV,GAAoBT,cAAc,CAACxB,QAAD,EAAWC,MAAX,EAAmBoB,SAAnB,EAA8B,CAAC,GAAGlB,IAAJ,KAAa;AAC3Ef,IAAAA,MAAM,CAACe,IAAI,CAACtB,MAAL,KAAgB,CAAhB,IAAqB0B,IAAI,CAAC2B,KAAL,IAAc/B,IAAI,CAACtB,MAAL,GAAc0B,IAAI,CAACsB,KAAL,CAAW3B,OAAX,CAAmBrB,MAArE,EAA6E,MAAO,aAAYW,eAAe,CAACqB,OAAO,IAAI,SAAZ,CAAuB,IAAGrB,eAAe,CAACa,MAAM,IAAI,SAAX,CAAsB,4EAA2EF,IAAI,CAACc,IAAL,CAAU,IAAV,CAAgB,GAAzQ,CAAN;;AAEA,QAAId,IAAI,CAACtB,MAAT,EAAiB;AACf,UAAI0B,IAAI,CAAC2B,KAAT,EAAgB;AACd,cAAM;AACJhC,UAAAA,OADI;AAEJlB,UAAAA;AAFI,YAGFuB,IAAI,CAACsB,KAHT;AAIA,cAAMM,OAAO,GAAGjC,OAAO,CAACrB,MAAR,KAAmB,CAAnB,GAAuB,CAACG,GAAD,CAAvB,GAA+B,CAAC,GAAGgB,QAAQ,CAACoC,MAAT,CAAgBC,SAAhB,CAA0BrD,GAA1B,EAA+BsD,GAA/B,CAAmCC,OAAnC,CAA2CjC,GAA3C,CAA+CkC,CAAC,IAAIA,CAApD,CAAJ,CAA/C;AACA,cAAMC,UAAU,GAAG,CAAC,GAAGvC,OAAJ,CAAnB;AACA,eAAO,IAAIL,GAAJ,CAAQG,QAAR,EAAkBD,YAAY,CAACC,QAAD,EAAWC,MAAX,EAAmBkC,OAAO,CAACO,KAAR,CAAc,CAAd,EAAiBvC,IAAI,CAACtB,MAAtB,CAAnB,EAAkD4D,UAAU,CAACC,KAAX,CAAiB,CAAjB,EAAoBvC,IAAI,CAACtB,MAAzB,CAAlD,EAAoFsB,IAApF,CAA9B,CAAP;AACD;AACF;;AAED,WAAO,IAAIN,GAAJ,CAAQG,QAAR,EAAkBD,YAAY,CAACC,QAAD,EAAWC,MAAX,EAAmB,EAAnB,EAAuB,EAAvB,EAA2B,EAA3B,CAA9B,CAAP;AACD,GAhBiC,CAAlC;AAiBA,SAAOoB,SAAP;AACD;AACD;;;AAGA,OAAO,SAASsB,cAAT,CAAwB3C,QAAxB,EAAkCC,MAAlC,EAA0C2C,OAA1C,EAAmD;AACxD,QAAM;AACJzB,IAAAA,IAAI,EAAE;AACJZ,MAAAA;AADI;AADF,MAIFN,MAJJ,CADwD,CAK5C;AACZ;AACA;AACA;;AAEA,QAAMoB,SAAS,GAAGH,cAAc,CAACjB,MAAD,EAAS,CAAC,GAAGE,IAAJ,KAAa;AACpD,QAAII,IAAI,CAACsC,OAAT,EAAkB;AAChB,aAAOD,OAAO,CAACE,WAAR,GAAsBzD,gBAAgB,CAACM,QAAQ,CAACiD,OAAO,CAAC5D,GAAT,CAAT,CAAtC,GAAgE4B,SAAS,CAACZ,QAAD,EAAWC,MAAX,EAAmB,EAAnB,EAAuB,EAAvB,EAA2B,EAA3B,CAAhF;AACD;;AAED,UAAM;AACJC,MAAAA,OADI;AAEJlB,MAAAA;AAFI,QAGFuB,IAAI,CAACsB,KAHT;AAIA,WAAO3B,OAAO,CAACrB,MAAR,KAAmB,CAAnB,GAAuB+B,SAAS,CAACZ,QAAD,EAAWC,MAAX,EAAmB,CAACjB,GAAD,CAAnB,EAA0BkB,OAA1B,EAAmCC,IAAnC,CAAhC,GAA2ES,SAAS,CAACZ,QAAD,EAAWC,MAAX,EAAmBD,QAAQ,CAACoC,MAAT,CAAgBC,SAAhB,CAA0BrD,GAA1B,EAA+BsD,GAA/B,CAAmCC,OAAnC,CAA2CjC,GAA3C,CAA+CkC,CAAC,IAAIA,CAApD,CAAnB,EAA2EtC,OAA3E,EAAoFC,IAApF,CAA3F;AACD,GAV+B,CAAhC;;AAYA,MAAII,IAAI,CAAC2B,KAAT,EAAgB;AACdF,IAAAA,iBAAiB,CAAChC,QAAD,EAAWC,MAAX,EAAmBoB,SAAnB,CAAjB;AACD;;AAEDA,EAAAA,SAAS,CAAC0B,SAAV,GAAsB,CAAC,GAAG5C,IAAJ,KAAakB,SAAS,CAACY,OAAV,IAAqBZ,SAAS,CAACY,OAAV,CAAkB,GAAG9B,IAArB,CAArB,IAAmDb,kBAAkB,CAAC+B,SAAS,EAAV,CAAlB,CAAgC,CAAhC,CAAtF;;AAEA,SAAOA,SAAP;AACD","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, compactAddLength, compactStripLength, isUndefined, stringCamelCase, stringLowerFirst, u8aConcat, u8aToU8a } from '@polkadot/util';\nimport { xxhashAsU8a } from '@polkadot/util-crypto';\nimport { Raw } from \"../../../codec/index.js\";\nimport { getHasher } from \"./getHasher.js\";\n\n/** @internal */\nfunction createKeyRaw(registry, itemFn, keys, hashers, args) {\n  return u8aConcat(xxhashAsU8a(itemFn.prefix, 128), xxhashAsU8a(itemFn.method, 128), ...keys.map((type, index) => getHasher(hashers[index])(registry.createType(registry.createLookupType(type), args[index]).toU8a())));\n}\n/** @internal */\n\n\nfunction createKey(registry, itemFn, keys, hashers, args) {\n  const {\n    method,\n    section\n  } = itemFn;\n  assert(Array.isArray(args), () => `Call to ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs ${keys.length} arguments`);\n  assert(args.filter(a => !isUndefined(a)).length === keys.length, () => `Call to ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs ${keys.length} arguments, found [${args.join(', ')}]`); // as per createKey, always add the length prefix (underlying it is Bytes)\n\n  return compactAddLength(createKeyRaw(registry, itemFn, keys, hashers, args));\n}\n/** @internal */\n\n\nfunction expandWithMeta({\n  meta,\n  method,\n  prefix,\n  section\n}, _storageFn) {\n  const storageFn = _storageFn;\n  storageFn.meta = meta;\n  storageFn.method = stringLowerFirst(method);\n  storageFn.prefix = prefix;\n  storageFn.section = section; // explicitly add the actual method in the toJSON, this gets used to determine caching and without it\n  // instances (e.g. collective) will not work since it is only matched on param meta\n\n  storageFn.toJSON = () => _objectSpread(_objectSpread({}, meta.toJSON()), {}, {\n    storage: {\n      method,\n      prefix,\n      section\n    }\n  });\n\n  return storageFn;\n}\n/** @internal */\n\n\nfunction extendHeadMeta(registry, {\n  meta: {\n    docs,\n    name,\n    type\n  },\n  section\n}, {\n  method\n}, iterFn) {\n  const outputType = registry.createLookupType(type.asMap.key); // metadata with a fallback value using the type of the key, the normal\n  // meta fallback only applies to actual entry values, create one for head\n\n  iterFn.meta = registry.createType('StorageEntryMetadataLatest', {\n    docs,\n    fallback: registry.createType('Bytes'),\n    modifier: registry.createType('StorageEntryModifierLatest', 1),\n    // required\n    name,\n    // FIXME???\n    type: registry.createType('StorageEntryTypeLatest', outputType, 0)\n  });\n  return (...args) => registry.createType('StorageKey', iterFn(...args), {\n    method,\n    section\n  });\n}\n/** @internal */\n\n\nfunction extendPrefixedMap(registry, itemFn, storageFn) {\n  const {\n    meta: {\n      type\n    },\n    method,\n    section\n  } = itemFn;\n  storageFn.iterKey = extendHeadMeta(registry, itemFn, storageFn, (...args) => {\n    assert(args.length === 0 || type.isMap && args.length < type.asMap.hashers.length, () => `Iteration ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs arguments to be at least one less than the full arguments, found [${args.join(', ')}]`);\n\n    if (args.length) {\n      if (type.isMap) {\n        const {\n          hashers,\n          key\n        } = type.asMap;\n        const keysVec = hashers.length === 1 ? [key] : [...registry.lookup.getSiType(key).def.asTuple.map(t => t)];\n        const hashersVec = [...hashers];\n        return new Raw(registry, createKeyRaw(registry, itemFn, keysVec.slice(0, args.length), hashersVec.slice(0, args.length), args));\n      }\n    }\n\n    return new Raw(registry, createKeyRaw(registry, itemFn, [], [], []));\n  });\n  return storageFn;\n}\n/** @internal */\n\n\nexport function createFunction(registry, itemFn, options) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn; // Can only have zero or one argument:\n  //   - storage.system.account(address)\n  //   - storage.timestamp.blockPeriod()\n  // For higher-map queries the params are passed in as an tuple, [key1, key2]\n\n  const storageFn = expandWithMeta(itemFn, (...args) => {\n    if (type.isPlain) {\n      return options.skipHashing ? compactAddLength(u8aToU8a(options.key)) : createKey(registry, itemFn, [], [], []);\n    }\n\n    const {\n      hashers,\n      key\n    } = type.asMap;\n    return hashers.length === 1 ? createKey(registry, itemFn, [key], hashers, args) : createKey(registry, itemFn, registry.lookup.getSiType(key).def.asTuple.map(t => t), hashers, args);\n  });\n\n  if (type.isMap) {\n    extendPrefixedMap(registry, itemFn, storageFn);\n  }\n\n  storageFn.keyPrefix = (...args) => storageFn.iterKey && storageFn.iterKey(...args) || compactStripLength(storageFn())[1];\n\n  return storageFn;\n}"]},"metadata":{},"sourceType":"module"}